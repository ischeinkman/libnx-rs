pub mod lang_items {
    pub enum c_void {}
    pub type c_char = u8;
    pub type c_int = i32;
    pub type c_long = i64;
    pub type c_longlong = i64;
    pub type c_schar = i8;
    pub type c_short = i16;
    pub type c_uchar = u8;
    pub type c_uint = u32;
    pub type c_ulong = u64;
    pub type c_ulonglong = u64;
    pub type c_ushort = u16;
    pub type size_t = u64;
    pub type ssize_t = i64;
    pub type c_float = f32;
    pub type c_double = f64;
}
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __IncompleteArrayField<T> {}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _NEWLIB_VERSION_H__: i32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.0.0\0";
pub const __NEWLIB__: i32 = 3;
pub const __NEWLIB_MINOR__: i32 = 0;
pub const __NEWLIB_PATCHLEVEL__: i32 = 0;
pub const _DEFAULT_SOURCE: i32 = 1;
pub const _POSIX_SOURCE: i32 = 1;
pub const _POSIX_C_SOURCE: i32 = 200809;
pub const _ATFILE_SOURCE: i32 = 1;
pub const __ATFILE_VISIBLE: i32 = 1;
pub const __BSD_VISIBLE: i32 = 1;
pub const __GNU_VISIBLE: i32 = 0;
pub const __ISO_C_VISIBLE: i32 = 2011;
pub const __LARGEFILE_VISIBLE: i32 = 0;
pub const __MISC_VISIBLE: i32 = 1;
pub const __POSIX_VISIBLE: i32 = 200809;
pub const __SVID_VISIBLE: i32 = 1;
pub const __XSI_VISIBLE: i32 = 0;
pub const __SSP_FORTIFY_LEVEL: i32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: i32 = 200112;
pub const _POSIX_TIMERS: i32 = 1;
pub const __have_longlong64: i32 = 1;
pub const __have_long64: i32 = 1;
pub const ___int8_t_defined: i32 = 1;
pub const ___int16_t_defined: i32 = 1;
pub const ___int32_t_defined: i32 = 1;
pub const ___int64_t_defined: i32 = 1;
pub const ___int_least8_t_defined: i32 = 1;
pub const ___int_least16_t_defined: i32 = 1;
pub const ___int_least32_t_defined: i32 = 1;
pub const ___int_least64_t_defined: i32 = 1;
pub const __int20: i32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 2usize] = b"l\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 2usize] = b"l\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 2usize] = b"l\0";
pub const __int8_t_defined: i32 = 1;
pub const __int16_t_defined: i32 = 1;
pub const __int32_t_defined: i32 = 1;
pub const __int64_t_defined: i32 = 1;
pub const __int_least8_t_defined: i32 = 1;
pub const __int_least16_t_defined: i32 = 1;
pub const __int_least32_t_defined: i32 = 1;
pub const __int_least64_t_defined: i32 = 1;
pub const __int_fast8_t_defined: i32 = 1;
pub const __int_fast16_t_defined: i32 = 1;
pub const __int_fast32_t_defined: i32 = 1;
pub const __int_fast64_t_defined: i32 = 1;
pub const WINT_MIN: i32 = 0;
pub const true_: i32 = 1;
pub const false_: i32 = 0;
pub const __bool_true_false_are_defined: i32 = 1;
pub const __alignas_is_defined: i32 = 1;
pub const __alignof_is_defined: i32 = 1;
pub const NROHEADER_MAGIC: i32 = 810504782;
pub const NROASSETHEADER_MAGIC: i32 = 1413829441;
pub const NROASSETHEADER_VERSION: i32 = 0;
pub const CUR_PROCESS_HANDLE: u32 = 4294934529;
pub const CUR_THREAD_HANDLE: u32 = 4294934528;
pub const MAX_WAIT_OBJECTS: i32 = 64;
pub const __NEWLIB_H__: i32 = 1;
pub const _WANT_IO_C99_FORMATS: i32 = 1;
pub const _WANT_IO_LONG_LONG: i32 = 1;
pub const _WANT_IO_POS_ARGS: i32 = 1;
pub const _MB_CAPABLE: i32 = 1;
pub const _MB_LEN_MAX: i32 = 8;
pub const HAVE_INITFINI_ARRAY: i32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: i32 = 1;
pub const _HAVE_LONG_DOUBLE: i32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: i32 = 1;
pub const _FVWRITE_IN_STREAMIO: i32 = 1;
pub const _FSEEK_OPTIMIZATION: i32 = 1;
pub const _UNBUF_STREAM_OPT: i32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: i32 = 1;
pub const __OBSOLETE_MATH: i32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const SFCI_MAGIC: i32 = 1229145683;
pub const SFCO_MAGIC: i32 = 1329808979;
pub const IPC_MAX_BUFFERS: i32 = 8;
pub const IPC_MAX_OBJECTS: i32 = 8;
pub const FS_MAX_PATH: i32 = 769;
pub const FS_SAVEDATA_CURRENT_TITLEID: i32 = 0;
pub const FS_SAVEDATA_USERID_COMMONSAVE: i32 = 0;
pub const ACC_USER_LIST_SIZE: i32 = 8;
pub const AUDREN_TIMER_FREQ_HZ: f64 = 200.0;
pub const AUDREN_TIMER_PERIOD_MS: f64 = 5.0;
pub const AUDREN_SAMPLES_PER_FRAME_32KHZ: i32 = 160;
pub const AUDREN_SAMPLES_PER_FRAME_48KHZ: i32 = 240;
pub const AUDREN_INPUT_PARAM_ALIGNMENT: i32 = 4096;
pub const AUDREN_OUTPUT_PARAM_ALIGNMENT: i32 = 16;
pub const AUDREN_MEMPOOL_ALIGNMENT: i32 = 4096;
pub const AUDREN_BUFFER_ALIGNMENT: i32 = 64;
pub const AUDREN_REVISION_1: i32 = 827737426;
pub const AUDREN_REVISION_2: i32 = 844514642;
pub const AUDREN_REVISION_3: i32 = 861291858;
pub const AUDREN_REVISION_4: i32 = 878069074;
pub const AUDREN_REVISION_5: i32 = 894846290;
pub const AUDREN_REVISION_6: i32 = 911623506;
pub const AUDREN_FINAL_MIX_ID: i32 = 0;
pub const AUDREN_UNUSED_MIX_ID: u32 = 2147483647;
pub const AUDREN_UNUSED_SPLITTER_ID: u32 = 4294967295;
pub const AUDREN_DEFAULT_DEVICE_NAME: &'static [u8; 13usize] = b"MainAudioOut\0";
pub const USB_DT_INTERFACE_SIZE: i32 = 9;
pub const USB_DT_ENDPOINT_SIZE: i32 = 7;
pub const USB_DT_DEVICE_SIZE: i32 = 18;
pub const USB_DT_SS_ENDPOINT_COMPANION_SIZE: i32 = 6;
pub const USB_ENDPOINT_ADDRESS_MASK: i32 = 15;
pub const USB_ENDPOINT_DIR_MASK: i32 = 128;
pub const USB_TRANSFER_TYPE_MASK: i32 = 3;
pub const USBDS_DEFAULT_InterfaceNumber: i32 = 4;
pub const JOYSTICK_MAX: i32 = 32768;
pub const JOYSTICK_MIN: i32 = -32768;
pub const SET_MAX_NAME_SIZE: i32 = 72;
pub const SPL_RSA_BUFFER_SIZE: i32 = 256;
pub const _NV_IOC_NRBITS: i32 = 8;
pub const _NV_IOC_TYPEBITS: i32 = 8;
pub const _NV_IOC_SIZEBITS: i32 = 14;
pub const _NV_IOC_DIRBITS: i32 = 2;
pub const _NV_IOC_NRMASK: i32 = 255;
pub const _NV_IOC_TYPEMASK: i32 = 255;
pub const _NV_IOC_SIZEMASK: i32 = 16383;
pub const _NV_IOC_DIRMASK: i32 = 3;
pub const _NV_IOC_NRSHIFT: i32 = 0;
pub const _NV_IOC_TYPESHIFT: i32 = 8;
pub const _NV_IOC_SIZESHIFT: i32 = 16;
pub const _NV_IOC_DIRSHIFT: i32 = 30;
pub const _NV_IOC_NONE: i32 = 0;
pub const _NV_IOC_WRITE: i32 = 1;
pub const _NV_IOC_READ: i32 = 2;
pub const BINDER_FIRST_CALL_TRANSACTION: i32 = 1;
pub const PARCEL_MAX_PAYLOAD: i32 = 1024;
pub const GPFIFO_QUEUE_SIZE: i32 = 2048;
pub const NXLINK_SERVER_PORT: i32 = 28280;
pub const NXLINK_CLIENT_PORT: i32 = 28771;
pub const __GNUCLIKE_ASM: i32 = 3;
pub const __GNUCLIKE___TYPEOF: i32 = 1;
pub const __GNUCLIKE___OFFSETOF: i32 = 1;
pub const __GNUCLIKE___SECTION: i32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: i32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: i32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: i32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: i32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: i32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: i32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: i32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: i32 = 1;
pub const __CC_SUPPORTS_INLINE: i32 = 1;
pub const __CC_SUPPORTS___INLINE: i32 = 1;
pub const __CC_SUPPORTS___INLINE__: i32 = 1;
pub const __CC_SUPPORTS___FUNC__: i32 = 1;
pub const __CC_SUPPORTS_WARNING: i32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: i32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: i32 = 1;
pub const __BIT_TYPES_DEFINED__: i32 = 1;
pub const _LITTLE_ENDIAN: i32 = 1234;
pub const _BIG_ENDIAN: i32 = 4321;
pub const _PDP_ENDIAN: i32 = 3412;
pub const _BYTE_ORDER: i32 = 1234;
pub const _QUAD_HIGHWORD: i32 = 1;
pub const _QUAD_LOWWORD: i32 = 0;
pub const LITTLE_ENDIAN: i32 = 1234;
pub const BIG_ENDIAN: i32 = 4321;
pub const PDP_ENDIAN: i32 = 3412;
pub const BYTE_ORDER: i32 = 1234;
pub const FD_SETSIZE: i32 = 64;
pub const SCHED_OTHER: i32 = 0;
pub const SCHED_FIFO: i32 = 1;
pub const SCHED_RR: i32 = 2;
pub const PTHREAD_SCOPE_PROCESS: i32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: i32 = 1;
pub const PTHREAD_INHERIT_SCHED: i32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: i32 = 2;
pub const PTHREAD_CREATE_DETACHED: i32 = 0;
pub const PTHREAD_CREATE_JOINABLE: i32 = 1;
pub const CONSOLE_COLOR_BOLD: i32 = 1;
pub const CONSOLE_COLOR_FAINT: i32 = 2;
pub const CONSOLE_ITALIC: i32 = 4;
pub const CONSOLE_UNDERLINE: i32 = 8;
pub const CONSOLE_BLINK_SLOW: i32 = 16;
pub const CONSOLE_BLINK_FAST: i32 = 32;
pub const CONSOLE_COLOR_REVERSE: i32 = 64;
pub const CONSOLE_CONCEAL: i32 = 128;
pub const CONSOLE_CROSSED_OUT: i32 = 256;
pub const FSDEV_DIRITER_MAGIC: i32 = 1718838390;
pub type __int8_t = lang_items::c_schar;
pub type __uint8_t = lang_items::c_uchar;
pub type __int16_t = lang_items::c_short;
pub type __uint16_t = lang_items::c_ushort;
pub type __int32_t = lang_items::c_int;
pub type __uint32_t = lang_items::c_uint;
pub type __int64_t = lang_items::c_long;
pub type __uint64_t = lang_items::c_ulong;
pub type __int_least8_t = lang_items::c_schar;
pub type __uint_least8_t = lang_items::c_uchar;
pub type __int_least16_t = lang_items::c_short;
pub type __uint_least16_t = lang_items::c_ushort;
pub type __int_least32_t = lang_items::c_int;
pub type __uint_least32_t = lang_items::c_uint;
pub type __int_least64_t = lang_items::c_long;
pub type __uint_least64_t = lang_items::c_ulong;
pub type __intmax_t = lang_items::c_long;
pub type __uintmax_t = lang_items::c_ulong;
pub type __intptr_t = lang_items::c_long;
pub type __uintptr_t = lang_items::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = lang_items::c_schar;
pub type uint_fast8_t = lang_items::c_uchar;
pub type int_fast16_t = lang_items::c_short;
pub type uint_fast16_t = lang_items::c_ushort;
pub type int_fast32_t = lang_items::c_int;
pub type uint_fast32_t = lang_items::c_uint;
pub type int_fast64_t = lang_items::c_long;
pub type uint_fast64_t = lang_items::c_ulong;
pub type wchar_t = lang_items::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: lang_items::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<max_align_t>())).__max_align_ll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<max_align_t>())).__max_align_ld as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ld)
        )
    );
}
pub type u128 = __uint128_t;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type s128 = __int128_t;
pub type vu8 = u8;
pub type vu16 = u16;
pub type vu32 = u32;
pub type vu64 = u64;
pub type vu128 = u128;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type vs128 = s128;
pub type Handle = u32;
pub type Result = u32;
pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut lang_items::c_void)>;
pub type VoidFn = ::core::option::Option<unsafe extern "C" fn()>;
pub const Module_Kernel: _bindgen_ty_1 = 1;
pub const Module_Libnx: _bindgen_ty_1 = 345;
pub const Module_HomebrewAbi: _bindgen_ty_1 = 346;
pub const Module_HomebrewLoader: _bindgen_ty_1 = 347;
pub const Module_LibnxNvidia: _bindgen_ty_1 = 348;
pub const Module_LibnxBinder: _bindgen_ty_1 = 349;
/// Module values
pub type _bindgen_ty_1 = u32;
pub const KernelError_OutOfSessions: _bindgen_ty_2 = 7;
pub const KernelError_InvalidCapabilityDescriptor: _bindgen_ty_2 = 14;
pub const KernelError_NotImplemented: _bindgen_ty_2 = 33;
pub const KernelError_ThreadTerminating: _bindgen_ty_2 = 59;
pub const KernelError_OutOfDebugEvents: _bindgen_ty_2 = 70;
pub const KernelError_InvalidSize: _bindgen_ty_2 = 101;
pub const KernelError_InvalidAddress: _bindgen_ty_2 = 102;
pub const KernelError_ResourceExhausted: _bindgen_ty_2 = 103;
pub const KernelError_OutOfMemory: _bindgen_ty_2 = 104;
pub const KernelError_OutOfHandles: _bindgen_ty_2 = 105;
pub const KernelError_InvalidMemoryState: _bindgen_ty_2 = 106;
pub const KernelError_InvalidMemoryPermissions: _bindgen_ty_2 = 108;
pub const KernelError_InvalidMemoryRange: _bindgen_ty_2 = 110;
pub const KernelError_InvalidPriority: _bindgen_ty_2 = 112;
pub const KernelError_InvalidCoreId: _bindgen_ty_2 = 113;
pub const KernelError_InvalidHandle: _bindgen_ty_2 = 114;
pub const KernelError_InvalidUserBuffer: _bindgen_ty_2 = 115;
pub const KernelError_InvalidCombination: _bindgen_ty_2 = 116;
pub const KernelError_TimedOut: _bindgen_ty_2 = 117;
pub const KernelError_Cancelled: _bindgen_ty_2 = 118;
pub const KernelError_OutOfRange: _bindgen_ty_2 = 119;
pub const KernelError_InvalidEnumValue: _bindgen_ty_2 = 120;
pub const KernelError_NotFound: _bindgen_ty_2 = 121;
pub const KernelError_AlreadyExists: _bindgen_ty_2 = 122;
pub const KernelError_ConnectionClosed: _bindgen_ty_2 = 123;
pub const KernelError_UnhandledUserInterrupt: _bindgen_ty_2 = 124;
pub const KernelError_InvalidState: _bindgen_ty_2 = 125;
pub const KernelError_ReservedValue: _bindgen_ty_2 = 126;
pub const KernelError_InvalidHwBreakpoint: _bindgen_ty_2 = 127;
pub const KernelError_FatalUserException: _bindgen_ty_2 = 128;
pub const KernelError_OwnedByAnotherProcess: _bindgen_ty_2 = 129;
pub const KernelError_ConnectionRefused: _bindgen_ty_2 = 131;
pub const KernelError_OutOfResource: _bindgen_ty_2 = 132;
pub const KernelError_IpcMapFailed: _bindgen_ty_2 = 259;
pub const KernelError_IpcCmdbufTooSmall: _bindgen_ty_2 = 260;
pub const KernelError_NotDebugged: _bindgen_ty_2 = 520;
/// Kernel error codes
pub type _bindgen_ty_2 = u32;
pub const LibnxError_BadReloc: _bindgen_ty_3 = 1;
pub const LibnxError_OutOfMemory: _bindgen_ty_3 = 2;
pub const LibnxError_AlreadyMapped: _bindgen_ty_3 = 3;
pub const LibnxError_BadGetInfo_Stack: _bindgen_ty_3 = 4;
pub const LibnxError_BadGetInfo_Heap: _bindgen_ty_3 = 5;
pub const LibnxError_BadQueryMemory: _bindgen_ty_3 = 6;
pub const LibnxError_AlreadyInitialized: _bindgen_ty_3 = 7;
pub const LibnxError_NotInitialized: _bindgen_ty_3 = 8;
pub const LibnxError_NotFound: _bindgen_ty_3 = 9;
pub const LibnxError_IoError: _bindgen_ty_3 = 10;
pub const LibnxError_BadInput: _bindgen_ty_3 = 11;
pub const LibnxError_BadReent: _bindgen_ty_3 = 12;
pub const LibnxError_BufferProducerError: _bindgen_ty_3 = 13;
pub const LibnxError_HandleTooEarly: _bindgen_ty_3 = 14;
pub const LibnxError_HeapAllocFailed: _bindgen_ty_3 = 15;
pub const LibnxError_TooManyOverrides: _bindgen_ty_3 = 16;
pub const LibnxError_ParcelError: _bindgen_ty_3 = 17;
pub const LibnxError_BadGfxInit: _bindgen_ty_3 = 18;
pub const LibnxError_BadGfxEventWait: _bindgen_ty_3 = 19;
pub const LibnxError_BadGfxQueueBuffer: _bindgen_ty_3 = 20;
pub const LibnxError_BadGfxDequeueBuffer: _bindgen_ty_3 = 21;
pub const LibnxError_AppletCmdidNotFound: _bindgen_ty_3 = 22;
pub const LibnxError_BadAppletReceiveMessage: _bindgen_ty_3 = 23;
pub const LibnxError_BadAppletNotifyRunning: _bindgen_ty_3 = 24;
pub const LibnxError_BadAppletGetCurrentFocusState: _bindgen_ty_3 = 25;
pub const LibnxError_BadAppletGetOperationMode: _bindgen_ty_3 = 26;
pub const LibnxError_BadAppletGetPerformanceMode: _bindgen_ty_3 = 27;
pub const LibnxError_BadUsbCommsRead: _bindgen_ty_3 = 28;
pub const LibnxError_BadUsbCommsWrite: _bindgen_ty_3 = 29;
pub const LibnxError_InitFail_SM: _bindgen_ty_3 = 30;
pub const LibnxError_InitFail_AM: _bindgen_ty_3 = 31;
pub const LibnxError_InitFail_HID: _bindgen_ty_3 = 32;
pub const LibnxError_InitFail_FS: _bindgen_ty_3 = 33;
pub const LibnxError_BadGetInfo_Rng: _bindgen_ty_3 = 34;
pub const LibnxError_JitUnavailable: _bindgen_ty_3 = 35;
pub const LibnxError_WeirdKernel: _bindgen_ty_3 = 36;
pub const LibnxError_IncompatSysVer: _bindgen_ty_3 = 37;
pub const LibnxError_InitFail_Time: _bindgen_ty_3 = 38;
pub const LibnxError_TooManyDevOpTabs: _bindgen_ty_3 = 39;
pub const LibnxError_DomainMessageUnknownType: _bindgen_ty_3 = 40;
pub const LibnxError_DomainMessageTooManyObjectIds: _bindgen_ty_3 = 41;
pub const LibnxError_AppletFailedToInitialize: _bindgen_ty_3 = 42;
pub const LibnxError_ApmFailedToInitialize: _bindgen_ty_3 = 43;
pub const LibnxError_NvinfoFailedToInitialize: _bindgen_ty_3 = 44;
pub const LibnxError_NvbufFailedToInitialize: _bindgen_ty_3 = 45;
/// libnx error codes
pub type _bindgen_ty_3 = u32;
pub const LibnxBinderError_Unknown: _bindgen_ty_4 = 1;
pub const LibnxBinderError_NoMemory: _bindgen_ty_4 = 2;
pub const LibnxBinderError_InvalidOperation: _bindgen_ty_4 = 3;
pub const LibnxBinderError_BadValue: _bindgen_ty_4 = 4;
pub const LibnxBinderError_BadType: _bindgen_ty_4 = 5;
pub const LibnxBinderError_NameNotFound: _bindgen_ty_4 = 6;
pub const LibnxBinderError_PermissionDenied: _bindgen_ty_4 = 7;
pub const LibnxBinderError_NoInit: _bindgen_ty_4 = 8;
pub const LibnxBinderError_AlreadyExists: _bindgen_ty_4 = 9;
pub const LibnxBinderError_DeadObject: _bindgen_ty_4 = 10;
pub const LibnxBinderError_FailedTransaction: _bindgen_ty_4 = 11;
pub const LibnxBinderError_BadIndex: _bindgen_ty_4 = 12;
pub const LibnxBinderError_NotEnoughData: _bindgen_ty_4 = 13;
pub const LibnxBinderError_WouldBlock: _bindgen_ty_4 = 14;
pub const LibnxBinderError_TimedOut: _bindgen_ty_4 = 15;
pub const LibnxBinderError_UnknownTransaction: _bindgen_ty_4 = 16;
pub const LibnxBinderError_FdsNotAllowed: _bindgen_ty_4 = 17;
/// libnx binder error codes
pub type _bindgen_ty_4 = u32;
pub const LibnxNvidiaError_Unknown: _bindgen_ty_5 = 1;
/// < Maps to Nvidia: 1
pub const LibnxNvidiaError_NotImplemented: _bindgen_ty_5 = 2;
/// < Maps to Nvidia: 2
pub const LibnxNvidiaError_NotSupported: _bindgen_ty_5 = 3;
/// < Maps to Nvidia: 3
pub const LibnxNvidiaError_NotInitialized: _bindgen_ty_5 = 4;
/// < Maps to Nvidia: 4
pub const LibnxNvidiaError_BadParameter: _bindgen_ty_5 = 5;
/// < Maps to Nvidia: 5
pub const LibnxNvidiaError_Timeout: _bindgen_ty_5 = 6;
/// < Maps to Nvidia: 6
pub const LibnxNvidiaError_InsufficientMemory: _bindgen_ty_5 = 7;
/// < Maps to Nvidia: 7
pub const LibnxNvidiaError_ReadOnlyAttribute: _bindgen_ty_5 = 8;
/// < Maps to Nvidia: 8
pub const LibnxNvidiaError_InvalidState: _bindgen_ty_5 = 9;
/// < Maps to Nvidia: 9
pub const LibnxNvidiaError_InvalidAddress: _bindgen_ty_5 = 10;
/// < Maps to Nvidia: 10
pub const LibnxNvidiaError_InvalidSize: _bindgen_ty_5 = 11;
/// < Maps to Nvidia: 11
pub const LibnxNvidiaError_BadValue: _bindgen_ty_5 = 12;
/// < Maps to Nvidia: 13
pub const LibnxNvidiaError_AlreadyAllocated: _bindgen_ty_5 = 13;
/// < Maps to Nvidia: 14
pub const LibnxNvidiaError_Busy: _bindgen_ty_5 = 14;
/// < Maps to Nvidia: 15
pub const LibnxNvidiaError_ResourceError: _bindgen_ty_5 = 15;
/// < Maps to Nvidia: 16
pub const LibnxNvidiaError_CountMismatch: _bindgen_ty_5 = 16;
/// < Maps to Nvidia: 0x1000
pub const LibnxNvidiaError_SharedMemoryTooSmall: _bindgen_ty_5 = 17;
/// < Maps to Nvidia: 0x30003
pub const LibnxNvidiaError_FileOperationFailed: _bindgen_ty_5 = 18;
/// < Maps to Nvidia: 0x3000F
pub const LibnxNvidiaError_IoctlFailed: _bindgen_ty_5 = 19;
/// libnx nvidia error codes
pub type _bindgen_ty_5 = u32;
/// Entry for each segment in the codebin.
#[repr(C)]
pub struct NroSegment {
    pub file_off: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_NroSegment() {
    assert_eq!(
        ::core::mem::size_of::<NroSegment>(),
        8usize,
        concat!("Size of: ", stringify!(NroSegment))
    );
    assert_eq!(
        ::core::mem::align_of::<NroSegment>(),
        4usize,
        concat!("Alignment of ", stringify!(NroSegment))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroSegment>())).file_off as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroSegment),
            "::",
            stringify!(file_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroSegment>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroSegment),
            "::",
            stringify!(size)
        )
    );
}
/// Offset 0x0 in the NRO.
#[repr(C)]
pub struct NroStart {
    pub unused: u32,
    pub mod_offset: u32,
    pub padding: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_NroStart() {
    assert_eq!(
        ::core::mem::size_of::<NroStart>(),
        16usize,
        concat!("Size of: ", stringify!(NroStart))
    );
    assert_eq!(
        ::core::mem::align_of::<NroStart>(),
        4usize,
        concat!("Alignment of ", stringify!(NroStart))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroStart>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroStart),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroStart>())).mod_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroStart),
            "::",
            stringify!(mod_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroStart>())).padding as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroStart),
            "::",
            stringify!(padding)
        )
    );
}
/// This follows NroStart, the actual nro-header.
#[repr(C)]
pub struct NroHeader {
    pub magic: u32,
    pub unk1: u32,
    pub size: u32,
    pub unk2: u32,
    pub segments: [NroSegment; 3usize],
    pub bss_size: u32,
    pub unk3: u32,
    pub build_id: [u8; 32usize],
    pub padding: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_NroHeader() {
    assert_eq!(
        ::core::mem::size_of::<NroHeader>(),
        112usize,
        concat!("Size of: ", stringify!(NroHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<NroHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(NroHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).unk1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(unk1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).unk2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(unk2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).segments as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(segments)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).bss_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(bss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).unk3 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(unk3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).build_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(build_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroHeader>())).padding as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NroHeader),
            "::",
            stringify!(padding)
        )
    );
}
/// Custom asset section.
#[repr(C)]
pub struct NroAssetSection {
    pub offset: u64,
    pub size: u64,
}
#[test]
fn bindgen_test_layout_NroAssetSection() {
    assert_eq!(
        ::core::mem::size_of::<NroAssetSection>(),
        16usize,
        concat!("Size of: ", stringify!(NroAssetSection))
    );
    assert_eq!(
        ::core::mem::align_of::<NroAssetSection>(),
        8usize,
        concat!("Alignment of ", stringify!(NroAssetSection))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetSection>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetSection),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetSection>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetSection),
            "::",
            stringify!(size)
        )
    );
}
/// Custom asset header.
#[repr(C)]
pub struct NroAssetHeader {
    pub magic: u32,
    pub version: u32,
    pub icon: NroAssetSection,
    pub nacp: NroAssetSection,
    pub romfs: NroAssetSection,
}
#[test]
fn bindgen_test_layout_NroAssetHeader() {
    assert_eq!(
        ::core::mem::size_of::<NroAssetHeader>(),
        56usize,
        concat!("Size of: ", stringify!(NroAssetHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<NroAssetHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(NroAssetHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).icon as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).nacp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(nacp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NroAssetHeader>())).romfs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NroAssetHeader),
            "::",
            stringify!(romfs)
        )
    );
}
/// Language entry. These strings are UTF-8.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NacpLanguageEntry {
    pub name: [lang_items::c_char; 512usize],
    pub author: [lang_items::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_NacpLanguageEntry() {
    assert_eq!(
        ::core::mem::size_of::<NacpLanguageEntry>(),
        768usize,
        concat!("Size of: ", stringify!(NacpLanguageEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<NacpLanguageEntry>(),
        1usize,
        concat!("Alignment of ", stringify!(NacpLanguageEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpLanguageEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpLanguageEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpLanguageEntry>())).author as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpLanguageEntry),
            "::",
            stringify!(author)
        )
    );
}
#[repr(C)]
pub struct NacpStruct {
    pub lang: [NacpLanguageEntry; 16usize],
    pub x3000_unk: [u8; 36usize],
    /// Normally all-zero?
    pub x3024_unk: u32,
    pub x3028_unk: u32,
    pub x302C_unk: u32,
    pub x3030_unk: u32,
    pub x3034_unk: u32,
    pub titleID0: u64,
    pub x3040_unk: [u8; 32usize],
    pub version: [lang_items::c_char; 16usize],
    pub titleID_DlcBase: u64,
    pub titleID1: u64,
    pub x3080_unk: u32,
    pub x3084_unk: u32,
    pub x3088_unk: u32,
    pub x308C_unk: [u8; 36usize],
    pub titleID2: u64,
    pub titleIDs: [u64; 7usize],
    pub x30F0_unk: u32,
    pub x30F4_unk: u32,
    pub titleID3: u64,
    pub bcatPassphrase: [lang_items::c_char; 64usize],
    pub x3140_unk: [u8; 3776usize],
}
#[test]
fn bindgen_test_layout_NacpStruct() {
    assert_eq!(
        ::core::mem::size_of::<NacpStruct>(),
        16384usize,
        concat!("Size of: ", stringify!(NacpStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<NacpStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(NacpStruct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).lang as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3000_unk as *const _ as usize },
        12288usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3000_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3024_unk as *const _ as usize },
        12324usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3024_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3028_unk as *const _ as usize },
        12328usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3028_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x302C_unk as *const _ as usize },
        12332usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x302C_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3030_unk as *const _ as usize },
        12336usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3030_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3034_unk as *const _ as usize },
        12340usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3034_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID0 as *const _ as usize },
        12344usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3040_unk as *const _ as usize },
        12352usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3040_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).version as *const _ as usize },
        12384usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID_DlcBase as *const _ as usize },
        12400usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID_DlcBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID1 as *const _ as usize },
        12408usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3080_unk as *const _ as usize },
        12416usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3080_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3084_unk as *const _ as usize },
        12420usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3084_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3088_unk as *const _ as usize },
        12424usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3088_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x308C_unk as *const _ as usize },
        12428usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x308C_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID2 as *const _ as usize },
        12464usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleIDs as *const _ as usize },
        12472usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleIDs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x30F0_unk as *const _ as usize },
        12528usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x30F0_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x30F4_unk as *const _ as usize },
        12532usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x30F4_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).titleID3 as *const _ as usize },
        12536usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(titleID3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).bcatPassphrase as *const _ as usize },
        12544usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(bcatPassphrase)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NacpStruct>())).x3140_unk as *const _ as usize },
        12608usize,
        concat!(
            "Offset of field: ",
            stringify!(NacpStruct),
            "::",
            stringify!(x3140_unk)
        )
    );
}
extern "C" {
    /// Get the NacpLanguageEntry from the input nacp corresponding to the current system language (this may fallback to other languages when needed). Output langentry is NULL if none found / content of entry is empty.
    pub fn nacpGetLanguageEntry(
        nacp: *mut NacpStruct,
        langentry: *mut *mut NacpLanguageEntry,
    ) -> Result;
}
extern "C" {
    /// @brief Performs a data cache flush on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @remarks Cache flush is defined as Clean + Invalidate.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armDCacheFlush(addr: *mut lang_items::c_void, size: usize);
}
extern "C" {
    /// @brief Performs a data cache clean on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armDCacheClean(addr: *mut lang_items::c_void, size: usize);
}
extern "C" {
    /// @brief Performs an instruction cache invalidation clean on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armICacheInvalidate(addr: *mut lang_items::c_void, size: usize);
}
extern "C" {
    /// @brief Performs a data cache zeroing operation on the specified buffer.
    /// @param addr Address of the buffer.
    /// @param size Size of the buffer, in bytes.
    /// @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
    pub fn armDCacheZero(addr: *mut lang_items::c_void, size: usize);
}
/// Armv8 CPU register.
#[repr(C)]
pub union CpuRegister {
    /// < 64-bit AArch64 register view.
    pub x: u64,
    /// < 32-bit AArch64 register view.
    pub w: u32,
    /// < AArch32 register view.
    pub r: u32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_CpuRegister() {
    assert_eq!(
        ::core::mem::size_of::<CpuRegister>(),
        8usize,
        concat!("Size of: ", stringify!(CpuRegister))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuRegister>(),
        8usize,
        concat!("Alignment of ", stringify!(CpuRegister))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CpuRegister>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuRegister),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CpuRegister>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuRegister),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CpuRegister>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuRegister),
            "::",
            stringify!(r)
        )
    );
}
/// Armv8 NEON register.
#[repr(C)]
#[derive(Copy, Clone)]
pub union FpuRegister {
    /// < 128-bit vector view.
    pub v: u128,
    /// < 64-bit double-precision view.
    pub d: f64,
    /// < 32-bit single-precision view.
    pub s: f32,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_FpuRegister() {
    assert_eq!(
        ::core::mem::size_of::<FpuRegister>(),
        16usize,
        concat!("Size of: ", stringify!(FpuRegister))
    );
    assert_eq!(
        ::core::mem::align_of::<FpuRegister>(),
        16usize,
        concat!("Alignment of ", stringify!(FpuRegister))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FpuRegister>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FpuRegister),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FpuRegister>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FpuRegister),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FpuRegister>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FpuRegister),
            "::",
            stringify!(s)
        )
    );
}
/// < General-purpose CPU registers (x0..x28 or r0..r10,r12).
pub const RegisterGroup_RegisterGroup_CpuGprs: RegisterGroup = 1;
/// < Special-purpose CPU registers (fp, lr, sp, pc, PSTATE or cpsr, TPIDR_EL0).
pub const RegisterGroup_RegisterGroup_CpuSprs: RegisterGroup = 2;
/// < General-purpose NEON registers.
pub const RegisterGroup_RegisterGroup_FpuGprs: RegisterGroup = 4;
/// < Special-purpose NEON registers.
pub const RegisterGroup_RegisterGroup_FpuSprs: RegisterGroup = 8;
/// < All CPU registers.
pub const RegisterGroup_RegisterGroup_CpuAll: RegisterGroup = 3;
/// < All NEON registers.
pub const RegisterGroup_RegisterGroup_FpuAll: RegisterGroup = 12;
/// < All registers.
pub const RegisterGroup_RegisterGroup_All: RegisterGroup = 15;
/// Armv8 register group. @ref svcGetThreadContext3 uses @ref RegisterGroup_All.
pub type RegisterGroup = u32;
/// < Instruction abort
pub const ThreadExceptionDesc_ThreadExceptionDesc_InstructionAbort: ThreadExceptionDesc = 256;
/// < Misaligned PC
pub const ThreadExceptionDesc_ThreadExceptionDesc_MisalignedPC: ThreadExceptionDesc = 258;
/// < Misaligned SP
pub const ThreadExceptionDesc_ThreadExceptionDesc_MisalignedSP: ThreadExceptionDesc = 259;
/// < SError [not in 1.0.0?]
pub const ThreadExceptionDesc_ThreadExceptionDesc_SError: ThreadExceptionDesc = 262;
/// < Bad SVC
pub const ThreadExceptionDesc_ThreadExceptionDesc_BadSVC: ThreadExceptionDesc = 769;
/// < Uncategorized, CP15RTTrap, CP15RRTTrap, CP14RTTrap, CP14RRTTrap, IllegalState, SystemRegisterTrap
pub const ThreadExceptionDesc_ThreadExceptionDesc_Trap: ThreadExceptionDesc = 260;
/// < None of the above, EC <= 0x34 and not a breakpoint
pub const ThreadExceptionDesc_ThreadExceptionDesc_Other: ThreadExceptionDesc = 257;
/// This is for \ref ThreadExceptionDump error_desc.
pub type ThreadExceptionDesc = u32;
/// Thread context structure (register dump)
#[repr(C)]
#[repr(align(16))]
pub struct ThreadContext {
    /// < GPRs 0..28. Note: also contains AArch32 SPRs.
    pub cpu_gprs: [CpuRegister; 29usize],
    /// < Frame pointer (x29) (AArch64). For AArch32, check r11.
    pub fp: u64,
    /// < Link register (x30) (AArch64). For AArch32, check r14.
    pub lr: u64,
    /// < Stack pointer (AArch64). For AArch32, check r13.
    pub sp: u64,
    /// < Program counter.
    pub pc: CpuRegister,
    /// < PSTATE or cpsr.
    pub psr: u32,
    /// < 32 general-purpose NEON registers.
    pub fpu_gprs: [FpuRegister; 32usize],
    /// < Floating-point control register.
    pub fpcr: u32,
    /// < Floating-point status register.
    pub fpsr: u32,
    /// < EL0 Read/Write Software Thread ID Register.
    pub tpidr: u64,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_ThreadContext() {
    assert_eq!(
        ::core::mem::size_of::<ThreadContext>(),
        800usize,
        concat!("Size of: ", stringify!(ThreadContext))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadContext>(),
        16usize,
        concat!("Alignment of ", stringify!(ThreadContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).cpu_gprs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fp as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).lr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).sp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).pc as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).psr as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(psr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fpu_gprs as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fpcr as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fpcr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).fpsr as *const _ as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(fpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadContext>())).tpidr as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadContext),
            "::",
            stringify!(tpidr)
        )
    );
}
/// Thread exception dump structure.
#[repr(C)]
#[repr(align(16))]
pub struct ThreadExceptionDump {
    /// < See \ref ThreadExceptionDesc.
    pub error_desc: u32,
    pub pad: [u32; 3usize],
    /// < GPRs 0..28. Note: also contains AArch32 registers.
    pub cpu_gprs: [CpuRegister; 29usize],
    /// < Frame pointer.
    pub fp: CpuRegister,
    /// < Link register.
    pub lr: CpuRegister,
    /// < Stack pointer.
    pub sp: CpuRegister,
    /// < Program counter (elr_el1).
    pub pc: CpuRegister,
    pub padding: u64,
    /// < 32 general-purpose NEON registers.
    pub fpu_gprs: [FpuRegister; 32usize],
    /// < pstate & 0xFF0FFE20
    pub pstate: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    /// < Fault Address Register.
    pub far: CpuRegister,
    pub __bindgen_padding_0: u64,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_ThreadExceptionDump() {
    assert_eq!(
        ::core::mem::size_of::<ThreadExceptionDump>(),
        832usize,
        concat!("Size of: ", stringify!(ThreadExceptionDump))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadExceptionDump>(),
        16usize,
        concat!("Alignment of ", stringify!(ThreadExceptionDump))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).error_desc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(error_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).cpu_gprs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).fp as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).lr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).sp as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).pc as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).padding as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).fpu_gprs as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(fpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).pstate as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).afsr0 as *const _ as usize },
        804usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).afsr1 as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).esr as *const _ as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionDump>())).far as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionDump),
            "::",
            stringify!(far)
        )
    );
}
#[repr(C)]
pub struct ThreadExceptionFrameA64 {
    /// < GPRs 0..8.
    pub cpu_gprs: [u64; 9usize],
    pub lr: u64,
    pub sp: u64,
    pub elr_el1: u64,
    /// < pstate & 0xFF0FFE20
    pub pstate: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    pub far: u64,
}
#[test]
fn bindgen_test_layout_ThreadExceptionFrameA64() {
    assert_eq!(
        ::core::mem::size_of::<ThreadExceptionFrameA64>(),
        120usize,
        concat!("Size of: ", stringify!(ThreadExceptionFrameA64))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadExceptionFrameA64>(),
        8usize,
        concat!("Alignment of ", stringify!(ThreadExceptionFrameA64))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).cpu_gprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).lr as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).sp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).elr_el1 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(elr_el1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).pstate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).afsr0 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).afsr1 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).esr as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA64>())).far as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA64),
            "::",
            stringify!(far)
        )
    );
}
#[repr(C)]
pub struct ThreadExceptionFrameA32 {
    /// < GPRs 0..7.
    pub cpu_gprs: [u32; 8usize],
    pub sp: u32,
    pub lr: u32,
    pub elr_el1: u32,
    /// < tpidr_el0 = 1
    pub tpidr_el0: u32,
    /// < cpsr & 0xFF0FFE20
    pub cpsr: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    pub far: u32,
}
#[test]
fn bindgen_test_layout_ThreadExceptionFrameA32() {
    assert_eq!(
        ::core::mem::size_of::<ThreadExceptionFrameA32>(),
        68usize,
        concat!("Size of: ", stringify!(ThreadExceptionFrameA32))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadExceptionFrameA32>(),
        4usize,
        concat!("Alignment of ", stringify!(ThreadExceptionFrameA32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).cpu_gprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(cpu_gprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).sp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).lr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).elr_el1 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(elr_el1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).tpidr_el0 as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(tpidr_el0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).cpsr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(cpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).afsr0 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).afsr1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).esr as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThreadExceptionFrameA32>())).far as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadExceptionFrameA32),
            "::",
            stringify!(far)
        )
    );
}
/// < Unmapped memory.
pub const MemoryType_MemType_Unmapped: MemoryType = 0;
/// < Mapped by kernel capability parsing in \ref svcCreateProcess.
pub const MemoryType_MemType_Io: MemoryType = 1;
/// < Mapped by kernel capability parsing in \ref svcCreateProcess.
pub const MemoryType_MemType_Normal: MemoryType = 2;
/// < Mapped during \ref svcCreateProcess.
pub const MemoryType_MemType_CodeStatic: MemoryType = 3;
/// < Transition from MemType_CodeStatic performed by \ref svcSetProcessMemoryPermission.
pub const MemoryType_MemType_CodeMutable: MemoryType = 4;
/// < Mapped using \ref svcSetHeapSize.
pub const MemoryType_MemType_Heap: MemoryType = 5;
/// < Mapped using \ref svcMapSharedMemory.
pub const MemoryType_MemType_SharedMem: MemoryType = 6;
/// < Mapped using \ref svcMapMemory.
pub const MemoryType_MemType_WeirdMappedMem: MemoryType = 7;
/// < Mapped using \ref svcMapProcessCodeMemory.
pub const MemoryType_MemType_ModuleCodeStatic: MemoryType = 8;
/// < Transition from \ref MemType_ModuleCodeStatic performed by \ref svcSetProcessMemoryPermission.
pub const MemoryType_MemType_ModuleCodeMutable: MemoryType = 9;
/// < IPC buffers with descriptor flags=0.
pub const MemoryType_MemType_IpcBuffer0: MemoryType = 10;
/// < Mapped using \ref svcMapMemory.
pub const MemoryType_MemType_MappedMemory: MemoryType = 11;
/// < Mapped during \ref svcCreateThread.
pub const MemoryType_MemType_ThreadLocal: MemoryType = 12;
/// < Mapped using \ref svcMapTransferMemory when the owning process has perm=0.
pub const MemoryType_MemType_TransferMemIsolated: MemoryType = 13;
/// < Mapped using \ref svcMapTransferMemory when the owning process has perm!=0.
pub const MemoryType_MemType_TransferMem: MemoryType = 14;
/// < Mapped using \ref svcMapProcessMemory.
pub const MemoryType_MemType_ProcessMem: MemoryType = 15;
/// < Reserved.
pub const MemoryType_MemType_Reserved: MemoryType = 16;
/// < IPC buffers with descriptor flags=1.
pub const MemoryType_MemType_IpcBuffer1: MemoryType = 17;
/// < IPC buffers with descriptor flags=3.
pub const MemoryType_MemType_IpcBuffer3: MemoryType = 18;
/// < Mapped in kernel during \ref svcCreateThread.
pub const MemoryType_MemType_KernelStack: MemoryType = 19;
/// < Mapped in kernel during \ref svcControlCodeMemory.
pub const MemoryType_MemType_CodeReadOnly: MemoryType = 20;
/// < Mapped in kernel during \ref svcControlCodeMemory.
pub const MemoryType_MemType_CodeWritable: MemoryType = 21;
/// Memory type enumeration (lower 8 bits of \ref MemoryState)
pub type MemoryType = u32;
/// < Type field (see \ref MemoryType).
pub const MemoryState_MemState_Type: MemoryState = 255;
/// < Permission change allowed.
pub const MemoryState_MemState_PermChangeAllowed: MemoryState = 256;
/// < Force read/writable by debug syscalls.
pub const MemoryState_MemState_ForceRwByDebugSyscalls: MemoryState = 512;
/// < IPC type 0 send allowed.
pub const MemoryState_MemState_IpcSendAllowed_Type0: MemoryState = 1024;
/// < IPC type 3 send allowed.
pub const MemoryState_MemState_IpcSendAllowed_Type3: MemoryState = 2048;
/// < IPC type 1 send allowed.
pub const MemoryState_MemState_IpcSendAllowed_Type1: MemoryState = 4096;
/// < Process permission change allowed.
pub const MemoryState_MemState_ProcessPermChangeAllowed: MemoryState = 16384;
/// < Map allowed.
pub const MemoryState_MemState_MapAllowed: MemoryState = 32768;
/// < Unmap process code memory allowed.
pub const MemoryState_MemState_UnmapProcessCodeMemAllowed: MemoryState = 65536;
/// < Transfer memory allowed.
pub const MemoryState_MemState_TransferMemAllowed: MemoryState = 131072;
/// < Query physical address allowed.
pub const MemoryState_MemState_QueryPAddrAllowed: MemoryState = 262144;
/// < Map device allowed (\ref svcMapDeviceAddressSpace and \ref svcMapDeviceAddressSpaceByForce).
pub const MemoryState_MemState_MapDeviceAllowed: MemoryState = 524288;
/// < Map device aligned allowed.
pub const MemoryState_MemState_MapDeviceAlignedAllowed: MemoryState = 1048576;
/// < IPC buffer allowed.
pub const MemoryState_MemState_IpcBufferAllowed: MemoryState = 2097152;
/// < Is pool allocated.
pub const MemoryState_MemState_IsPoolAllocated: MemoryState = 4194304;
/// < Alias for \ref MemState_IsPoolAllocated.
pub const MemoryState_MemState_IsRefCounted: MemoryState = 4194304;
/// < Map process allowed.
pub const MemoryState_MemState_MapProcessAllowed: MemoryState = 8388608;
/// < Attribute change allowed.
pub const MemoryState_MemState_AttrChangeAllowed: MemoryState = 16777216;
/// < Code memory allowed.
pub const MemoryState_MemState_CodeMemAllowed: MemoryState = 33554432;
/// Memory state bitmasks.
pub type MemoryState = u32;
/// < Is borrowed memory.
pub const MemoryAttribute_MemAttr_IsBorrowed: MemoryAttribute = 1;
/// < Is IPC mapped (when IpcRefCount > 0).
pub const MemoryAttribute_MemAttr_IsIpcMapped: MemoryAttribute = 2;
/// < Is device mapped (when DeviceRefCount > 0).
pub const MemoryAttribute_MemAttr_IsDeviceMapped: MemoryAttribute = 4;
/// < Is uncached.
pub const MemoryAttribute_MemAttr_IsUncached: MemoryAttribute = 8;
/// Memory attribute bitmasks.
pub type MemoryAttribute = u32;
/// < No permissions.
pub const Permission_Perm_None: Permission = 0;
/// < Read permission.
pub const Permission_Perm_R: Permission = 1;
/// < Write permission.
pub const Permission_Perm_W: Permission = 2;
/// < Execute permission.
pub const Permission_Perm_X: Permission = 4;
/// < Read/write permissions.
pub const Permission_Perm_Rw: Permission = 3;
/// < Read/execute permissions.
pub const Permission_Perm_Rx: Permission = 5;
/// < Don't care
pub const Permission_Perm_DontCare: Permission = 268435456;
/// Memory permission bitmasks.
pub type Permission = u32;
/// Memory information structure.
#[repr(C)]
pub struct MemoryInfo {
    /// < Base address.
    pub addr: u64,
    /// < Size.
    pub size: u64,
    /// < Memory type (see lower 8 bits of \ref MemoryState).
    pub type_: u32,
    /// < Memory attributes (see \ref MemoryAttribute).
    pub attr: u32,
    /// < Memory permissions (see \ref Permission).
    pub perm: u32,
    /// < Device reference count.
    pub device_refcount: u32,
    /// < IPC reference count.
    pub ipc_refcount: u32,
    /// < Padding.
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_MemoryInfo() {
    assert_eq!(
        ::core::mem::size_of::<MemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(MemoryInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).attr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).perm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).device_refcount as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(device_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).ipc_refcount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(ipc_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemoryInfo>())).padding as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(padding)
        )
    );
}
/// Secure monitor arguments.
#[repr(C, packed)]
pub struct SecmonArgs {
    /// < Values of X0 through X7.
    pub X: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_SecmonArgs() {
    assert_eq!(
        ::core::mem::size_of::<SecmonArgs>(),
        64usize,
        concat!("Size of: ", stringify!(SecmonArgs))
    );
    assert_eq!(
        ::core::mem::align_of::<SecmonArgs>(),
        1usize,
        concat!("Alignment of ", stringify!(SecmonArgs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SecmonArgs>())).X as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SecmonArgs),
            "::",
            stringify!(X)
        )
    );
}
/// < Map owner.
pub const CodeMapOperation_CodeMapOperation_MapOwner: CodeMapOperation = 0;
/// < Map slave.
pub const CodeMapOperation_CodeMapOperation_MapSlave: CodeMapOperation = 1;
/// < Unmap owner.
pub const CodeMapOperation_CodeMapOperation_UnmapOwner: CodeMapOperation = 2;
/// < Unmap slave.
pub const CodeMapOperation_CodeMapOperation_UnmapSlave: CodeMapOperation = 3;
/// Code memory mapping operations
pub type CodeMapOperation = u32;
/// <How much memory can a process map.
pub const LimitableResource_LimitableResource_Memory: LimitableResource = 0;
/// <How many threads can a process spawn.
pub const LimitableResource_LimitableResource_Threads: LimitableResource = 1;
/// <How many events can a process have.
pub const LimitableResource_LimitableResource_Events: LimitableResource = 2;
/// <How many transfer memories can a process make.
pub const LimitableResource_LimitableResource_TransferMemories: LimitableResource = 3;
/// <How many sessions can a process own.
pub const LimitableResource_LimitableResource_Sessions: LimitableResource = 4;
/// Limitable Resources.
pub type LimitableResource = u32;
/// <What state is a process in.
pub const ProcessInfoType_ProcessInfoType_ProcessState: ProcessInfoType = 0;
/// Process Information.
pub type ProcessInfoType = u32;
/// <Newly-created process, not yet started.
pub const ProcessState_ProcessState_Created: ProcessState = 0;
/// <Newly-created process, not yet started but attached to debugger.
pub const ProcessState_ProcessState_CreatedAttached: ProcessState = 1;
/// <Process that is running normally (and detached from any debugger).
pub const ProcessState_ProcessState_Running: ProcessState = 2;
/// <Process that has just crashed.
pub const ProcessState_ProcessState_Crashed: ProcessState = 3;
/// <Process that is running normally, attached to a debugger.
pub const ProcessState_ProcessState_RunningAttached: ProcessState = 4;
/// <Process has begun exiting.
pub const ProcessState_ProcessState_Exiting: ProcessState = 5;
/// <Process has finished exiting.
pub const ProcessState_ProcessState_Exited: ProcessState = 6;
/// <Process execution suspended by debugger.
pub const ProcessState_ProcessState_DebugSuspended: ProcessState = 7;
/// Process States.
pub type ProcessState = u32;
pub const DebugThreadParam_DebugThreadParam_ActualPriority: DebugThreadParam = 0;
pub const DebugThreadParam_DebugThreadParam_State: DebugThreadParam = 1;
pub const DebugThreadParam_DebugThreadParam_IdealCore: DebugThreadParam = 2;
pub const DebugThreadParam_DebugThreadParam_CurrentCore: DebugThreadParam = 3;
pub const DebugThreadParam_DebugThreadParam_CoreMask: DebugThreadParam = 4;
/// Debug Thread Parameters.
pub type DebugThreadParam = u32;
extern "C" {
    /// @brief Set the process heap to a given size. It can both extend and shrink the heap.
    /// @param[out] out_addr Variable to which write the address of the heap (which is randomized and fixed by the kernel)
    /// @param[in] size Size of the heap, must be a multiple of 0x2000000 and [2.0.0+] less than 0x18000000.
    /// @return Result code.
    /// @note Syscall number 0x00.
    pub fn svcSetHeapSize(out_addr: *mut *mut lang_items::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Set the memory permissions of a (page-aligned) range of memory.
    /// @param[in] addr Start address of the range.
    /// @param[in] size Size of the range, in bytes.
    /// @param[in] perm Permissions (see \ref Permission).
    /// @return Result code.
    /// @remark Perm_X is not allowed. Setting write-only is not allowed either (Perm_W).
    /// This can be used to move back and forth between Perm_None, Perm_R and Perm_Rw.
    /// @note Syscall number 0x01.
    pub fn svcSetMemoryPermission(addr: *mut lang_items::c_void, size: u64, perm: u32) -> Result;
}
extern "C" {
    /// @brief Set the memory attributes of a (page-aligned) range of memory.
    /// @param[in] addr Start address of the range.
    /// @param[in] size Size of the range, in bytes.
    /// @param[in] val0 State0
    /// @param[in] val1 State1
    /// @return Result code.
    /// @remark See <a href="https://switchbrew.org/wiki/SVC#svcSetMemoryAttribute">switchbrew.org Wiki</a> for more details.
    /// @note Syscall number 0x02.
    pub fn svcSetMemoryAttribute(
        addr: *mut lang_items::c_void,
        size: u64,
        val0: u32,
        val1: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Maps a memory range into a different range. Mainly used for adding guard pages around stack.
    /// Source range gets reprotected to Perm_None (it can no longer be accessed), and \ref MemAttr_IsBorrowed is set in the source \ref MemoryAttribute.
    /// @param[in] dst_addr Destination address.
    /// @param[in] src_addr Source address.
    /// @param[in] size Size of the range.
    /// @return Result code.
    /// @note Syscall number 0x04.
    pub fn svcMapMemory(
        dst_addr: *mut lang_items::c_void,
        src_addr: *mut lang_items::c_void,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps a region that was previously mapped with \ref svcMapMemory.
    /// @param[in] dst_addr Destination address.
    /// @param[in] src_addr Source address.
    /// @param[in] size Size of the range.
    /// @return Result code.
    /// @note Syscall number 0x05.
    pub fn svcUnmapMemory(
        dst_addr: *mut lang_items::c_void,
        src_addr: *mut lang_items::c_void,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Query information about an address. Will always fetch the lowest page-aligned mapping that contains the provided address.
    /// @param[out] meminfo_ptr \ref MemoryInfo structure which will be filled in.
    /// @param[out] page_info Page information which will be filled in.
    /// @param[in] addr Address to query.
    /// @return Result code.
    /// @note Syscall number 0x06.
    pub fn svcQueryMemory(meminfo_ptr: *mut MemoryInfo, pageinfo: *mut u32, addr: u64) -> Result;
}
extern "C" {
    /// @brief Exits the current process.
    /// @note Syscall number 0x07.
    pub fn svcExitProcess();
}
extern "C" {
    /// @brief Creates a thread.
    /// @return Result code.
    /// @note Syscall number 0x08.
    pub fn svcCreateThread(
        out: *mut Handle,
        entry: *mut lang_items::c_void,
        arg: *mut lang_items::c_void,
        stack_top: *mut lang_items::c_void,
        prio: lang_items::c_int,
        cpuid: lang_items::c_int,
    ) -> Result;
}
extern "C" {
    /// @brief Starts a freshly created thread.
    /// @return Result code.
    /// @note Syscall number 0x09.
    pub fn svcStartThread(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Exits the current thread.
    /// @note Syscall number 0x0A.
    pub fn svcExitThread();
}
extern "C" {
    /// @brief Sleeps the current thread for the specified amount of time.
    /// @return Result code.
    /// @note Syscall number 0x0B.
    pub fn svcSleepThread(nano: u64) -> Result;
}
extern "C" {
    /// @brief Gets a thread's priority.
    /// @return Result code.
    /// @note Syscall number 0x0C.
    pub fn svcGetThreadPriority(priority: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Sets a thread's priority.
    /// @return Result code.
    /// @note Syscall number 0x0D.
    pub fn svcSetThreadPriority(handle: Handle, priority: u32) -> Result;
}
extern "C" {
    /// @brief Gets a thread's core mask.
    /// @return Result code.
    /// @note Syscall number 0x0E.
    pub fn svcGetThreadCoreMask(
        preferred_core: *mut s32,
        affinity_mask: *mut u32,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Sets a thread's core mask.
    /// @return Result code.
    /// @note Syscall number 0x0F.
    pub fn svcSetThreadCoreMask(handle: Handle, preferred_core: s32, affinity_mask: u32) -> Result;
}
extern "C" {
    /// @brief Gets the current processor's number.
    /// @return The current processor's number.
    /// @note Syscall number 0x10.
    pub fn svcGetCurrentProcessorNumber() -> u32;
}
extern "C" {
    /// @brief Sets an event's signalled status.
    /// @return Result code.
    /// @note Syscall number 0x11.
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Clears an event's signalled status.
    /// @return Result code.
    /// @note Syscall number 0x12.
    pub fn svcClearEvent(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Maps a block of shared memory.
    /// @return Result code.
    /// @note Syscall number 0x13.
    pub fn svcMapSharedMemory(
        handle: Handle,
        addr: *mut lang_items::c_void,
        size: usize,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps a block of shared memory.
    /// @return Result code.
    /// @note Syscall number 0x14.
    pub fn svcUnmapSharedMemory(
        handle: Handle,
        addr: *mut lang_items::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a block of transfer memory.
    /// @return Result code.
    /// @note Syscall number 0x15.
    pub fn svcCreateTransferMemory(
        out: *mut Handle,
        addr: *mut lang_items::c_void,
        size: usize,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Closes a handle, decrementing the reference count of the corresponding kernel object.
    /// This might result in the kernel freeing the object.
    /// @param handle Handle to close.
    /// @return Result code.
    /// @note Syscall number 0x16.
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Resets a signal.
    /// @return Result code.
    /// @note Syscall number 0x17.
    pub fn svcResetSignal(handle: Handle) -> Result;
}
extern "C" {
    /// @brief Waits on one or more synchronization objects, optionally with a timeout.
    /// @return Result code.
    /// @note Syscall number 0x18.
    /// @note \p handleCount must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
    /// @note This is the raw syscall, which can be cancelled by \ref svcCancelSynchronization or other means. \ref waitHandles or \ref waitMultiHandle should normally be used instead.
    pub fn svcWaitSynchronization(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Waits a \ref svcWaitSynchronization operation being done on a synchronization object in another thread.
    /// @return Result code.
    /// @note Syscall number 0x19.
    pub fn svcCancelSynchronization(thread: Handle) -> Result;
}
extern "C" {
    /// @brief Arbitrates a mutex lock operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1A.
    pub fn svcArbitrateLock(wait_tag: u32, tag_location: *mut u32, self_tag: u32) -> Result;
}
extern "C" {
    /// @brief Arbitrates a mutex unlock operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1B.
    pub fn svcArbitrateUnlock(tag_location: *mut u32) -> Result;
}
extern "C" {
    /// @brief Performs a condition variable wait operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1C.
    pub fn svcWaitProcessWideKeyAtomic(
        key: *mut u32,
        tag_location: *mut u32,
        self_tag: u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Performs a condition variable wake-up operation in userspace.
    /// @return Result code.
    /// @note Syscall number 0x1D.
    pub fn svcSignalProcessWideKey(key: *mut u32, num: s32) -> Result;
}
extern "C" {
    /// @brief Gets the current system tick.
    /// @return The current system tick.
    /// @note Syscall number 0x1E.
    pub fn svcGetSystemTick() -> u64;
}
extern "C" {
    /// @brief Connects to a registered named port.
    /// @return Result code.
    /// @note Syscall number 0x1F.
    pub fn svcConnectToNamedPort(session: *mut Handle, name: *const lang_items::c_char) -> Result;
}
extern "C" {
    /// @brief Sends an IPC synchronization request to a session.
    /// @return Result code.
    /// @note Syscall number 0x21.
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
extern "C" {
    /// @brief Sends an IPC synchronization request to a session from an user allocated buffer.
    /// @return Result code.
    /// @remark size must be allocated to 0x1000 bytes.
    /// @note Syscall number 0x22.
    pub fn svcSendSyncRequestWithUserBuffer(
        usrBuffer: *mut lang_items::c_void,
        size: u64,
        session: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Sends an IPC synchronization request to a session from an user allocated buffer (asynchronous version).
    /// @return Result code.
    /// @remark size must be allocated to 0x1000 bytes.
    /// @note Syscall number 0x23.
    pub fn svcSendAsyncRequestWithUserBuffer(
        handle: *mut Handle,
        usrBuffer: *mut lang_items::c_void,
        size: u64,
        session: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the PID associated with a process.
    /// @return Result code.
    /// @note Syscall number 0x24.
    pub fn svcGetProcessId(processID: *mut u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Gets the TID associated with a process.
    /// @return Result code.
    /// @note Syscall number 0x25.
    pub fn svcGetThreadId(threadID: *mut u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Breaks execution. Panic.
    /// @param[in] breakReason Break reason.
    /// @param[in] inval1 First break parameter.
    /// @param[in] inval2 Second break parameter.
    /// @return Result code.
    /// @note Syscall number 0x26.
    pub fn svcBreak(breakReason: u32, inval1: u64, inval2: u64) -> Result;
}
extern "C" {
    /// @brief Outputs debug text, if used during debugging.
    /// @param[in] str Text to output.
    /// @param[in] size Size of the text in bytes.
    /// @return Result code.
    /// @note Syscall number 0x27.
    pub fn svcOutputDebugString(str: *const lang_items::c_char, size: u64) -> Result;
}
extern "C" {
    /// @brief Returns from an exception.
    /// @param[in] res Result code.
    /// @note Syscall number 0x28.
    pub fn svcReturnFromException(res: Result);
}
extern "C" {
    /// @brief Retrieves information about the system, or a certain kernel object.
    /// @param[out] out Variable to which store the information.
    /// @param[in] id0 First ID of the property to retrieve.
    /// @param[in] handle Handle of the object to retrieve information from, or \ref INVALID_HANDLE to retrieve information about the system.
    /// @param[in] id1 Second ID of the property to retrieve.
    /// @return Result code.
    /// @remark The full list of property IDs can be found on the <a href="https://switchbrew.org/wiki/SVC#svcGetInfo">switchbrew.org wiki</a>.
    /// @note Syscall number 0x29.
    pub fn svcGetInfo(out: *mut u64, id0: u64, handle: Handle, id1: u64) -> Result;
}
extern "C" {
    /// @brief Maps new heap memory at the desired address. [3.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x2C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapPhysicalMemory(address: *mut lang_items::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapPhysicalMemory. [3.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x2D.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapPhysicalMemory(address: *mut lang_items::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Gets the maximum value a LimitableResource can have, for a Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x30.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetResourceLimitLimitValue(
        out: *mut u64,
        reslimit_h: Handle,
        which: LimitableResource,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the maximum value a LimitableResource can have, for a Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x31.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetResourceLimitCurrentValue(
        out: *mut u64,
        reslimit_h: Handle,
        which: LimitableResource,
    ) -> Result;
}
extern "C" {
    /// @brief Configures the pause/unpause status of a thread.
    /// @return Result code.
    /// @note Syscall number 0x32.
    pub fn svcSetThreadActivity(thread: Handle, paused: bool) -> Result;
}
extern "C" {
    /// @brief Dumps the registers of a thread paused by @ref svcSetThreadActivity (register groups: all).
    /// @param[out] ctx Output thread context (register dump).
    /// @param[in] thread Thread handle.
    /// @return Result code.
    /// @note Syscall number 0x33.
    /// @warning Official kernel will not dump x0..x18 if the thread is currently executing a system call, and prior to 6.0.0 doesn't dump TPIDR_EL0.
    pub fn svcGetThreadContext3(ctx: *mut ThreadContext, thread: Handle) -> Result;
}
extern "C" {
    /// @brief Creates an IPC session.
    /// @return Result code.
    /// @note Syscall number 0x40.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateSession(
        server_handle: *mut Handle,
        client_handle: *mut Handle,
        unk0: u32,
        unk1: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Accepts an IPC session.
    /// @return Result code.
    /// @note Syscall number 0x41.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcAcceptSession(session_handle: *mut Handle, port_handle: Handle) -> Result;
}
extern "C" {
    /// @brief Performs IPC input/output.
    /// @return Result code.
    /// @note Syscall number 0x43.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReplyAndReceive(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Performs IPC input/output from an user allocated buffer.
    /// @return Result code.
    /// @note Syscall number 0x44.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReplyAndReceiveWithUserBuffer(
        index: *mut s32,
        usrBuffer: *mut lang_items::c_void,
        size: u64,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a system event.
    /// @return Result code.
    /// @note Syscall number 0x45.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateEvent(server_handle: *mut Handle, client_handle: *mut Handle) -> Result;
}
extern "C" {
    /// @brief Maps unsafe memory (usable for GPU DMA) for a system module at the desired address. [5.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x48.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapPhysicalMemoryUnsafe(address: *mut lang_items::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapPhysicalMemoryUnsafe. [5.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x49.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapPhysicalMemoryUnsafe(address: *mut lang_items::c_void, size: u64) -> Result;
}
extern "C" {
    /// @brief Sets the system-wide limit for unsafe memory mappable using \ref svcMapPhysicalMemoryUnsafe. [5.0.0+]
    /// @return Result code.
    /// @note Syscall number 0x4A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetUnsafeLimit(size: u64) -> Result;
}
extern "C" {
    /// @brief Creates code memory in the caller's address space [4.0.0+].
    /// @return Result code.
    /// @note Syscall number 0x4B.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateCodeMemory(
        code_handle: *mut Handle,
        src_addr: *mut lang_items::c_void,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Maps code memory in the caller's address space [4.0.0+].
    /// @return Result code.
    /// @note Syscall number 0x4C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcControlCodeMemory(
        code_handle: Handle,
        op: CodeMapOperation,
        dst_addr: *mut lang_items::c_void,
        size: u64,
        perm: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Reads/writes a protected MMIO register.
    /// @return Result code.
    /// @note Syscall number 0x4E.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReadWriteRegister(outVal: *mut u32, regAddr: u64, rwMask: u32, inVal: u32) -> Result;
}
extern "C" {
    /// @brief Creates a block of shared memory.
    /// @return Result code.
    /// @note Syscall number 0x50.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateSharedMemory(
        out: *mut Handle,
        size: usize,
        local_perm: u32,
        other_perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Maps a block of transfer memory.
    /// @return Result code.
    /// @note Syscall number 0x51.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapTransferMemory(
        tmem_handle: Handle,
        addr: *mut lang_items::c_void,
        size: usize,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps a block of transfer memory.
    /// @return Result code.
    /// @note Syscall number 0x52.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapTransferMemory(
        tmem_handle: Handle,
        addr: *mut lang_items::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Creates an event and binds it to a specific hardware interrupt.
    /// @return Result code.
    /// @note Syscall number 0x53.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateInterruptEvent(handle: *mut Handle, irqNum: u64, flag: u32) -> Result;
}
extern "C" {
    /// @brief Queries information about a certain virtual address, including its physical address.
    /// @return Result code.
    /// @note Syscall number 0x54.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcQueryPhysicalAddress(out: *mut u64, virtaddr: u64) -> Result;
}
extern "C" {
    /// @brief Returns a virtual address mapped to a given IO range.
    /// @return Result code.
    /// @note Syscall number 0x55.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcQueryIoMapping(virtaddr: *mut u64, physaddr: u64, size: u64) -> Result;
}
extern "C" {
    /// @brief Creates a virtual address space for binding device address spaces.
    /// @return Result code.
    /// @note Syscall number 0x56.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateDeviceAddressSpace(handle: *mut Handle, dev_addr: u64, dev_size: u64)
        -> Result;
}
extern "C" {
    /// @brief Attaches a device address space to a device.
    /// @return Result code.
    /// @note Syscall number 0x57.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcAttachDeviceAddressSpace(device: u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Detaches a device address space from a device.
    /// @return Result code.
    /// @note Syscall number 0x58.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcDetachDeviceAddressSpace(device: u64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Maps an attached device address space to an userspace address.
    /// @return Result code.
    /// @remark The userspace destination address must have the \ref MemState_MapDeviceAllowed bit set.
    /// @note Syscall number 0x59.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapDeviceAddressSpaceByForce(
        handle: Handle,
        proc_handle: Handle,
        map_addr: u64,
        dev_size: u64,
        dev_addr: u64,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Maps an attached device address space to an userspace address.
    /// @return Result code.
    /// @remark The userspace destination address must have the \ref MemState_MapDeviceAlignedAllowed bit set.
    /// @note Syscall number 0x5A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapDeviceAddressSpaceAligned(
        handle: Handle,
        proc_handle: Handle,
        map_addr: u64,
        dev_size: u64,
        dev_addr: u64,
        perm: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Unmaps an attached device address space from an userspace address.
    /// @return Result code.
    /// @note Syscall number 0x5C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapDeviceAddressSpace(
        handle: Handle,
        proc_handle: Handle,
        map_addr: u64,
        map_size: u64,
        dev_addr: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Debugs an active process.
    /// @return Result code.
    /// @note Syscall number 0x60.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcDebugActiveProcess(debug: *mut Handle, processID: u64) -> Result;
}
extern "C" {
    /// @brief Breaks an active debugging session.
    /// @return Result code.
    /// @note Syscall number 0x61.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    /// @brief Terminates the process of an active debugging session.
    /// @return Result code.
    /// @note Syscall number 0x62.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    /// @brief Gets an incoming debug event from a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x63.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetDebugEvent(event_out: *mut u8, debug: Handle) -> Result;
}
extern "C" {
    /// @brief Continues a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x64.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    /// @warning Only exists on 3.0.0+. For older versions use \ref svcContinueDebugEventPre300.
    pub fn svcContinueDebugEvent(
        debug: Handle,
        flags: u32,
        tid_list: *mut u64,
        num_tids: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Continues a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x64.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    /// @warning Only exists on 1.0.0-2.3.0. For newer versions use \ref svcContinueDebugEvent.
    pub fn svcLegacyContinueDebugEvent(debug: Handle, flags: u32, threadID: u64) -> Result;
}
extern "C" {
    /// @brief Gets the context (dump the registers) of a thread in a debugging session.
    /// @return Result code.
    /// @param[out] ctx Output thread context (register dump).
    /// @param[in] debug Debug handle.
    /// @param[in] threadId ID of the thread to dump the context of.
    /// @param[in] flags Register groups to select, combination of @ref RegisterGroup flags.
    /// @note Syscall number 0x67.
    /// @warning Official kernel will not dump any CPU GPR if the thread is currently executing a system call (except @ref svcBreak and @ref svcReturnFromException).
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetDebugThreadContext(
        ctx: *mut ThreadContext,
        debug: Handle,
        threadID: u64,
        flags: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the context (dump the registers) of a thread in a debugging session.
    /// @return Result code.
    /// @param[in] debug Debug handle.
    /// @param[in] threadId ID of the thread to set the context of.
    /// @param[in] ctx Input thread context (register dump).
    /// @param[in] flags Register groups to select, combination of @ref RegisterGroup flags.
    /// @note Syscall number 0x68.
    /// @warning Official kernel will return an error if the thread is currently executing a system call (except @ref svcBreak and @ref svcReturnFromException).
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetDebugThreadContext(
        debug: Handle,
        threadID: u64,
        ctx: *const ThreadContext,
        flags: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Retrieves a list of all running processes.
    /// @return Result code.
    /// @note Syscall number 0x65.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetProcessList(num_out: *mut u32, pids_out: *mut u64, max_pids: u32) -> Result;
}
extern "C" {
    /// @brief Retrieves a list of all threads for a debug handle (or zero).
    /// @return Result code.
    /// @note Syscall number 0x66.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetThreadList(
        num_out: *mut u32,
        tids_out: *mut u64,
        max_tids: u32,
        debug: Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Queries memory information from a process that is being debugged.
    /// @return Result code.
    /// @note Syscall number 0x69.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcQueryDebugProcessMemory(
        meminfo_ptr: *mut MemoryInfo,
        pageinfo: *mut u32,
        debug: Handle,
        addr: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Reads memory from a process that is being debugged.
    /// @return Result code.
    /// @note Syscall number 0x6A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcReadDebugProcessMemory(
        buffer: *mut lang_items::c_void,
        debug: Handle,
        addr: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Writes to memory in a process that is being debugged.
    /// @return Result code.
    /// @note Syscall number 0x6B.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcWriteDebugProcessMemory(
        debug: Handle,
        buffer: *const lang_items::c_void,
        addr: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Gets parameters from a thread in a debugging session.
    /// @return Result code.
    /// @note Syscall number 0x6D.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetDebugThreadParam(
        out_64: *mut u64,
        out_32: *mut u32,
        debug: Handle,
        threadID: u64,
        param: DebugThreadParam,
    ) -> Result;
}
extern "C" {
    /// @brief Retrieves privileged information about the system, or a certain kernel object.
    /// @param[out] out Variable to which store the information.
    /// @param[in] id0 First ID of the property to retrieve.
    /// @param[in] handle Handle of the object to retrieve information from, or \ref INVALID_HANDLE to retrieve information about the system.
    /// @param[in] id1 Second ID of the property to retrieve.
    /// @return Result code.
    /// @remark The full list of property IDs can be found on the <a href="https://switchbrew.org/wiki/SVC#svcGetSystemInfo">switchbrew.org wiki</a>.
    /// @note Syscall number 0x6F.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetSystemInfo(out: *mut u64, id0: u64, handle: Handle, id1: u64) -> Result;
}
extern "C" {
    /// @brief Creates a port.
    /// @return Result code.
    /// @note Syscall number 0x70.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreatePort(
        portServer: *mut Handle,
        portClient: *mut Handle,
        max_sessions: s32,
        is_light: bool,
        name: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    /// @brief Manages a named port.
    /// @return Result code.
    /// @note Syscall number 0x71.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcManageNamedPort(
        portServer: *mut Handle,
        name: *const lang_items::c_char,
        maxSessions: s32,
    ) -> Result;
}
extern "C" {
    /// @brief Manages a named port.
    /// @return Result code.
    /// @note Syscall number 0x72.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcConnectToPort(session: *mut Handle, port: Handle) -> Result;
}
extern "C" {
    /// @brief Sets the memory permissions for the specified memory with the supplied process handle.
    /// @param[in] proc Process handle.
    /// @param[in] addr Address of the memory.
    /// @param[in] size Size of the memory.
    /// @param[in] perm Permissions (see \ref Permission).
    /// @return Result code.
    /// @remark This returns an error (0xD801) when \p perm is >0x5, hence -WX and RWX are not allowed.
    /// @note Syscall number 0x73.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetProcessMemoryPermission(proc_: Handle, addr: u64, size: u64, perm: u32) -> Result;
}
extern "C" {
    /// @brief Maps the src address from the supplied process handle into the current process.
    /// @param[in] dst Address to which map the memory in the current process.
    /// @param[in] proc Process handle.
    /// @param[in] src Source mapping address.
    /// @param[in] size Size of the memory.
    /// @return Result code.
    /// @remark This allows mapping code and rodata with RW- permission.
    /// @note Syscall number 0x74.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapProcessMemory(
        dst: *mut lang_items::c_void,
        proc_: Handle,
        src: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapProcessMemory.
    /// @param[in] dst Destination mapping address
    /// @param[in] proc Process handle.
    /// @param[in] src Address of the memory in the process.
    /// @param[in] size Size of the memory.
    /// @return Result code.
    /// @remark This allows mapping code and rodata with RW- permission.
    /// @note Syscall number 0x75.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapProcessMemory(
        dst: *mut lang_items::c_void,
        proc_: Handle,
        src: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Maps normal heap in a certain process as executable code (used when loading NROs).
    /// @param[in] proc Process handle (cannot be \ref CUR_PROCESS_HANDLE).
    /// @param[in] dst Destination mapping address.
    /// @param[in] src Source mapping address.
    /// @param[in] size Size of the mapping.
    /// @return Result code.
    /// @note Syscall number 0x77.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcMapProcessCodeMemory(proc_: Handle, dst: u64, src: u64, size: u64) -> Result;
}
extern "C" {
    /// @brief Undoes the effects of \ref svcMapProcessCodeMemory.
    /// @param[in] proc Process handle (cannot be \ref CUR_PROCESS_HANDLE).
    /// @param[in] dst Destination mapping address.
    /// @param[in] src Source mapping address.
    /// @param[in] size Size of the mapping.
    /// @return Result code.
    /// @note Syscall number 0x78.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcUnmapProcessCodeMemory(proc_: Handle, dst: u64, src: u64, size: u64) -> Result;
}
extern "C" {
    /// @brief Creates a new process.
    /// @return Result code.
    /// @note Syscall number 0x79.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateProcess(
        out: *mut Handle,
        proc_info: *mut lang_items::c_void,
        caps: *mut u32,
        cap_num: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Starts executing a freshly created process.
    /// @return Result code.
    /// @note Syscall number 0x7A.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcStartProcess(
        proc_: Handle,
        main_prio: s32,
        default_cpu: s32,
        stack_size: u32,
    ) -> Result;
}
extern "C" {
    /// @brief Terminates a running process.
    /// @return Result code.
    /// @note Syscall number 0x7B.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcTerminateProcess(proc_: Handle) -> Result;
}
extern "C" {
    /// @brief Gets a \ref ProcessInfoType for a process.
    /// @return Result code.
    /// @note Syscall number 0x7C.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcGetProcessInfo(out: *mut u64, proc_: Handle, which: ProcessInfoType) -> Result;
}
extern "C" {
    /// @brief Creates a new Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x7D.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCreateResourceLimit(out: *mut Handle) -> Result;
}
extern "C" {
    /// @brief Sets the value for a \ref LimitableResource for a Resource Limit handle.
    /// @return Result code.
    /// @note Syscall number 0x7E.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcSetResourceLimitLimitValue(
        reslimit: Handle,
        which: LimitableResource,
        value: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Calls a secure monitor function (TrustZone, EL3).
    /// @param regs Arguments to pass to the secure monitor.
    /// @return Return value from the secure monitor.
    /// @note Syscall number 0x7F.
    /// @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
    pub fn svcCallSecureMonitor(regs: *mut SecmonArgs) -> u64;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
#[test]
fn bindgen_test_layout___lock_t() {
    assert_eq!(
        ::core::mem::size_of::<__lock_t>(),
        12usize,
        concat!("Size of: ", stringify!(__lock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__lock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__lock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).thread_tag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(thread_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__lock_t>())).counter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__lock_t),
            "::",
            stringify!(counter)
        )
    );
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> lang_items::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> lang_items::c_int;
}
/// Mutex datatype, defined in newlib.
pub type Mutex = _LOCK_T;
/// Recursive mutex datatype, defined in newlib.
pub type RMutex = _LOCK_RECURSIVE_T;
extern "C" {
    /// @brief Locks a mutex.
    /// @param m Mutex object.
    pub fn mutexLock(m: *mut Mutex);
}
extern "C" {
    /// @brief Attempts to lock a mutex without waiting.
    /// @param m Mutex object.
    /// @return 1 if the mutex has been acquired successfully, and 0 on contention.
    pub fn mutexTryLock(m: *mut Mutex) -> bool;
}
extern "C" {
    /// @brief Unlocks a mutex.
    /// @param m Mutex object.
    pub fn mutexUnlock(m: *mut Mutex);
}
extern "C" {
    /// @brief Locks a recursive mutex.
    /// @param m Recursive mutex object.
    pub fn rmutexLock(m: *mut RMutex);
}
extern "C" {
    /// @brief Attempts to lock a recursive mutex without waiting.
    /// @param m Recursive mutex object.
    /// @return 1 if the mutex has been acquired successfully, and 0 on contention.
    pub fn rmutexTryLock(m: *mut RMutex) -> bool;
}
extern "C" {
    /// @brief Unlocks a recursive mutex.
    /// @param m Recursive mutex object.
    pub fn rmutexUnlock(m: *mut RMutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitableMethods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitableNode {
    pub prev: *mut WaitableNode,
    pub next: *mut WaitableNode,
}
#[test]
fn bindgen_test_layout_WaitableNode() {
    assert_eq!(
        ::core::mem::size_of::<WaitableNode>(),
        16usize,
        concat!("Size of: ", stringify!(WaitableNode))
    );
    assert_eq!(
        ::core::mem::align_of::<WaitableNode>(),
        8usize,
        concat!("Alignment of ", stringify!(WaitableNode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WaitableNode>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WaitableNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<WaitableNode>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WaitableNode),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Waitable {
    pub vt: *const WaitableMethods,
    pub list: WaitableNode,
    pub mutex: Mutex,
}
#[test]
fn bindgen_test_layout_Waitable() {
    assert_eq!(
        ::core::mem::size_of::<Waitable>(),
        32usize,
        concat!("Size of: ", stringify!(Waitable))
    );
    assert_eq!(
        ::core::mem::align_of::<Waitable>(),
        8usize,
        concat!("Alignment of ", stringify!(Waitable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitable>())).vt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitable),
            "::",
            stringify!(vt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitable>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitable),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waitable>())).mutex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Waitable),
            "::",
            stringify!(mutex)
        )
    );
}
pub const WaiterType_WaiterType_Handle: WaiterType = 0;
pub const WaiterType_WaiterType_HandleWithClear: WaiterType = 1;
pub const WaiterType_WaiterType_Waitable: WaiterType = 2;
pub type WaiterType = u32;
/// Waiter structure, representing any generic waitable synchronization object; both kernel-mode and user-mode.
#[repr(C)]
pub struct Waiter {
    pub type_: WaiterType,
    pub __bindgen_anon_1: Waiter__bindgen_ty_1,
}
#[repr(C)]
pub struct Waiter__bindgen_ty_1 {
    pub handle: __BindgenUnionField<Handle>,
    pub waitable: __BindgenUnionField<*mut Waitable>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_Waiter__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<Waiter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Waiter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Waiter__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Waiter__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waiter__bindgen_ty_1>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waiter__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waiter__bindgen_ty_1>())).waitable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waiter__bindgen_ty_1),
            "::",
            stringify!(waitable)
        )
    );
}
#[test]
fn bindgen_test_layout_Waiter() {
    assert_eq!(
        ::core::mem::size_of::<Waiter>(),
        16usize,
        concat!("Size of: ", stringify!(Waiter))
    );
    assert_eq!(
        ::core::mem::align_of::<Waiter>(),
        8usize,
        concat!("Alignment of ", stringify!(Waiter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Waiter>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Waiter),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// @brief Waits for an arbitrary number of generic waitable synchronization objects, optionally with a timeout.
    /// @param[out] idx_out Variable that will received the index of the signalled object.
    /// @param[in] objects Array containing \ref Waiter structures.
    /// @param[in] num_objects Number of objects in the array.
    /// @param[in] timeout Timeout (in nanoseconds).
    /// @return Result code.
    /// @note The number of objects must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
    pub fn waitObjects(
        idx_out: *mut s32,
        objects: *const Waiter,
        num_objects: s32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// @brief Waits for an arbitrary number of kernel synchronization objects, optionally with a timeout. This function replaces \ref svcWaitSynchronization.
    /// @param[out] idx_out Variable that will received the index of the signalled object.
    /// @param[in] handles Array containing handles.
    /// @param[in] num_handles Number of handles in the array.
    /// @param[in] timeout Timeout (in nanoseconds).
    /// @return Result code.
    /// @note The number of objects must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
    pub fn waitHandles(
        idx_out: *mut s32,
        handles: *const Handle,
        num_handles: s32,
        timeout: u64,
    ) -> Result;
}
/// Transfer memory information structure.
#[repr(C)]
pub struct TransferMemory {
    /// < Kernel object handle.
    pub handle: Handle,
    /// < Size of the transfer memory object.
    pub size: usize,
    /// < Permissions of the transfer memory object.
    pub perm: Permission,
    /// < Address of the source backing memory.
    pub src_addr: *mut lang_items::c_void,
    /// < Address to which the transfer memory object is mapped.
    pub map_addr: *mut lang_items::c_void,
}
#[test]
fn bindgen_test_layout_TransferMemory() {
    assert_eq!(
        ::core::mem::size_of::<TransferMemory>(),
        40usize,
        concat!("Size of: ", stringify!(TransferMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<TransferMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(TransferMemory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).perm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).src_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TransferMemory>())).map_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TransferMemory),
            "::",
            stringify!(map_addr)
        )
    );
}
extern "C" {
    /// @brief Creates a transfer memory object.
    /// @param t Transfer memory information structure that will be filled in.
    /// @param size Size of the transfer memory object to create.
    /// @param perm Permissions with which to protect the transfer memory in the local process.
    /// @return Result code.
    pub fn tmemCreate(t: *mut TransferMemory, size: usize, perm: Permission) -> Result;
}
extern "C" {
    /// @brief Loads a transfer memory object coming from a remote process.
    /// @param t Transfer memory information structure which will be filled in.
    /// @param handle Handle of the transfer memory object.
    /// @param size Size of the transfer memory object that is being loaded.
    /// @param perm Permissions which the transfer memory is expected to have in the process that owns the memory.
    /// @warning This is a privileged operation; in normal circumstances applications shouldn't use this function.
    pub fn tmemLoadRemote(t: *mut TransferMemory, handle: Handle, size: usize, perm: Permission);
}
extern "C" {
    /// @brief Maps a transfer memory object.
    /// @param t Transfer memory information structure.
    /// @return Result code.
    /// @warning This is a privileged operation; in normal circumstances applications cannot use this function.
    pub fn tmemMap(t: *mut TransferMemory) -> Result;
}
extern "C" {
    /// @brief Unmaps a transfer memory object.
    /// @param t Transfer memory information structure.
    /// @return Result code.
    /// @warning This is a privileged operation; in normal circumstances applications cannot use this function.
    pub fn tmemUnmap(t: *mut TransferMemory) -> Result;
}
extern "C" {
    /// @brief Frees up resources used by a transfer memory object, unmapping and closing handles, etc.
    /// @param t Transfer memory information structure.
    /// @return Result code.
    pub fn tmemClose(t: *mut TransferMemory) -> Result;
}
/// Shared memory information structure.
#[repr(C)]
pub struct SharedMemory {
    /// < Kernel object handle.
    pub handle: Handle,
    /// < Size of the shared memory object.
    pub size: usize,
    /// < Permissions.
    pub perm: Permission,
    /// < Address to which the shared memory object is mapped.
    pub map_addr: *mut lang_items::c_void,
}
#[test]
fn bindgen_test_layout_SharedMemory() {
    assert_eq!(
        ::core::mem::size_of::<SharedMemory>(),
        32usize,
        concat!("Size of: ", stringify!(SharedMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<SharedMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(SharedMemory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).perm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SharedMemory>())).map_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedMemory),
            "::",
            stringify!(map_addr)
        )
    );
}
extern "C" {
    /// @brief Creates a shared memory object.
    /// @param s Shared memory information structure which will be filled in.
    /// @param size Size of the shared memory object to create.
    /// @param local_perm Permissions with which the shared memory object will be mapped in the local process.
    /// @param remote_perm Permissions with which the shared memory object will be mapped in the remote process (can be Perm_DontCare).
    /// @return Result code.
    /// @warning This is a privileged operation; in normal circumstances applications cannot use this function.
    pub fn shmemCreate(
        s: *mut SharedMemory,
        size: usize,
        local_perm: Permission,
        remote_perm: Permission,
    ) -> Result;
}
extern "C" {
    /// @brief Loads a shared memory object coming from a remote process.
    /// @param s Shared memory information structure which will be filled in.
    /// @param handle Handle of the shared memory object.
    /// @param size Size of the shared memory object that is being loaded.
    /// @param perm Permissions with which the shared memory object will be mapped in the local process.
    pub fn shmemLoadRemote(s: *mut SharedMemory, handle: Handle, size: usize, perm: Permission);
}
extern "C" {
    /// @brief Maps a shared memory object.
    /// @param s Shared memory information structure.
    /// @return Result code.
    pub fn shmemMap(s: *mut SharedMemory) -> Result;
}
extern "C" {
    /// @brief Unmaps a shared memory object.
    /// @param s Shared memory information structure.
    /// @return Result code.
    pub fn shmemUnmap(s: *mut SharedMemory) -> Result;
}
extern "C" {
    /// @brief Frees up resources used by a shared memory object, unmapping and closing handles, etc.
    /// @param s Shared memory information structure.
    /// @return Result code.
    pub fn shmemClose(s: *mut SharedMemory) -> Result;
}
#[repr(C)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub struct Event {
    pub revent: Handle,
    pub wevent: Handle,
    pub autoclear: bool,
}
#[test]
fn bindgen_test_layout_Event() {
    assert_eq!(
        ::core::mem::size_of::<Event>(),
        12usize,
        concat!("Size of: ", stringify!(Event))
    );
    assert_eq!(
        ::core::mem::align_of::<Event>(),
        4usize,
        concat!("Alignment of ", stringify!(Event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Event>())).revent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(revent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Event>())).wevent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(wevent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Event>())).autoclear as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Event),
            "::",
            stringify!(autoclear)
        )
    );
}
extern "C" {
    pub fn eventCreate(t: *mut Event, autoclear: bool) -> Result;
}
extern "C" {
    pub fn eventLoadRemote(t: *mut Event, handle: Handle, autoclear: bool);
}
extern "C" {
    pub fn eventClose(t: *mut Event);
}
extern "C" {
    pub fn eventWait(t: *mut Event, timeout: u64) -> Result;
}
extern "C" {
    pub fn eventFire(t: *mut Event) -> Result;
}
extern "C" {
    pub fn eventClear(t: *mut Event) -> Result;
}
/// User-mode event object.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEvent {
    pub waitable: Waitable,
    pub signal: bool,
    pub auto_clear: bool,
}
#[test]
fn bindgen_test_layout_UEvent() {
    assert_eq!(
        ::core::mem::size_of::<UEvent>(),
        40usize,
        concat!("Size of: ", stringify!(UEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<UEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(UEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UEvent>())).waitable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UEvent),
            "::",
            stringify!(waitable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UEvent>())).signal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UEvent),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UEvent>())).auto_clear as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(UEvent),
            "::",
            stringify!(auto_clear)
        )
    );
}
extern "C" {
    /// @brief Creates a user-mode event.
    /// @param[out] e UEvent object.
    /// @param[in] bool auto_clear Whether to automatically clear the event.
    /// @note It is safe to wait on this event with several threads simultaneously.
    /// @note If more than one thread is listening on it, at least one thread will get the signal. No other guarantees.
    pub fn ueventCreate(e: *mut UEvent, auto_clear: bool);
}
extern "C" {
    /// @brief Clears the event signal.
    /// @param[in] e UEvent object.
    pub fn ueventClear(e: *mut UEvent);
}
extern "C" {
    /// @brief Signals the event.
    /// @param[in] e UEvent object.
    pub fn ueventSignal(e: *mut UEvent);
}
/// < Timers of this kind fire once and then stop automatically.
pub const TimerType_TimerType_OneShot: TimerType = 0;
/// < Timers of this kind fire periodically.
pub const TimerType_TimerType_Repeating: TimerType = 1;
/// Valid types for a user-mode timer.
pub type TimerType = u32;
/// User-mode timer object.
#[repr(C)]
pub struct UTimer {
    pub waitable: Waitable,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub next_tick: u64,
    pub interval: u64,
}
#[test]
fn bindgen_test_layout_UTimer() {
    assert_eq!(
        ::core::mem::size_of::<UTimer>(),
        56usize,
        concat!("Size of: ", stringify!(UTimer))
    );
    assert_eq!(
        ::core::mem::align_of::<UTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(UTimer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UTimer>())).waitable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UTimer),
            "::",
            stringify!(waitable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UTimer>())).next_tick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UTimer),
            "::",
            stringify!(next_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UTimer>())).interval as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UTimer),
            "::",
            stringify!(interval)
        )
    );
}
impl UTimer {
    #[inline]
    pub fn type_(&self) -> TimerType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: TimerType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn started(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_started(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: TimerType,
        started: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let started: u8 = unsafe { ::core::mem::transmute(started) };
            started as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    /// @brief Creates a user-mode timer.
    /// @param[out] t UTimer object.
    /// @param[in] interval Interval (in nanoseconds).
    /// @param[in] type Type of timer to create (see \ref TimerType).
    /// @note The timer is stopped when it is created. Use \ref utimerStart to start it.
    /// @note It is safe to wait on this timer with several threads simultaneously.
    /// @note If more than one thread is listening on it, at least one thread will get the signal. No other guarantees.
    /// @note For a repeating timer: If the timer triggers twice before you wait on it, you will only get one signal.
    pub fn utimerCreate(t: *mut UTimer, interval: u64, type_: TimerType);
}
extern "C" {
    /// @brief Starts the timer.
    /// @param[in] t UTimer object.
    pub fn utimerStart(t: *mut UTimer);
}
extern "C" {
    /// @brief Stops the timer.
    /// @param[in] t UTimer object.
    pub fn utimerStop(t: *mut UTimer);
}
/// Read/write lock structure.
#[repr(C)]
pub struct RwLock {
    pub r: RMutex,
    pub g: RMutex,
    pub b: u64,
}
#[test]
fn bindgen_test_layout_RwLock() {
    assert_eq!(
        ::core::mem::size_of::<RwLock>(),
        32usize,
        concat!("Size of: ", stringify!(RwLock))
    );
    assert_eq!(
        ::core::mem::align_of::<RwLock>(),
        8usize,
        concat!("Alignment of ", stringify!(RwLock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RwLock>())).r as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(RwLock), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RwLock>())).g as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(RwLock), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RwLock>())).b as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(RwLock), "::", stringify!(b))
    );
}
extern "C" {
    /// @brief Initializes the read/write lock.
    /// @param r Read/write lock object.
    pub fn rwlockInit(r: *mut RwLock);
}
extern "C" {
    /// @brief Locks the read/write lock for reading.
    /// @param r Read/write lock object.
    pub fn rwlockReadLock(r: *mut RwLock);
}
extern "C" {
    /// @brief Unlocks the read/write lock for reading.
    /// @param r Read/write lock object.
    pub fn rwlockReadUnlock(r: *mut RwLock);
}
extern "C" {
    /// @brief Locks the read/write lock for writing.
    /// @param r Read/write lock object.
    pub fn rwlockWriteLock(r: *mut RwLock);
}
extern "C" {
    /// @brief Unlocks the read/write lock for writing.
    /// @param r Read/write lock object.
    pub fn rwlockWriteUnlock(r: *mut RwLock);
}
/// Condition variable.
pub type CondVar = u32;
extern "C" {
    /// @brief Waits on a condition variable with a timeout.
    /// @param[in] c Condition variable object.
    /// @param[in] m Mutex object to use inside the condition variable.
    /// @param[in] timeout Timeout in nanoseconds.
    /// @return Result code (0xEA01 on timeout).
    /// @remark On function return, the underlying mutex is acquired.
    pub fn condvarWaitTimeout(c: *mut CondVar, m: *mut Mutex, timeout: u64) -> Result;
}
/// Thread information structure.
#[repr(C)]
pub struct Thread {
    /// < Thread handle.
    pub handle: Handle,
    /// < Pointer to stack memory.
    pub stack_mem: *mut lang_items::c_void,
    /// < Pointer to stack memory mirror.
    pub stack_mirror: *mut lang_items::c_void,
    /// < Stack size.
    pub stack_sz: usize,
}
#[test]
fn bindgen_test_layout_Thread() {
    assert_eq!(
        ::core::mem::size_of::<Thread>(),
        32usize,
        concat!("Size of: ", stringify!(Thread))
    );
    assert_eq!(
        ::core::mem::align_of::<Thread>(),
        8usize,
        concat!("Alignment of ", stringify!(Thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).stack_mem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(stack_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).stack_mirror as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(stack_mirror)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Thread>())).stack_sz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Thread),
            "::",
            stringify!(stack_sz)
        )
    );
}
extern "C" {
    /// @brief Creates a thread.
    /// @param t Thread information structure which will be filled in.
    /// @param entry Entrypoint of the thread.
    /// @param arg Argument to pass to the entrypoint.
    /// @param stack_sz Stack size (rounded up to page alignment).
    /// @param prio Thread priority (0x00~0x3F); 0x2C is the usual priority of the main thread, 0x3B is a special priority on cores 0..2 that enables preemptive multithreading (0x3F on core 3).
    /// @param cpuid ID of the core on which to create the thread (0~3); or -2 to use the default core for the current process.
    /// @return Result code.
    pub fn threadCreate(
        t: *mut Thread,
        entry: ThreadFunc,
        arg: *mut lang_items::c_void,
        stack_sz: usize,
        prio: lang_items::c_int,
        cpuid: lang_items::c_int,
    ) -> Result;
}
extern "C" {
    /// @brief Starts the execution of a thread.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadStart(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Waits for a thread to finish executing.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadWaitForExit(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Frees up resources associated with a thread.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadClose(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Pauses the execution of a thread.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadPause(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Resumes the execution of a thread, after having been paused.
    /// @param t Thread information structure.
    /// @return Result code.
    pub fn threadResume(t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Dumps the registers of a thread paused by @ref threadPause (register groups: all).
    /// @param[out] ctx Output thread context (register dump).
    /// @param t Thread information structure.
    /// @return Result code.
    /// @warning Official kernel will not dump x0..x18 if the thread is currently executing a system call, and prior to 6.0.0 doesn't dump TPIDR_EL0.
    pub fn threadDumpContext(ctx: *mut ThreadContext, t: *mut Thread) -> Result;
}
extern "C" {
    /// @brief Gets the raw handle to the current thread.
    /// @return The current thread's handle.
    pub fn threadGetCurHandle() -> Handle;
}
/// Semaphore structure.
#[repr(C)]
pub struct Semaphore {
    /// < Condition variable object.
    pub condvar: CondVar,
    /// < Mutex object.
    pub mutex: Mutex,
    /// < Internal counter.
    pub count: u64,
}
#[test]
fn bindgen_test_layout_Semaphore() {
    assert_eq!(
        ::core::mem::size_of::<Semaphore>(),
        16usize,
        concat!("Size of: ", stringify!(Semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<Semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(Semaphore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Semaphore>())).condvar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Semaphore),
            "::",
            stringify!(condvar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Semaphore>())).mutex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Semaphore),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Semaphore>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Semaphore),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    /// @brief Initializes a semaphore and its internal counter.
    /// @param s Semaphore object.
    /// @param initial_count initial value for internal counter (typically the # of free resources).
    pub fn semaphoreInit(s: *mut Semaphore, initial_count: u64);
}
extern "C" {
    /// @brief Increments the Semaphore to allow other threads to continue.
    /// @param s Semaphore object.
    pub fn semaphoreSignal(s: *mut Semaphore);
}
extern "C" {
    /// @brief Decrements Semaphore and waits if 0.
    /// @param s Semaphore object.
    pub fn semaphoreWait(s: *mut Semaphore);
}
extern "C" {
    /// @brief Attempts to get lock without waiting.
    /// @param s Semaphore object.
    /// @return true if no wait and successful lock, false otherwise.
    pub fn semaphoreTryWait(s: *mut Semaphore) -> bool;
}
extern "C" {
    /// @brief Reserves a slice of general purpose address space.
    /// @param size The size of the slice of address space that will be reserved (rounded up to page alignment).
    /// @return Pointer to the slice of address space, or NULL on failure.
    pub fn virtmemReserve(size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// @brief Relinquishes a slice of address space reserved with virtmemReserve (currently no-op).
    /// @param addr Pointer to the slice.
    /// @param size Size of the slice.
    pub fn virtmemFree(addr: *mut lang_items::c_void, size: usize);
}
extern "C" {
    /// @brief Reserves a slice of address space inside the stack memory mapping region (for use with svcMapMemory).
    /// @param size The size of the slice of address space that will be reserved (rounded up to page alignment).
    /// @return Pointer to the slice of address space, or NULL on failure.
    pub fn virtmemReserveStack(size: usize) -> *mut lang_items::c_void;
}
extern "C" {
    /// @brief Relinquishes a slice of address space reserved with virtmemReserveStack (currently no-op).
    /// @param addr Pointer to the slice.
    /// @param size Size of the slice.
    pub fn virtmemFreeStack(addr: *mut lang_items::c_void, size: usize);
}
extern "C" {
    /// Returns true if the kernel version is equal to or above 2.0.0.
    pub fn kernelAbove200() -> bool;
}
extern "C" {
    /// Returns true if the kernel version is equal to or above 3.0.0.
    pub fn kernelAbove300() -> bool;
}
extern "C" {
    /// Returns true if the kernel version is equal to or above 4.0.0.
    pub fn kernelAbove400() -> bool;
}
extern "C" {
    /// Returns true if the kernel version is equal to or above 5.0.0.
    pub fn kernelAbove500() -> bool;
}
extern "C" {
    /// Returns true if the kernel version is equal to or above 6.0.0.
    pub fn kernelAbove600() -> bool;
}
extern "C" {
    /// Returns true if the process has a debugger attached.
    pub fn detectDebugger() -> bool;
}
extern "C" {
    /// @brief Fills a buffer with random data.
    /// @param buf Pointer to the buffer.
    /// @param len Size of the buffer in bytes.
    pub fn randomGet(buf: *mut lang_items::c_void, len: usize);
}
extern "C" {
    /// @brief Returns a random 64-bit value.
    /// @return Random value.
    pub fn randomGet64() -> u64;
}
/// < JIT supported using svcSetProcessMemoryPermission
pub const JitType_JitType_CodeMemory: JitType = 0;
/// < JIT supported using 4.0.0+ code-memory syscalls (this isn't usable on 5.0.0+ so JitType_CodeMemory is used instead).
pub const JitType_JitType_JitMemory: JitType = 1;
/// JIT implementation type.
pub type JitType = u32;
/// JIT buffer object.
#[repr(C)]
pub struct Jit {
    pub type_: JitType,
    pub size: usize,
    pub src_addr: *mut lang_items::c_void,
    pub rx_addr: *mut lang_items::c_void,
    pub rw_addr: *mut lang_items::c_void,
    pub is_executable: bool,
    pub handle: Handle,
}
#[test]
fn bindgen_test_layout_Jit() {
    assert_eq!(
        ::core::mem::size_of::<Jit>(),
        48usize,
        concat!("Size of: ", stringify!(Jit))
    );
    assert_eq!(
        ::core::mem::align_of::<Jit>(),
        8usize,
        concat!("Alignment of ", stringify!(Jit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Jit), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).src_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).rx_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(rx_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).rw_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(rw_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).is_executable as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(is_executable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Jit>())).handle as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Jit),
            "::",
            stringify!(handle)
        )
    );
}
extern "C" {
    /// @brief Creates a JIT buffer.
    /// @param j JIT buffer.
    /// @param size Size of the JIT buffer.
    /// @return Result code.
    pub fn jitCreate(j: *mut Jit, size: usize) -> Result;
}
extern "C" {
    /// @brief Transition a JIT buffer to have writable permission.
    /// @param j JIT buffer.
    /// @return Result code.
    pub fn jitTransitionToWritable(j: *mut Jit) -> Result;
}
extern "C" {
    /// @brief Transition a JIT buffer to have executable permission.
    /// @param j JIT buffer.
    /// @return Result code.
    pub fn jitTransitionToExecutable(j: *mut Jit) -> Result;
}
extern "C" {
    /// @brief Destroys a JIT buffer.
    /// @param j JIT buffer.
    /// @return Result code.
    pub fn jitClose(j: *mut Jit) -> Result;
}
extern "C" {
    /// @brief Gets the address of the writable memory alias of a JIT buffer.
    /// @param j JIT buffer.
    /// @return Pointer to alias of the JIT buffer that can be written to.
    pub fn jitGetRwAddr(j: *mut Jit) -> *mut lang_items::c_void;
}
extern "C" {
    /// @brief Gets the address of the executable memory alias of a JIT buffer.
    /// @param j JIT buffer.
    /// @return Pointer to alias of the JIT buffer that can be executed.
    pub fn jitGetRxAddr(j: *mut Jit) -> *mut lang_items::c_void;
}
/// < Regular buffer.
pub const BufferType_BufferType_Normal: BufferType = 0;
/// < Allows ProcessMemory and shared TransferMemory.
pub const BufferType_BufferType_Type1: BufferType = 1;
pub const BufferType_BufferType_Invalid: BufferType = 2;
/// < Same as Type1 except remote process is not allowed to use device-mapping.
pub const BufferType_BufferType_Type3: BufferType = 3;
pub type BufferType = u32;
pub const BufferDirection_BufferDirection_Send: BufferDirection = 0;
pub const BufferDirection_BufferDirection_Recv: BufferDirection = 1;
pub const BufferDirection_BufferDirection_Exch: BufferDirection = 2;
pub type BufferDirection = u32;
pub const IpcCommandType_IpcCommandType_Invalid: IpcCommandType = 0;
pub const IpcCommandType_IpcCommandType_LegacyRequest: IpcCommandType = 1;
pub const IpcCommandType_IpcCommandType_Close: IpcCommandType = 2;
pub const IpcCommandType_IpcCommandType_LegacyControl: IpcCommandType = 3;
pub const IpcCommandType_IpcCommandType_Request: IpcCommandType = 4;
pub const IpcCommandType_IpcCommandType_Control: IpcCommandType = 5;
pub const IpcCommandType_IpcCommandType_RequestWithContext: IpcCommandType = 6;
pub const IpcCommandType_IpcCommandType_ControlWithContext: IpcCommandType = 7;
pub type IpcCommandType = u32;
pub const DomainMessageType_DomainMessageType_Invalid: DomainMessageType = 0;
pub const DomainMessageType_DomainMessageType_SendMessage: DomainMessageType = 1;
pub const DomainMessageType_DomainMessageType_Close: DomainMessageType = 2;
pub type DomainMessageType = u32;
/// IPC domain message header.
#[repr(C)]
pub struct DomainMessageHeader {
    pub Type: u8,
    pub NumObjectIds: u8,
    pub Length: u16,
    pub ThisObjectId: u32,
    pub Pad: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_DomainMessageHeader() {
    assert_eq!(
        ::core::mem::size_of::<DomainMessageHeader>(),
        16usize,
        concat!("Size of: ", stringify!(DomainMessageHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<DomainMessageHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(DomainMessageHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainMessageHeader>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DomainMessageHeader>())).NumObjectIds as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(NumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainMessageHeader>())).Length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DomainMessageHeader>())).ThisObjectId as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(ThisObjectId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainMessageHeader>())).Pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainMessageHeader),
            "::",
            stringify!(Pad)
        )
    );
}
/// IPC domain response header.
#[repr(C)]
pub struct DomainResponseHeader {
    pub NumObjectIds: u32,
    pub Pad: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_DomainResponseHeader() {
    assert_eq!(
        ::core::mem::size_of::<DomainResponseHeader>(),
        16usize,
        concat!("Size of: ", stringify!(DomainResponseHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<DomainResponseHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(DomainResponseHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<DomainResponseHeader>())).NumObjectIds as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainResponseHeader),
            "::",
            stringify!(NumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DomainResponseHeader>())).Pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainResponseHeader),
            "::",
            stringify!(Pad)
        )
    );
}
#[repr(C)]
pub struct IpcCommand {
    pub NumSend: usize,
    pub NumRecv: usize,
    pub NumExch: usize,
    pub Buffers: [*const lang_items::c_void; 8usize],
    pub BufferSizes: [usize; 8usize],
    pub BufferTypes: [BufferType; 8usize],
    pub NumStaticIn: usize,
    pub NumStaticOut: usize,
    pub Statics: [*const lang_items::c_void; 8usize],
    pub StaticSizes: [usize; 8usize],
    pub StaticIndices: [u8; 8usize],
    pub SendPid: bool,
    pub NumHandlesCopy: usize,
    pub NumHandlesMove: usize,
    pub Handles: [Handle; 8usize],
    pub NumObjectIds: usize,
    pub ObjectIds: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_IpcCommand() {
    assert_eq!(
        ::core::mem::size_of::<IpcCommand>(),
        432usize,
        concat!("Size of: ", stringify!(IpcCommand))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcCommand>(),
        8usize,
        concat!("Alignment of ", stringify!(IpcCommand))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumSend as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumSend)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumRecv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumRecv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumExch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumExch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).Buffers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(Buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).BufferSizes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(BufferSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).BufferTypes as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(BufferTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumStaticIn as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumStaticIn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumStaticOut as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumStaticOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).Statics as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(Statics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).StaticSizes as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(StaticSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).StaticIndices as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(StaticIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).SendPid as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(SendPid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumHandlesCopy as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumHandlesCopy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumHandlesMove as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumHandlesMove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).Handles as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(Handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).NumObjectIds as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(NumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcCommand>())).ObjectIds as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcCommand),
            "::",
            stringify!(ObjectIds)
        )
    );
}
/// IPC buffer descriptor.
#[repr(C)]
pub struct IpcBufferDescriptor {
    /// < Size of the buffer.
    pub Size: u32,
    /// < Lower 32-bits of the address of the buffer
    pub Addr: u32,
    /// < Packed data (including higher bits of the address)
    pub Packed: u32,
}
#[test]
fn bindgen_test_layout_IpcBufferDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<IpcBufferDescriptor>(),
        12usize,
        concat!("Size of: ", stringify!(IpcBufferDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcBufferDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(IpcBufferDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcBufferDescriptor>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcBufferDescriptor),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcBufferDescriptor>())).Addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcBufferDescriptor),
            "::",
            stringify!(Addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcBufferDescriptor>())).Packed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcBufferDescriptor),
            "::",
            stringify!(Packed)
        )
    );
}
/// IPC static send-buffer descriptor.
#[repr(C)]
pub struct IpcStaticSendDescriptor {
    /// < Packed data (including higher bits of the address)
    pub Packed: u32,
    /// < Lower 32-bits of the address
    pub Addr: u32,
}
#[test]
fn bindgen_test_layout_IpcStaticSendDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<IpcStaticSendDescriptor>(),
        8usize,
        concat!("Size of: ", stringify!(IpcStaticSendDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcStaticSendDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(IpcStaticSendDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticSendDescriptor>())).Packed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticSendDescriptor),
            "::",
            stringify!(Packed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticSendDescriptor>())).Addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticSendDescriptor),
            "::",
            stringify!(Addr)
        )
    );
}
/// IPC static receive-buffer descriptor.
#[repr(C)]
pub struct IpcStaticRecvDescriptor {
    /// < Lower 32-bits of the address of the buffer
    pub Addr: u32,
    /// < Packed data (including higher bits of the address)
    pub Packed: u32,
}
#[test]
fn bindgen_test_layout_IpcStaticRecvDescriptor() {
    assert_eq!(
        ::core::mem::size_of::<IpcStaticRecvDescriptor>(),
        8usize,
        concat!("Size of: ", stringify!(IpcStaticRecvDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcStaticRecvDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(IpcStaticRecvDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticRecvDescriptor>())).Addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticRecvDescriptor),
            "::",
            stringify!(Addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcStaticRecvDescriptor>())).Packed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcStaticRecvDescriptor),
            "::",
            stringify!(Packed)
        )
    );
}
/// IPC parsed command (response) structure.
#[repr(C)]
pub struct IpcParsedCommand {
    /// < Type of the command
    pub CommandType: IpcCommandType,
    /// < true if the 'Pid' field is filled out.
    pub HasPid: bool,
    /// < PID included in the response (only if HasPid is true)
    pub Pid: u64,
    /// < Number of handles copied.
    pub NumHandles: usize,
    /// < Handles.
    pub Handles: [Handle; 8usize],
    /// < true if the handle was moved, false if it was copied.
    pub WasHandleCopied: [bool; 8usize],
    /// < true if the the message is a Domain message.
    pub IsDomainRequest: bool,
    /// < Type of the domain message.
    pub InMessageType: DomainMessageType,
    /// < Size of rawdata (for domain messages).
    pub InMessageLength: u32,
    /// < Object ID to call the command on (for domain messages).
    pub InThisObjectId: u32,
    /// < Number of object IDs (for domain messages).
    pub InNumObjectIds: usize,
    /// < Object IDs (for domain messages).
    pub InObjectIds: [u32; 8usize],
    /// < true if the the message is a Domain response.
    pub IsDomainResponse: bool,
    /// < Number of object IDs (for domain responses).
    pub OutNumObjectIds: usize,
    /// < Object IDs (for domain responses).
    pub OutObjectIds: [u32; 8usize],
    /// < Number of buffers in the response.
    pub NumBuffers: usize,
    /// < Pointers to the buffers.
    pub Buffers: [*mut lang_items::c_void; 8usize],
    /// < Sizes of the buffers.
    pub BufferSizes: [usize; 8usize],
    /// < Types of the buffers.
    pub BufferTypes: [BufferType; 8usize],
    /// < Direction of each buffer.
    pub BufferDirections: [BufferDirection; 8usize],
    /// < Number of statics in the response.
    pub NumStatics: usize,
    /// < Pointers to the statics.
    pub Statics: [*mut lang_items::c_void; 8usize],
    /// < Sizes of the statics.
    pub StaticSizes: [usize; 8usize],
    /// < Indices of the statics.
    pub StaticIndices: [u8; 8usize],
    /// < Number of output statics available in the response.
    pub NumStaticsOut: usize,
    /// < Pointer to the raw embedded data structure in the response.
    pub Raw: *mut lang_items::c_void,
    /// < Pointer to the raw embedded data structure, without padding.
    pub RawWithoutPadding: *mut lang_items::c_void,
    /// < Size of the raw embedded data.
    pub RawSize: usize,
}
#[test]
fn bindgen_test_layout_IpcParsedCommand() {
    assert_eq!(
        ::core::mem::size_of::<IpcParsedCommand>(),
        544usize,
        concat!("Size of: ", stringify!(IpcParsedCommand))
    );
    assert_eq!(
        ::core::mem::align_of::<IpcParsedCommand>(),
        8usize,
        concat!("Alignment of ", stringify!(IpcParsedCommand))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).CommandType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(CommandType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).HasPid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(HasPid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumHandles as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumHandles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Handles as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Handles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).WasHandleCopied as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(WasHandleCopied)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).IsDomainRequest as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(IsDomainRequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).InMessageType as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InMessageType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).InMessageLength as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InMessageLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).InThisObjectId as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InThisObjectId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).InNumObjectIds as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InNumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).InObjectIds as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(InObjectIds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).IsDomainResponse as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(IsDomainResponse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).OutNumObjectIds as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(OutNumObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).OutObjectIds as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(OutObjectIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumBuffers as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumBuffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Buffers as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).BufferSizes as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(BufferSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).BufferTypes as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(BufferTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).BufferDirections as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(BufferDirections)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumStatics as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumStatics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Statics as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Statics)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).StaticSizes as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(StaticSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).StaticIndices as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(StaticIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).NumStaticsOut as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(NumStaticsOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).Raw as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(Raw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IpcParsedCommand>())).RawWithoutPadding as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(RawWithoutPadding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IpcParsedCommand>())).RawSize as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(IpcParsedCommand),
            "::",
            stringify!(RawSize)
        )
    );
}
/// Barrier structure.
#[repr(C)]
pub struct Barrier {
    /// < Number of threads to reach the barrier.
    pub count: u64,
    /// < Number of threads to wait on.
    pub thread_total: u64,
    /// < Semaphore to make sure threads release to scheduler one at a time.
    pub throttle: Semaphore,
    /// < Semaphore to lock barrier to prevent multiple operations by threads at once.
    pub lock: Semaphore,
    /// < Semaphore to force a thread to wait if count < thread_total.
    pub thread_wait: Semaphore,
}
#[test]
fn bindgen_test_layout_Barrier() {
    assert_eq!(
        ::core::mem::size_of::<Barrier>(),
        64usize,
        concat!("Size of: ", stringify!(Barrier))
    );
    assert_eq!(
        ::core::mem::align_of::<Barrier>(),
        8usize,
        concat!("Alignment of ", stringify!(Barrier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).thread_total as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(thread_total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).throttle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(throttle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Barrier>())).thread_wait as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Barrier),
            "::",
            stringify!(thread_wait)
        )
    );
}
extern "C" {
    /// @brief Initializes a barrier and the number of threads to wait on.
    /// @param b Barrier object.
    /// @param thread_count Initial value for the number of threads the barrier must wait for.
    pub fn barrierInit(b: *mut Barrier, thread_count: u64);
}
extern "C" {
    /// @brief Forces threads to wait until all threads have called barrierWait.
    /// @param b Barrier object.
    pub fn barrierWait(b: *mut Barrier);
}
/// < Uninitialized service.
pub const ServiceType_ServiceType_Uninitialized: ServiceType = 0;
/// < Normal service.
pub const ServiceType_ServiceType_Normal: ServiceType = 1;
/// < Domain.
pub const ServiceType_ServiceType_Domain: ServiceType = 2;
/// < Domain subservice;
pub const ServiceType_ServiceType_DomainSubservice: ServiceType = 3;
/// < Service overriden in the homebrew environment.
pub const ServiceType_ServiceType_Override: ServiceType = 4;
/// Service type.
pub type ServiceType = u32;
/// Service object structure.
#[repr(C)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub struct Service {
    pub handle: Handle,
    pub object_id: u32,
    pub type_: ServiceType,
}
#[test]
fn bindgen_test_layout_Service() {
    assert_eq!(
        ::core::mem::size_of::<Service>(),
        12usize,
        concat!("Size of: ", stringify!(Service))
    );
    assert_eq!(
        ::core::mem::align_of::<Service>(),
        4usize,
        concat!("Alignment of ", stringify!(Service))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Service>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Service),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Service>())).object_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Service),
            "::",
            stringify!(object_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Service>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Service),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// @brief Initializes SM.
    /// @return Result code.
    /// @note This function is already called in the default application startup code (before main() is called).
    pub fn smInitialize() -> Result;
}
extern "C" {
    /// @brief Uninitializes SM.
    /// @return Result code.
    /// @note This function is already handled in the default application exit code (after main() returns).
    pub fn smExit();
}
extern "C" {
    /// @brief Requests a service from SM.
    /// @param[out] service_out Service structure which will be filled in.
    /// @param[in] name Name of the service to request.
    /// @return Result code.
    pub fn smGetService(service_out: *mut Service, name: *const lang_items::c_char) -> Result;
}
extern "C" {
    /// @brief Requests a service from SM, as an IPC session handle directly
    /// @param[out] handle_out Variable containing IPC session handle.
    /// @param[in] name Name of the service to request.
    /// @return Result code.
    pub fn smGetServiceOriginal(handle_out: *mut Handle, name: u64) -> Result;
}
extern "C" {
    /// @brief Retrieves an overriden service in the homebrew environment.
    /// @param[in] name Name of the service to request (as 64-bit integer).
    /// @return IPC session handle.
    pub fn smGetServiceOverride(name: u64) -> Handle;
}
extern "C" {
    /// @brief Creates and registers a new service within SM.
    /// @param[out] handle_out Variable containing IPC port handle.
    /// @param[in] name Name of the service.
    /// @param[in] is_light "Is light"
    /// @param[in] max_sessions Maximum number of concurrent sessions that the service will accept.
    /// @return Result code.
    pub fn smRegisterService(
        handle_out: *mut Handle,
        name: *const lang_items::c_char,
        is_light: bool,
        max_sessions: lang_items::c_int,
    ) -> Result;
}
extern "C" {
    /// @brief Unregisters a previously registered service in SM.
    /// @param[in] name Name of the service.
    /// @return Result code.
    pub fn smUnregisterService(name: *const lang_items::c_char) -> Result;
}
extern "C" {
    /// @brief Check whether SM is initialized.
    /// @return true if initialized.
    pub fn smHasInitialized() -> bool;
}
extern "C" {
    /// @brief Encodes a service name as a 64-bit integer.
    /// @param[in] name Name of the service.
    /// @return Encoded name.
    pub fn smEncodeName(name: *const lang_items::c_char) -> u64;
}
extern "C" {
    /// @brief Overrides a service with a custom IPC service handle.
    /// @param[in] name Name of the service (as 64-bit integer).
    /// @param[in] handle IPC session handle.
    pub fn smAddOverrideHandle(name: u64, handle: Handle);
}
#[repr(C)]
pub struct FsFileSystem {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsFileSystem() {
    assert_eq!(
        ::core::mem::size_of::<FsFileSystem>(),
        12usize,
        concat!("Size of: ", stringify!(FsFileSystem))
    );
    assert_eq!(
        ::core::mem::align_of::<FsFileSystem>(),
        4usize,
        concat!("Alignment of ", stringify!(FsFileSystem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsFileSystem>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsFileSystem),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsFile {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsFile() {
    assert_eq!(
        ::core::mem::size_of::<FsFile>(),
        12usize,
        concat!("Size of: ", stringify!(FsFile))
    );
    assert_eq!(
        ::core::mem::align_of::<FsFile>(),
        4usize,
        concat!("Alignment of ", stringify!(FsFile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsFile>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FsFile), "::", stringify!(s))
    );
}
#[repr(C)]
pub struct FsDir {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsDir() {
    assert_eq!(
        ::core::mem::size_of::<FsDir>(),
        12usize,
        concat!("Size of: ", stringify!(FsDir))
    );
    assert_eq!(
        ::core::mem::align_of::<FsDir>(),
        4usize,
        concat!("Alignment of ", stringify!(FsDir))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDir>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FsDir), "::", stringify!(s))
    );
}
#[repr(C)]
pub struct FsStorage {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsStorage() {
    assert_eq!(
        ::core::mem::size_of::<FsStorage>(),
        12usize,
        concat!("Size of: ", stringify!(FsStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<FsStorage>(),
        4usize,
        concat!("Alignment of ", stringify!(FsStorage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsStorage>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsStorage),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsSaveDataIterator {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsSaveDataIterator() {
    assert_eq!(
        ::core::mem::size_of::<FsSaveDataIterator>(),
        12usize,
        concat!("Size of: ", stringify!(FsSaveDataIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<FsSaveDataIterator>(),
        4usize,
        concat!("Alignment of ", stringify!(FsSaveDataIterator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataIterator>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataIterator),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsEventNotifier {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsEventNotifier() {
    assert_eq!(
        ::core::mem::size_of::<FsEventNotifier>(),
        12usize,
        concat!("Size of: ", stringify!(FsEventNotifier))
    );
    assert_eq!(
        ::core::mem::align_of::<FsEventNotifier>(),
        4usize,
        concat!("Alignment of ", stringify!(FsEventNotifier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsEventNotifier>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsEventNotifier),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct FsDeviceOperator {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_FsDeviceOperator() {
    assert_eq!(
        ::core::mem::size_of::<FsDeviceOperator>(),
        12usize,
        concat!("Size of: ", stringify!(FsDeviceOperator))
    );
    assert_eq!(
        ::core::mem::align_of::<FsDeviceOperator>(),
        4usize,
        concat!("Alignment of ", stringify!(FsDeviceOperator))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDeviceOperator>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDeviceOperator),
            "::",
            stringify!(s)
        )
    );
}
/// Directory entry.
#[repr(C)]
pub struct FsDirectoryEntry {
    /// < Entry name.
    pub name: [lang_items::c_char; 769usize],
    pub pad: [u8; 3usize],
    /// < See FsEntryType.
    pub type_: s8,
    /// < ?
    pub pad2: [u8; 3usize],
    /// < File size.
    pub fileSize: u64,
}
#[test]
fn bindgen_test_layout_FsDirectoryEntry() {
    assert_eq!(
        ::core::mem::size_of::<FsDirectoryEntry>(),
        784usize,
        concat!("Size of: ", stringify!(FsDirectoryEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<FsDirectoryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(FsDirectoryEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).pad as *const _ as usize },
        769usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).type_ as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).pad2 as *const _ as usize },
        773usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsDirectoryEntry>())).fileSize as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(FsDirectoryEntry),
            "::",
            stringify!(fileSize)
        )
    );
}
/// Save Struct
#[repr(C, packed)]
pub struct FsSave {
    /// < titleID of the savedata to access when accessing other titles' savedata via SaveData, otherwise FS_SAVEDATA_CURRENT_TITLEID.
    pub titleID: u64,
    /// < userID of the user-specific savedata to access, otherwise FS_SAVEDATA_USERID_COMMONSAVE. See account.h.
    pub userID: u128,
    /// < saveID, 0 for SaveData.
    pub saveID: u64,
    /// < See \ref FsSaveDataType.
    pub SaveDataType: u64,
    /// < 0 for SystemSaveData/SaveData.
    pub unk_x28: u64,
    /// < 0 for SystemSaveData/SaveData.
    pub unk_x30: u64,
    /// < 0 for SystemSaveData/SaveData.
    pub unk_x38: u64,
}
#[test]
fn bindgen_test_layout_FsSave() {
    assert_eq!(
        ::core::mem::size_of::<FsSave>(),
        64usize,
        concat!("Size of: ", stringify!(FsSave))
    );
    assert_eq!(
        ::core::mem::align_of::<FsSave>(),
        1usize,
        concat!("Alignment of ", stringify!(FsSave))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).titleID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).userID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(userID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).saveID as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(saveID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).SaveDataType as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(SaveDataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).unk_x28 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(unk_x28)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).unk_x30 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(unk_x30)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSave>())).unk_x38 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSave),
            "::",
            stringify!(unk_x38)
        )
    );
}
#[repr(C, packed)]
pub struct FsSaveDataInfo {
    pub saveID_unk: u64,
    /// < See \ref FsSaveDataSpaceId.
    pub SaveDataSpaceId: u8,
    /// < See \ref FsSaveDataType.
    pub SaveDataType: u8,
    pub pad: [u8; 6usize],
    /// < See userID for \ref FsSave.
    pub userID: u128,
    /// < See saveID for \ref FsSave.
    pub saveID: u64,
    /// < titleID for FsSaveDataType_SaveData.
    pub titleID: u64,
    /// < Raw saveimage size.
    pub size: u64,
    /// < Unknown. Usually zeros?
    pub unk_x38: [u8; 40usize],
}
#[test]
fn bindgen_test_layout_FsSaveDataInfo() {
    assert_eq!(
        ::core::mem::size_of::<FsSaveDataInfo>(),
        96usize,
        concat!("Size of: ", stringify!(FsSaveDataInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<FsSaveDataInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(FsSaveDataInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).saveID_unk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(saveID_unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).SaveDataSpaceId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(SaveDataSpaceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).SaveDataType as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(SaveDataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).pad as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).userID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(userID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).saveID as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(saveID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).titleID as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsSaveDataInfo>())).unk_x38 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FsSaveDataInfo),
            "::",
            stringify!(unk_x38)
        )
    );
}
#[repr(C, packed)]
pub struct FsTimeStampRaw {
    /// < POSIX timestamp.
    pub created: u64,
    /// < POSIX timestamp.
    pub modified: u64,
    /// < POSIX timestamp.
    pub accessed: u64,
    /// < 0x1 when the timestamps are set.
    pub is_valid: u8,
    pub padding: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_FsTimeStampRaw() {
    assert_eq!(
        ::core::mem::size_of::<FsTimeStampRaw>(),
        32usize,
        concat!("Size of: ", stringify!(FsTimeStampRaw))
    );
    assert_eq!(
        ::core::mem::align_of::<FsTimeStampRaw>(),
        1usize,
        concat!("Alignment of ", stringify!(FsTimeStampRaw))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).created as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).modified as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(modified)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).accessed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(accessed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).is_valid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsTimeStampRaw>())).padding as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(FsTimeStampRaw),
            "::",
            stringify!(padding)
        )
    );
}
pub const FsEntryType_ENTRYTYPE_DIR: FsEntryType = 0;
pub const FsEntryType_ENTRYTYPE_FILE: FsEntryType = 1;
pub type FsEntryType = u32;
/// < Open for reading.
pub const FsFileFlags_FS_OPEN_READ: FsFileFlags = 1;
/// < Open for writing.
pub const FsFileFlags_FS_OPEN_WRITE: FsFileFlags = 2;
/// < Append file.
pub const FsFileFlags_FS_OPEN_APPEND: FsFileFlags = 4;
pub type FsFileFlags = u32;
/// < Enable reading directory entries.
pub const FsDirectoryFlags_FS_DIROPEN_DIRECTORY: FsDirectoryFlags = 1;
/// < Enable reading file entries.
pub const FsDirectoryFlags_FS_DIROPEN_FILE: FsDirectoryFlags = 2;
/// For use with fsFsOpenDirectory.
pub type FsDirectoryFlags = u32;
pub const FsStorageId_FsStorageId_None: FsStorageId = 0;
pub const FsStorageId_FsStorageId_Host: FsStorageId = 1;
pub const FsStorageId_FsStorageId_GameCard: FsStorageId = 2;
pub const FsStorageId_FsStorageId_NandSystem: FsStorageId = 3;
pub const FsStorageId_FsStorageId_NandUser: FsStorageId = 4;
pub const FsStorageId_FsStorageId_SdCard: FsStorageId = 5;
pub type FsStorageId = u32;
pub const FsContentStorageId_FS_CONTENTSTORAGEID_NandSystem: FsContentStorageId = 0;
pub const FsContentStorageId_FS_CONTENTSTORAGEID_NandUser: FsContentStorageId = 1;
pub const FsContentStorageId_FS_CONTENTSTORAGEID_SdCard: FsContentStorageId = 2;
pub type FsContentStorageId = u32;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_NandSystem: FsSaveDataSpaceId = 0;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_NandUser: FsSaveDataSpaceId = 1;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_SdCard: FsSaveDataSpaceId = 2;
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_TemporaryStorage: FsSaveDataSpaceId = 3;
/// < Pseudo value for fsOpenSaveDataIterator().
pub const FsSaveDataSpaceId_FsSaveDataSpaceId_All: FsSaveDataSpaceId = -1;
pub type FsSaveDataSpaceId = i32;
pub const FsSaveDataType_FsSaveDataType_SystemSaveData: FsSaveDataType = 0;
pub const FsSaveDataType_FsSaveDataType_SaveData: FsSaveDataType = 1;
pub const FsSaveDataType_FsSaveDataType_BcatDeliveryCacheStorage: FsSaveDataType = 2;
pub const FsSaveDataType_FsSaveDataType_DeviceSaveData: FsSaveDataType = 3;
/// < [3.0.0+]
pub const FsSaveDataType_FsSaveDataType_TemporaryStorage: FsSaveDataType = 4;
/// < [3.0.0+]
pub const FsSaveDataType_FsSaveDataType_CacheStorage: FsSaveDataType = 5;
pub type FsSaveDataType = u32;
/// < Causes the cartridge to automatically start on bootup
pub const FsGameCardAttribute_FsGameCardAttribute_AutoBoot: FsGameCardAttribute = 1;
/// < Causes NS to throw an error on attempt to load the cartridge
pub const FsGameCardAttribute_FsGameCardAttribute_ForceError: FsGameCardAttribute = 2;
/// < Indicates that this gamecard is a repair tool.
pub const FsGameCardAttribute_FsGameCardAttribute_Repair: FsGameCardAttribute = 4;
pub type FsGameCardAttribute = u32;
#[repr(C)]
pub struct FsGameCardHandle {
    pub value: u32,
}
#[test]
fn bindgen_test_layout_FsGameCardHandle() {
    assert_eq!(
        ::core::mem::size_of::<FsGameCardHandle>(),
        4usize,
        concat!("Size of: ", stringify!(FsGameCardHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FsGameCardHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(FsGameCardHandle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FsGameCardHandle>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FsGameCardHandle),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn fsInitialize() -> Result;
}
extern "C" {
    pub fn fsExit();
}
extern "C" {
    pub fn fsGetServiceSession() -> *mut Service;
}
extern "C" {
    pub fn fsOpenBisStorage(out: *mut FsStorage, PartitionId: u32) -> Result;
}
extern "C" {
    pub fn fsOpenBisFileSystem(
        out: *mut FsFileSystem,
        PartitionId: u32,
        string: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsIsExFatSupported(out: *mut bool) -> Result;
}
extern "C" {
    /// Do not call this directly, see fs_dev.h.
    pub fn fsMountSdcard(out: *mut FsFileSystem) -> Result;
}
extern "C" {
    pub fn fsMountSaveData(out: *mut FsFileSystem, inval: u8, save: *mut FsSave) -> Result;
}
extern "C" {
    pub fn fsMountSystemSaveData(out: *mut FsFileSystem, inval: u8, save: *mut FsSave) -> Result;
}
extern "C" {
    pub fn fsOpenSaveDataIterator(out: *mut FsSaveDataIterator, SaveDataSpaceId: s32) -> Result;
}
extern "C" {
    pub fn fsOpenDataStorageByCurrentProcess(out: *mut FsStorage) -> Result;
}
extern "C" {
    pub fn fsOpenDeviceOperator(out: *mut FsDeviceOperator) -> Result;
}
extern "C" {
    pub fn fsOpenSdCardDetectionEventNotifier(out: *mut FsEventNotifier) -> Result;
}
extern "C" {
    /// Wrapper(s) for fsMountSaveData.
    /// See FsSave for titleID and userID.
    pub fn fsMount_SaveData(out: *mut FsFileSystem, titleID: u64, userID: u128) -> Result;
}
extern "C" {
    /// Wrapper for fsMountSystemSaveData.
    /// WARNING: You can brick when writing to SystemSaveData, if the data is corrupted etc.
    pub fn fsMount_SystemSaveData(out: *mut FsFileSystem, saveID: u64) -> Result;
}
pub const FsFileSystemType_FsFileSystemType_Logo: FsFileSystemType = 2;
pub const FsFileSystemType_FsFileSystemType_ContentControl: FsFileSystemType = 3;
pub const FsFileSystemType_FsFileSystemType_ContentManual: FsFileSystemType = 4;
pub const FsFileSystemType_FsFileSystemType_ContentMeta: FsFileSystemType = 5;
pub const FsFileSystemType_FsFileSystemType_ContentData: FsFileSystemType = 6;
pub const FsFileSystemType_FsFileSystemType_ApplicationPackage: FsFileSystemType = 7;
pub type FsFileSystemType = u32;
pub const FsFileSystemQueryType_FsFileSystemQueryType_SetArchiveBit: FsFileSystemQueryType = 0;
pub type FsFileSystemQueryType = u32;
extern "C" {
    /// Mount requested filesystem type from content file
    pub fn fsOpenFileSystem(
        out: *mut FsFileSystem,
        fsType: FsFileSystemType,
        contentPath: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    /// same as calling fsOpenFileSystemWithId with 0 as titleId
    pub fn fsOpenFileSystemWithId(
        out: *mut FsFileSystem,
        titleId: u64,
        fsType: FsFileSystemType,
        contentPath: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    /// works on all firmwares, titleId is ignored on 1.0.0
    pub fn fsFsCreateFile(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
        size: usize,
        flags: lang_items::c_int,
    ) -> Result;
}
extern "C" {
    pub fn fsFsDeleteFile(fs: *mut FsFileSystem, path: *const lang_items::c_char) -> Result;
}
extern "C" {
    pub fn fsFsCreateDirectory(fs: *mut FsFileSystem, path: *const lang_items::c_char) -> Result;
}
extern "C" {
    pub fn fsFsDeleteDirectory(fs: *mut FsFileSystem, path: *const lang_items::c_char) -> Result;
}
extern "C" {
    pub fn fsFsDeleteDirectoryRecursively(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsFsRenameFile(
        fs: *mut FsFileSystem,
        path0: *const lang_items::c_char,
        path1: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsFsRenameDirectory(
        fs: *mut FsFileSystem,
        path0: *const lang_items::c_char,
        path1: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn fsFsGetEntryType(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
        out: *mut FsEntryType,
    ) -> Result;
}
extern "C" {
    pub fn fsFsOpenFile(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
        flags: lang_items::c_int,
        out: *mut FsFile,
    ) -> Result;
}
extern "C" {
    pub fn fsFsOpenDirectory(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
        flags: lang_items::c_int,
        out: *mut FsDir,
    ) -> Result;
}
extern "C" {
    pub fn fsFsCommit(fs: *mut FsFileSystem) -> Result;
}
extern "C" {
    pub fn fsFsGetFreeSpace(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn fsFsGetTotalSpace(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn fsFsGetFileTimeStampRaw(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
        out: *mut FsTimeStampRaw,
    ) -> Result;
}
extern "C" {
    /// 3.0.0+
    pub fn fsFsCleanDirectoryRecursively(
        fs: *mut FsFileSystem,
        path: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    /// 3.0.0+
    pub fn fsFsQueryEntry(
        fs: *mut FsFileSystem,
        out: *mut lang_items::c_void,
        out_size: usize,
        in_: *const lang_items::c_void,
        in_size: usize,
        path: *const lang_items::c_char,
        query_type: FsFileSystemQueryType,
    ) -> Result;
}
extern "C" {
    /// 4.0.0+
    pub fn fsFsClose(fs: *mut FsFileSystem);
}
extern "C" {
    /// Uses \ref fsFsQueryEntry to set the archive bit on the specified absolute directory path.
    /// This will cause HOS to treat the directory as if it were a file containing the directory's concatenated contents.
    pub fn fsFsSetArchiveBit(fs: *mut FsFileSystem, path: *const lang_items::c_char) -> Result;
}
extern "C" {
    pub fn fsFileRead(
        f: *mut FsFile,
        off: u64,
        buf: *mut lang_items::c_void,
        len: usize,
        out: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn fsFileWrite(
        f: *mut FsFile,
        off: u64,
        buf: *const lang_items::c_void,
        len: usize,
    ) -> Result;
}
extern "C" {
    pub fn fsFileFlush(f: *mut FsFile) -> Result;
}
extern "C" {
    pub fn fsFileSetSize(f: *mut FsFile, sz: u64) -> Result;
}
extern "C" {
    pub fn fsFileGetSize(f: *mut FsFile, out: *mut u64) -> Result;
}
extern "C" {
    pub fn fsFileClose(f: *mut FsFile);
}
extern "C" {
    pub fn fsDirRead(
        d: *mut FsDir,
        inval: u64,
        total_entries: *mut usize,
        max_entries: usize,
        buf: *mut FsDirectoryEntry,
    ) -> Result;
}
extern "C" {
    pub fn fsDirGetEntryCount(d: *mut FsDir, count: *mut u64) -> Result;
}
extern "C" {
    pub fn fsDirClose(d: *mut FsDir);
}
extern "C" {
    pub fn fsStorageRead(
        s: *mut FsStorage,
        off: u64,
        buf: *mut lang_items::c_void,
        len: usize,
    ) -> Result;
}
extern "C" {
    pub fn fsStorageWrite(
        s: *mut FsStorage,
        off: u64,
        buf: *const lang_items::c_void,
        len: usize,
    ) -> Result;
}
extern "C" {
    pub fn fsStorageFlush(s: *mut FsStorage) -> Result;
}
extern "C" {
    pub fn fsStorageSetSize(s: *mut FsStorage, sz: u64) -> Result;
}
extern "C" {
    pub fn fsStorageGetSize(s: *mut FsStorage, out: *mut u64) -> Result;
}
extern "C" {
    pub fn fsStorageClose(s: *mut FsStorage);
}
extern "C" {
    /// Read FsSaveDataInfo data into the buf array.
    pub fn fsSaveDataIteratorRead(
        s: *mut FsSaveDataIterator,
        buf: *mut FsSaveDataInfo,
        max_entries: usize,
        total_entries: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn fsSaveDataIteratorClose(s: *mut FsSaveDataIterator);
}
extern "C" {
    pub fn fsEventNotifierGetEventHandle(e: *mut FsEventNotifier, out: *mut Handle) -> Result;
}
extern "C" {
    pub fn fsEventNotifierClose(e: *mut FsEventNotifier);
}
extern "C" {
    pub fn fsDeviceOperatorIsSdCardInserted(d: *mut FsDeviceOperator, out: *mut bool) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorIsGameCardInserted(d: *mut FsDeviceOperator, out: *mut bool) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorGetGameCardHandle(
        d: *mut FsDeviceOperator,
        out: *mut FsGameCardHandle,
    ) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorGetGameCardAttribute(
        d: *mut FsDeviceOperator,
        handle: *const FsGameCardHandle,
        out: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn fsDeviceOperatorClose(d: *mut FsDeviceOperator);
}
extern "C" {
    pub fn smManagerInitialize() -> Result;
}
extern "C" {
    pub fn smManagerExit();
}
extern "C" {
    pub fn smManagerRegisterProcess(
        pid: u64,
        acid_sac: *const lang_items::c_void,
        acid_sac_size: usize,
        aci0_sac: *const lang_items::c_void,
        aci0_sac_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn smManagerUnregisterProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn fsldrInitialize() -> Result;
}
extern "C" {
    pub fn fsldrExit();
}
extern "C" {
    pub fn fsldrOpenCodeFileSystem(
        tid: u64,
        path: *const lang_items::c_char,
        out: *mut FsFileSystem,
    ) -> Result;
}
extern "C" {
    pub fn fsldrIsArchivedProgram(pid: u64, out: *mut bool) -> Result;
}
extern "C" {
    pub fn fsldrSetCurrentProcess() -> Result;
}
extern "C" {
    pub fn fsprInitialize() -> Result;
}
extern "C" {
    pub fn fsprExit();
}
extern "C" {
    pub fn fsprRegisterProgram(
        pid: u64,
        titleID: u64,
        storageID: FsStorageId,
        fs_access_header: *const lang_items::c_void,
        fah_size: usize,
        fs_access_control: *const lang_items::c_void,
        fac_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn fsprUnregisterProgram(pid: u64) -> Result;
}
extern "C" {
    pub fn fsprSetCurrentProcess() -> Result;
}
extern "C" {
    pub fn fsprSetEnabledProgramVerification(enabled: bool) -> Result;
}
#[repr(C)]
pub struct AccountProfile {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_AccountProfile() {
    assert_eq!(
        ::core::mem::size_of::<AccountProfile>(),
        12usize,
        concat!("Size of: ", stringify!(AccountProfile))
    );
    assert_eq!(
        ::core::mem::align_of::<AccountProfile>(),
        4usize,
        concat!("Alignment of ", stringify!(AccountProfile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountProfile>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfile),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C, packed)]
pub struct AccountUserData {
    pub unk_x0: u32,
    /// < Icon ID. 0 = Mii, the rest are character icon IDs.
    pub iconID: u32,
    /// < Profile icon background color ID
    pub iconBackgroundColorID: u8,
    pub unk_x9: [u8; 7usize],
    /// < Some ID related to the Mii? All zeros when a character icon is used.
    pub miiID: [u8; 16usize],
    /// < Usually zeros?
    pub unk_x20: [u8; 96usize],
}
#[test]
fn bindgen_test_layout_AccountUserData() {
    assert_eq!(
        ::core::mem::size_of::<AccountUserData>(),
        128usize,
        concat!("Size of: ", stringify!(AccountUserData))
    );
    assert_eq!(
        ::core::mem::align_of::<AccountUserData>(),
        1usize,
        concat!("Alignment of ", stringify!(AccountUserData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).iconID as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(iconID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AccountUserData>())).iconBackgroundColorID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(iconBackgroundColorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).unk_x9 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(unk_x9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).miiID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(miiID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountUserData>())).unk_x20 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountUserData),
            "::",
            stringify!(unk_x20)
        )
    );
}
#[repr(C, packed)]
pub struct AccountProfileBase {
    pub userID: u128,
    /// < POSIX UTC timestamp, for the last account edit.
    pub lastEditTimestamp: u64,
    /// < UTF-8 Username.
    pub username: [lang_items::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_AccountProfileBase() {
    assert_eq!(
        ::core::mem::size_of::<AccountProfileBase>(),
        56usize,
        concat!("Size of: ", stringify!(AccountProfileBase))
    );
    assert_eq!(
        ::core::mem::align_of::<AccountProfileBase>(),
        1usize,
        concat!("Alignment of ", stringify!(AccountProfileBase))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountProfileBase>())).userID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfileBase),
            "::",
            stringify!(userID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AccountProfileBase>())).lastEditTimestamp as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfileBase),
            "::",
            stringify!(lastEditTimestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AccountProfileBase>())).username as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AccountProfileBase),
            "::",
            stringify!(username)
        )
    );
}
extern "C" {
    pub fn accountInitialize() -> Result;
}
extern "C" {
    pub fn accountExit();
}
extern "C" {
    pub fn accountGetService() -> *mut Service;
}
extern "C" {
    /// Get the total number of user profiles
    pub fn accountGetUserCount(user_count: *mut s32) -> Result;
}
extern "C" {
    /// @brief Get a list of all user IDs. The returned list will never be larger than ACC_USER_LIST_SIZE.
    /// @param userIDs Pointer to array of user IDs.
    /// @param max_userIDs Maximum number of user IDs to return.
    /// @param actual_total The actual total number of user IDs found.
    pub fn accountListAllUsers(
        userIDs: *mut u128,
        max_userIDs: usize,
        actual_total: *mut usize,
    ) -> Result;
}
extern "C" {
    /// Get the userID for the currently active user. The output userID is only valid when the output account_selected==1, otherwise no user is currently selected.
    /// An user is only selected when the user-account selection applet was used to select an user at least once before.
    pub fn accountGetActiveUser(userID: *mut u128, account_selected: *mut bool) -> Result;
}
extern "C" {
    /// Get an AccountProfile for the specified userID.
    pub fn accountGetProfile(out: *mut AccountProfile, userID: u128) -> Result;
}
extern "C" {
    /// Get \ref AccountUserData and \ref AccountProfileBase for the specified profile, userdata is optional (can be NULL).
    pub fn accountProfileGet(
        profile: *mut AccountProfile,
        userdata: *mut AccountUserData,
        profilebase: *mut AccountProfileBase,
    ) -> Result;
}
extern "C" {
    /// Get the icon image size.
    pub fn accountProfileGetImageSize(
        profile: *mut AccountProfile,
        image_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// Load the JPEG profile icon, valid for both Miis and character icons. The output image_size is the same as the one from \ref accountProfileGetImageSize.
    pub fn accountProfileLoadImage(
        profile: *mut AccountProfile,
        buf: *mut lang_items::c_void,
        len: usize,
        image_size: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn accountProfileClose(profile: *mut AccountProfile);
}
extern "C" {
    /// Gets the userID which was selected by the profile-selector applet (if any), prior to launching the currently running Application title. This can only be used once under the current process, under an Application title.
    pub fn accountGetPreselectedUser(userID: *mut u128) -> Result;
}
extern "C" {
    /// These are used internally by applet.
    pub fn apmInitialize() -> Result;
}
extern "C" {
    pub fn apmExit();
}
extern "C" {
    pub fn apmSetPerformanceConfiguration(
        PerformanceMode: u32,
        PerformanceConfiguration: u32,
    ) -> Result;
}
extern "C" {
    pub fn apmGetPerformanceConfiguration(
        PerformanceMode: u32,
        PerformanceConfiguration: *mut u32,
    ) -> Result;
}
pub const AppletType_AppletType_None: AppletType = -2;
pub const AppletType_AppletType_Default: AppletType = -1;
pub const AppletType_AppletType_Application: AppletType = 0;
pub const AppletType_AppletType_SystemApplet: AppletType = 1;
pub const AppletType_AppletType_LibraryApplet: AppletType = 2;
pub const AppletType_AppletType_OverlayApplet: AppletType = 3;
pub const AppletType_AppletType_SystemApplication: AppletType = 4;
pub type AppletType = i32;
pub const AppletOperationMode_AppletOperationMode_Handheld: AppletOperationMode = 0;
pub const AppletOperationMode_AppletOperationMode_Docked: AppletOperationMode = 1;
pub type AppletOperationMode = u32;
/// < FocusState changed.
pub const AppletHookType_AppletHookType_OnFocusState: AppletHookType = 0;
/// < OperationMode changed.
pub const AppletHookType_AppletHookType_OnOperationMode: AppletHookType = 1;
/// < PerformanceMode changed.
pub const AppletHookType_AppletHookType_OnPerformanceMode: AppletHookType = 2;
/// < Exit requested.
pub const AppletHookType_AppletHookType_OnExitRequest: AppletHookType = 3;
/// < Number of applet hook types.
pub const AppletHookType_AppletHookType_Max: AppletHookType = 4;
/// applet hook types.
pub type AppletHookType = u32;
/// < Applet is focused.
pub const AppletFocusState_AppletFocusState_Focused: AppletFocusState = 1;
/// < Out of focus - LibraryApplet open.
pub const AppletFocusState_AppletFocusState_NotFocusedLibraryApplet: AppletFocusState = 2;
/// < Out of focus - HOME menu open / console is sleeping.
pub const AppletFocusState_AppletFocusState_NotFocusedHomeSleep: AppletFocusState = 3;
pub type AppletFocusState = u32;
/// < Suspend only when HOME menu is open / console is sleeping (default).
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_SuspendHomeSleep:
    AppletFocusHandlingMode = 0;
/// < Don't suspend when out of focus.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_NoSuspend: AppletFocusHandlingMode = 1;
/// < Suspend only when HOME menu is open / console is sleeping but still receive OnFocusState hook.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_SuspendHomeSleepNotify:
    AppletFocusHandlingMode = 2;
/// < Always suspend when out of focus, regardless of the reason.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_AlwaysSuspend: AppletFocusHandlingMode =
    3;
/// < Number of focus handling modes.
pub const AppletFocusHandlingMode_AppletFocusHandlingMode_Max: AppletFocusHandlingMode = 4;
pub type AppletFocusHandlingMode = u32;
/// < Application-specific LaunchParameter
pub const AppletLaunchParameterKind_AppletLaunchParameterKind_Application:
    AppletLaunchParameterKind = 1;
/// < account PreselectedUser
pub const AppletLaunchParameterKind_AppletLaunchParameterKind_PreselectedUser:
    AppletLaunchParameterKind = 2;
/// < Unknown if used by anything?
pub const AppletLaunchParameterKind_AppletLaunchParameterKind_Unknown: AppletLaunchParameterKind =
    3;
pub type AppletLaunchParameterKind = u32;
/// < 010000000000100C "overlayDisp"
pub const AppletId_AppletId_overlayDisp: AppletId = 2;
/// < 0100000000001000 "qlaunch" (SystemAppletMenu)
pub const AppletId_AppletId_qlaunch: AppletId = 3;
/// < 0100000000001012 "starter"
pub const AppletId_AppletId_starter: AppletId = 4;
/// < 0100000000001001 "auth"
pub const AppletId_AppletId_auth: AppletId = 10;
/// < 0100000000001002 "cabinet"
pub const AppletId_AppletId_cabinet: AppletId = 11;
/// < 0100000000001003 "controller"
pub const AppletId_AppletId_controller: AppletId = 12;
/// < 0100000000001004 "dataErase"
pub const AppletId_AppletId_dataErase: AppletId = 13;
/// < 0100000000001005 "error"
pub const AppletId_AppletId_error: AppletId = 14;
/// < 0100000000001006 "netConnect"
pub const AppletId_AppletId_netConnect: AppletId = 15;
/// < 0100000000001007 "playerSelect"
pub const AppletId_AppletId_playerSelect: AppletId = 16;
/// < 0100000000001008 "swkbd"
pub const AppletId_AppletId_swkbd: AppletId = 17;
/// < 0100000000001009 "miiEdit"
pub const AppletId_AppletId_miiEdit: AppletId = 18;
/// < 010000000000100A "LibAppletWeb" WebApplet applet
pub const AppletId_AppletId_web: AppletId = 19;
/// < 010000000000100B "LibAppletShop" ShopN applet
pub const AppletId_AppletId_shop: AppletId = 20;
/// < 010000000000100D "photoViewer"
pub const AppletId_AppletId_photoViewer: AppletId = 21;
/// < 010000000000100E "set" (This title is currently not present on retail devices.)
pub const AppletId_AppletId_set: AppletId = 22;
/// < 010000000000100F "LibAppletOff" Offline web-applet
pub const AppletId_AppletId_offlineWeb: AppletId = 23;
/// < 0100000000001010 "LibAppletLns" Whitelisted web-applet
pub const AppletId_AppletId_loginShare: AppletId = 24;
/// < 0100000000001011 "LibAppletAuth" WifiWebAuth applet
pub const AppletId_AppletId_wifiWebAuth: AppletId = 25;
/// < 0100000000001013 "myPage"
pub const AppletId_AppletId_myPage: AppletId = 26;
pub type AppletId = u32;
pub const LibAppletMode_LibAppletMode_AllForeground: LibAppletMode = 0;
pub const LibAppletMode_LibAppletMode_Background: LibAppletMode = 1;
pub const LibAppletMode_LibAppletMode_Unknown2: LibAppletMode = 2;
pub const LibAppletMode_LibAppletMode_Unknown3: LibAppletMode = 3;
/// LibraryAppletMode
pub type LibAppletMode = u32;
pub const LibAppletExitReason_LibAppletExitReason_Normal: LibAppletExitReason = 0;
pub const LibAppletExitReason_LibAppletExitReason_Canceled: LibAppletExitReason = 1;
pub const LibAppletExitReason_LibAppletExitReason_Abnormal: LibAppletExitReason = 2;
pub const LibAppletExitReason_LibAppletExitReason_Unexpected: LibAppletExitReason = 10;
/// LibraryAppletExitReason
pub type LibAppletExitReason = u32;
/// applet hook function.
pub type AppletHookFn = ::core::option::Option<
    unsafe extern "C" fn(hook: AppletHookType, param: *mut lang_items::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppletHookCookie {
    /// < Next cookie.
    pub next: *mut AppletHookCookie,
    /// < Hook callback.
    pub callback: AppletHookFn,
    /// < Callback parameter.
    pub param: *mut lang_items::c_void,
}
#[test]
fn bindgen_test_layout_AppletHookCookie() {
    assert_eq!(
        ::core::mem::size_of::<AppletHookCookie>(),
        24usize,
        concat!("Size of: ", stringify!(AppletHookCookie))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletHookCookie>(),
        8usize,
        concat!("Alignment of ", stringify!(AppletHookCookie))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHookCookie>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHookCookie),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHookCookie>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHookCookie),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHookCookie>())).param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHookCookie),
            "::",
            stringify!(param)
        )
    );
}
/// applet IStorage
#[repr(C)]
pub struct AppletStorage {
    pub s: Service,
    pub tmem: TransferMemory,
}
#[test]
fn bindgen_test_layout_AppletStorage() {
    assert_eq!(
        ::core::mem::size_of::<AppletStorage>(),
        56usize,
        concat!("Size of: ", stringify!(AppletStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(AppletStorage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletStorage>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletStorage),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletStorage>())).tmem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletStorage),
            "::",
            stringify!(tmem)
        )
    );
}
/// LibraryApplet state.
#[repr(C)]
pub struct AppletHolder {
    /// < ILibraryAppletAccessor
    pub s: Service,
    /// < Output from GetAppletStateChangedEvent, autoclear=false.
    pub StateChangedEvent: Event,
    /// < See ref \ref LibAppletMode.
    pub mode: LibAppletMode,
    /// < Output from GetIndirectLayerConsumerHandle on 2.0.0+.
    pub layer_handle: u64,
    /// < When set, indicates that the LibraryApplet title is creating itself.
    pub creating_self: bool,
    /// < Set by \ref appletHolderJoin using the output from cmd GetResult, see \ref LibAppletExitReason.
    pub exitreason: LibAppletExitReason,
}
#[test]
fn bindgen_test_layout_AppletHolder() {
    assert_eq!(
        ::core::mem::size_of::<AppletHolder>(),
        48usize,
        concat!("Size of: ", stringify!(AppletHolder))
    );
    assert_eq!(
        ::core::mem::align_of::<AppletHolder>(),
        8usize,
        concat!("Alignment of ", stringify!(AppletHolder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).StateChangedEvent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(StateChangedEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).layer_handle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(layer_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).creating_self as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(creating_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AppletHolder>())).exitreason as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AppletHolder),
            "::",
            stringify!(exitreason)
        )
    );
}
extern "C" {
    pub fn appletInitialize() -> Result;
}
extern "C" {
    pub fn appletExit();
}
extern "C" {
    pub fn appletGetAppletResourceUserId(out: *mut u64) -> Result;
}
extern "C" {
    pub fn appletGetAppletType() -> AppletType;
}
extern "C" {
    pub fn appletNotifyRunning(out: *mut u8);
}
extern "C" {
    pub fn appletCreateManagedDisplayLayer(out: *mut u64) -> Result;
}
extern "C" {
    /// @brief Pops a LaunchParameter AppletStorage, the storage will be removed from sysmodule state during this.
    /// @param s Output storage.
    /// @param kind See \ref AppletLaunchParameterKind.
    /// @note Can only be used in Applications.
    /// @note See also acc.h \ref accountGetPreselectedUser (wrapper for appletPopLaunchParameter etc).
    pub fn appletPopLaunchParameter(
        s: *mut AppletStorage,
        kind: AppletLaunchParameterKind,
    ) -> Result;
}
extern "C" {
    pub fn appletGetDesiredLanguage(LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Only available with AppletType_*Application.
    pub fn appletSetTerminateResult(res: Result) -> Result;
}
extern "C" {
    /// Gets whether video recording is supported.
    /// See also \ref appletInitializeGamePlayRecording.
    pub fn appletIsGamePlayRecordingSupported(flag: *mut bool) -> Result;
}
extern "C" {
    /// Disable/enable video recording. Only available after \ref appletInitializeGamePlayRecording was used.
    /// See also \ref appletInitializeGamePlayRecording.
    pub fn appletSetGamePlayRecordingState(state: bool) -> Result;
}
extern "C" {
    /// Initializes video recording. This allocates a 0x6000000-byte buffer for the TransferMemory, cleanup is handled automatically during app exit in \ref appletExit.
    /// Only available with AppletType_Application on 3.0.0+, hence errors from this can be ignored.
    /// Video recording is only fully available system-side with 4.0.0+.
    /// Only usable when running under a title which supports video recording.
    pub fn appletInitializeGamePlayRecording() -> Result;
}
extern "C" {
    /// @brief Blocks the usage of the home button.
    /// @param val Unknown nanoseconds. Value 0 can be used.
    /// @note Can only be used in regularapps.
    pub fn appletBeginBlockingHomeButton(val: s64) -> Result;
}
extern "C" {
    pub fn appletEndBlockingHomeButton() -> Result;
}
extern "C" {
    /// @brief Delay exiting until \ref appletUnlockExit is called, with a 15 second timeout once exit is requested.
    /// @note When exit is requested \ref appletMainLoop will return false, hence any main-loop using appletMainLoop will exit. This allows the app to handle cleanup post-main-loop instead of being force-terminated.
    /// @note If the above timeout occurs after exit was requested where \ref appletUnlockExit was not called, the process will be forced-terminated.
    /// @note \ref appletUnlockExit must be used before main() returns.
    pub fn appletLockExit() -> Result;
}
extern "C" {
    pub fn appletUnlockExit() -> Result;
}
extern "C" {
    /// @brief Controls whether screenshot-capture is allowed.
    /// @param val 0 = disable, 1 = enable.
    pub fn appletSetScreenShotPermission(val: s32) -> Result;
}
extern "C" {
    pub fn appletSetScreenShotImageOrientation(val: s32) -> Result;
}
extern "C" {
    /// @brief Pushes a storage to the general channel. Used for sending requests to qlaunch.
    /// @note  This is not usable under an Application, however it is usable under a LibraryApplet.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param s Storage object.
    pub fn appletPushToGeneralChannel(s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Creates a LibraryApplet.
    /// @param h AppletHolder object.
    /// @param id See \ref AppletId.
    /// @param mode See \ref LibAppletMode.
    pub fn appletCreateLibraryApplet(
        h: *mut AppletHolder,
        id: AppletId,
        mode: LibAppletMode,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a LibraryApplet. This is for when a LibraryApplet title creates itself.
    /// @note  Identical to \ref appletCreateLibraryApplet except this sets the creating_self flag to true.
    /// @param h AppletHolder object.
    /// @param id See \ref AppletId.
    /// @param mode See \ref LibAppletMode.
    pub fn appletCreateLibraryAppletSelf(
        h: *mut AppletHolder,
        id: AppletId,
        mode: LibAppletMode,
    ) -> Result;
}
extern "C" {
    /// Closes an AppletHolder object.
    pub fn appletHolderClose(h: *mut AppletHolder);
}
extern "C" {
    /// @brief Gets the IndirectLayerConsumerHandle loaded during \ref appletCreateLibraryApplet, on 2.0.0+.
    /// @note  Only available when \ref LibAppletMode is \ref LibAppletMode_Unknown3.
    /// @param h AppletHolder object.
    /// @param out Output IndirectLayerConsumerHandle.
    pub fn appletHolderGetIndirectLayerConsumerHandle(
        h: *mut AppletHolder,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    /// @brief Starts the LibraryApplet.
    /// @param h AppletHolder object.
    pub fn appletHolderStart(h: *mut AppletHolder) -> Result;
}
extern "C" {
    /// @brief Waits for the LibraryApplet to exit.
    /// @param h AppletHolder object.
    pub fn appletHolderJoin(h: *mut AppletHolder);
}
extern "C" {
    /// @brief Gets the \ref LibAppletExitReason set by \ref appletHolderJoin.
    /// @param h AppletHolder object.
    pub fn appletHolderGetExitReason(h: *mut AppletHolder) -> LibAppletExitReason;
}
extern "C" {
    /// @brief Pushes a storage for LibraryApplet input.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPushInData(h: *mut AppletHolder, s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Pops a storage from LibraryApplet output.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPopOutData(h: *mut AppletHolder, s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Pushes a storage for LibraryApplet Extra storage input.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPushExtraStorage(h: *mut AppletHolder, s: *mut AppletStorage) -> Result;
}
extern "C" {
    /// @brief Pushes a storage for LibraryApplet Interactive input.
    /// @note  This uses \ref appletStorageClose automatically.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPushInteractiveInData(h: *mut AppletHolder, s: *mut AppletStorage)
        -> Result;
}
extern "C" {
    /// @brief Pops a storage from LibraryApplet Interactive output.
    /// @param h AppletHolder object.
    /// @param s Storage object.
    pub fn appletHolderPopInteractiveOutData(h: *mut AppletHolder, s: *mut AppletStorage)
        -> Result;
}
extern "C" {
    /// @brief Creates a storage.
    /// @param s Storage object.
    /// @param size Size of storage.
    pub fn appletCreateStorage(s: *mut AppletStorage, size: s64) -> Result;
}
extern "C" {
    /// @brief Creates a TransferMemory storage.
    /// @param s Storage object.
    /// @param size Size of storage.
    /// @param writable Controls whether writing to the storage is allowed with \ref appletStorageWrite.
    pub fn appletCreateTransferMemoryStorage(
        s: *mut AppletStorage,
        size: s64,
        writable: bool,
    ) -> Result;
}
extern "C" {
    /// @brief Creates a HandleStorage. Only available on 2.0.0+.
    /// @param s Storage object.
    /// @param inval Arbitrary input value.
    /// @param handle Arbitrary input handle.
    pub fn appletCreateHandleStorage(s: *mut AppletStorage, inval: s64, handle: Handle) -> Result;
}
extern "C" {
    /// @brief Creates a HandleStorage using TransferMemory. Wrapper for \ref appletCreateHandleStorage.
    /// @param s Storage object.
    /// @param size Size of storage.
    pub fn appletCreateHandleStorageTmem(s: *mut AppletStorage, size: s64) -> Result;
}
extern "C" {
    /// Closes the storage object. TransferMemory closing is seperate, see \ref appletStorageCloseTmem.
    /// Other applet functions which push an input storage will automatically call this.
    pub fn appletStorageClose(s: *mut AppletStorage);
}
extern "C" {
    /// Closes the TransferMemory in the storage object. For TransferMemory storage created by the current process, this must be called after the LibraryApplet finishes using it (if sent to one).
    pub fn appletStorageCloseTmem(s: *mut AppletStorage);
}
extern "C" {
    /// Gets the size of the storage. This is not usable with HandleStorage, use \ref appletStorageGetHandle or \ref appletStorageMap instead for that.
    pub fn appletStorageGetSize(s: *mut AppletStorage, size: *mut s64) -> Result;
}
extern "C" {
    /// @brief Writes to a storage. offset(+size) must be within the actual storage size.
    /// @note  This is not usable with HandleStorage.
    /// @param s Storage object.
    /// @param offset Offset in storage.
    /// @param buffer Input data.
    /// @param size Data size.
    pub fn appletStorageWrite(
        s: *mut AppletStorage,
        offset: s64,
        buffer: *const lang_items::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Reads from a storage. offset(+size) must be within the actual storage size.
    /// @note  This is not usable with HandleStorage.
    /// @param s Storage object.
    /// @param offset Offset in storage.
    /// @param buffer Input data.
    /// @param size Data size.
    pub fn appletStorageRead(
        s: *mut AppletStorage,
        offset: s64,
        buffer: *mut lang_items::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Gets data for a HandleStorage originally from \ref appletCreateHandleStorage input.
    /// @note  Only available on 2.0.0+.
    /// @param out Output value.
    /// @param handle Output handle.
    pub fn appletStorageGetHandle(
        s: *mut AppletStorage,
        out: *mut s64,
        handle: *mut Handle,
    ) -> Result;
}
extern "C" {
    /// @brief Maps TransferMemory for a HandleStorage. Wrapper for \ref appletCreateHandleStorage.
    /// @note  The TransferMemory can be unmapped with \ref appletStorageCloseTmem.
    /// @note  Do not use this if the AppletStorage already contains initialized TransferMemory state.
    /// @param s Storage object.
    /// @param addr Output mapped address (optional).
    /// @param size Output size (optional).
    pub fn appletStorageMap(
        s: *mut AppletStorage,
        addr: *mut *mut lang_items::c_void,
        size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Processes the current applet status. Generally used within a main loop.
    /// @return Whether the application should continue running.
    pub fn appletMainLoop() -> bool;
}
extern "C" {
    /// @brief Sets up an applet status hook.
    /// @param cookie Hook cookie to use.
    /// @param callback Function to call when applet's status changes.
    /// @param param User-defined parameter to pass to the callback.
    pub fn appletHook(
        cookie: *mut AppletHookCookie,
        callback: AppletHookFn,
        param: *mut lang_items::c_void,
    );
}
extern "C" {
    /// @brief Removes an applet status hook.
    /// @param cookie Hook cookie to remove.
    pub fn appletUnhook(cookie: *mut AppletHookCookie);
}
extern "C" {
    /// These return state which is updated by appletMainLoop() when notifications are received.
    pub fn appletGetOperationMode() -> u8;
}
extern "C" {
    pub fn appletGetPerformanceMode() -> u32;
}
extern "C" {
    pub fn appletGetFocusState() -> AppletFocusState;
}
extern "C" {
    pub fn appletSetFocusHandlingMode(mode: AppletFocusHandlingMode) -> Result;
}
pub const PcmFormat_PcmFormat_Invalid: PcmFormat = 0;
pub const PcmFormat_PcmFormat_Int8: PcmFormat = 1;
pub const PcmFormat_PcmFormat_Int16: PcmFormat = 2;
pub const PcmFormat_PcmFormat_Int24: PcmFormat = 3;
pub const PcmFormat_PcmFormat_Int32: PcmFormat = 4;
pub const PcmFormat_PcmFormat_Float: PcmFormat = 5;
pub const PcmFormat_PcmFormat_Adpcm: PcmFormat = 6;
pub type PcmFormat = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AudioDeviceName {
    pub name: [lang_items::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_AudioDeviceName() {
    assert_eq!(
        ::core::mem::size_of::<AudioDeviceName>(),
        256usize,
        concat!("Size of: ", stringify!(AudioDeviceName))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDeviceName>(),
        1usize,
        concat!("Alignment of ", stringify!(AudioDeviceName))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDeviceName>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDeviceName),
            "::",
            stringify!(name)
        )
    );
}
pub const AudioInState_AudioInState_Started: AudioInState = 0;
pub const AudioInState_AudioInState_Stopped: AudioInState = 1;
pub type AudioInState = u32;
#[repr(C)]
pub struct AudioInBuffer {
    /// < Next buffer. (Unused)
    pub next: *mut AudioInBuffer,
    /// < Sample buffer (aligned to 0x1000 bytes).
    pub buffer: *mut lang_items::c_void,
    /// < Sample buffer size (aligned to 0x1000 bytes).
    pub buffer_size: u64,
    /// < Size of data inside the buffer.
    pub data_size: u64,
    /// < Offset of data inside the buffer. (Unused?)
    pub data_offset: u64,
}
#[test]
fn bindgen_test_layout_AudioInBuffer() {
    assert_eq!(
        ::core::mem::size_of::<AudioInBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(AudioInBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioInBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioInBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).data_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioInBuffer>())).data_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioInBuffer),
            "::",
            stringify!(data_offset)
        )
    );
}
extern "C" {
    pub fn audinInitialize() -> Result;
}
extern "C" {
    pub fn audinExit();
}
extern "C" {
    pub fn audinListAudioIns(
        DeviceNames: *mut lang_items::c_char,
        DeviceNamesCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audinOpenAudioIn(
        DeviceNameIn: *const lang_items::c_char,
        DeviceNameOut: *mut lang_items::c_char,
        SampleRateIn: u32,
        ChannelCountIn: u32,
        SampleRateOut: *mut u32,
        ChannelCountOut: *mut u32,
        Format: *mut PcmFormat,
        State: *mut AudioInState,
    ) -> Result;
}
extern "C" {
    pub fn audinGetAudioInState(State: *mut AudioInState) -> Result;
}
extern "C" {
    pub fn audinStartAudioIn() -> Result;
}
extern "C" {
    pub fn audinStopAudioIn() -> Result;
}
extern "C" {
    pub fn audinAppendAudioInBuffer(Buffer: *mut AudioInBuffer) -> Result;
}
extern "C" {
    pub fn audinGetReleasedAudioInBuffer(
        Buffer: *mut *mut AudioInBuffer,
        ReleasedBuffersCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audinContainsAudioInBuffer(
        Buffer: *mut AudioInBuffer,
        ContainsBuffer: *mut bool,
    ) -> Result;
}
extern "C" {
    /// @brief Submits an audio sample data buffer for capturing and waits for it to finish capturing.
    /// @brief Uses \ref audinAppendAudioInBuffer and \ref audinWaitCaptureFinish internally.
    /// @param source AudioInBuffer containing the buffer to hold the captured sample data.
    /// @param released AudioInBuffer to receive the captured buffer after being released.
    pub fn audinCaptureBuffer(
        source: *mut AudioInBuffer,
        released: *mut *mut AudioInBuffer,
    ) -> Result;
}
extern "C" {
    /// @brief Waits for audio capture to finish.
    /// @param released AudioInBuffer to receive the first captured buffer after being released.
    /// @param released_count Pointer to receive the number of captured buffers.
    /// @param timeout Timeout value, use U64_MAX to wait until all finished.
    pub fn audinWaitCaptureFinish(
        released: *mut *mut AudioInBuffer,
        released_count: *mut u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// These return the state associated with the currently active audio input device.
    pub fn audinGetSampleRate() -> u32;
}
extern "C" {
    pub fn audinGetChannelCount() -> u32;
}
extern "C" {
    pub fn audinGetPcmFormat() -> PcmFormat;
}
extern "C" {
    pub fn audinGetDeviceState() -> AudioInState;
}
pub const AudioOutState_AudioOutState_Started: AudioOutState = 0;
pub const AudioOutState_AudioOutState_Stopped: AudioOutState = 1;
pub type AudioOutState = u32;
#[repr(C)]
pub struct AudioOutBuffer {
    /// < Next buffer. (Unused)
    pub next: *mut AudioOutBuffer,
    /// < Sample buffer (aligned to 0x1000 bytes).
    pub buffer: *mut lang_items::c_void,
    /// < Sample buffer size (aligned to 0x1000 bytes).
    pub buffer_size: u64,
    /// < Size of data inside the buffer.
    pub data_size: u64,
    /// < Offset of data inside the buffer. (Unused?)
    pub data_offset: u64,
}
#[test]
fn bindgen_test_layout_AudioOutBuffer() {
    assert_eq!(
        ::core::mem::size_of::<AudioOutBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(AudioOutBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioOutBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioOutBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).data_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioOutBuffer>())).data_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioOutBuffer),
            "::",
            stringify!(data_offset)
        )
    );
}
extern "C" {
    pub fn audoutInitialize() -> Result;
}
extern "C" {
    pub fn audoutExit();
}
extern "C" {
    pub fn audoutListAudioOuts(
        DeviceNames: *mut lang_items::c_char,
        DeviceNamesCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audoutOpenAudioOut(
        DeviceNameIn: *const lang_items::c_char,
        DeviceNameOut: *mut lang_items::c_char,
        SampleRateIn: u32,
        ChannelCountIn: u32,
        SampleRateOut: *mut u32,
        ChannelCountOut: *mut u32,
        Format: *mut PcmFormat,
        State: *mut AudioOutState,
    ) -> Result;
}
extern "C" {
    pub fn audoutGetAudioOutState(State: *mut AudioOutState) -> Result;
}
extern "C" {
    pub fn audoutStartAudioOut() -> Result;
}
extern "C" {
    pub fn audoutStopAudioOut() -> Result;
}
extern "C" {
    pub fn audoutAppendAudioOutBuffer(Buffer: *mut AudioOutBuffer) -> Result;
}
extern "C" {
    pub fn audoutGetReleasedAudioOutBuffer(
        Buffer: *mut *mut AudioOutBuffer,
        ReleasedBuffersCount: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn audoutContainsAudioOutBuffer(
        Buffer: *mut AudioOutBuffer,
        ContainsBuffer: *mut bool,
    ) -> Result;
}
extern "C" {
    /// @brief Submits an audio sample data buffer for playing and waits for it to finish playing.
    /// @brief Uses \ref audoutAppendAudioOutBuffer and \ref audoutWaitPlayFinish internally.
    /// @param source AudioOutBuffer containing the source sample data to be played.
    /// @param released AudioOutBuffer to receive the played buffer after being released.
    pub fn audoutPlayBuffer(
        source: *mut AudioOutBuffer,
        released: *mut *mut AudioOutBuffer,
    ) -> Result;
}
extern "C" {
    /// @brief Waits for audio playback to finish.
    /// @param released AudioOutBuffer to receive the first played buffer after being released.
    /// @param released_count Pointer to receive the number of played buffers.
    /// @param timeout Timeout value, use U64_MAX to wait until all finished.
    pub fn audoutWaitPlayFinish(
        released: *mut *mut AudioOutBuffer,
        released_count: *mut u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    /// These return the state associated with the currently active audio output device.
    pub fn audoutGetSampleRate() -> u32;
}
extern "C" {
    pub fn audoutGetChannelCount() -> u32;
}
extern "C" {
    pub fn audoutGetPcmFormat() -> PcmFormat;
}
extern "C" {
    pub fn audoutGetDeviceState() -> AudioOutState;
}
pub const AudioRendererOutputRate_AudioRendererOutputRate_32kHz: AudioRendererOutputRate = 0;
pub const AudioRendererOutputRate_AudioRendererOutputRate_48kHz: AudioRendererOutputRate = 1;
pub type AudioRendererOutputRate = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioRendererConfig {
    pub output_rate: AudioRendererOutputRate,
    pub num_voices: lang_items::c_int,
    pub num_effects: lang_items::c_int,
    pub num_sinks: lang_items::c_int,
    pub num_mix_objs: lang_items::c_int,
    pub num_mix_buffers: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_AudioRendererConfig() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererConfig>(),
        24usize,
        concat!("Size of: ", stringify!(AudioRendererConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).output_rate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(output_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererConfig>())).num_voices as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_voices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).num_effects as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_effects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererConfig>())).num_sinks as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_sinks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).num_mix_objs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_mix_objs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererConfig>())).num_mix_buffers as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererConfig),
            "::",
            stringify!(num_mix_buffers)
        )
    );
}
#[repr(C)]
pub struct AudioRendererUpdateDataHeader {
    pub revision: u32,
    pub behavior_sz: u32,
    pub mempools_sz: u32,
    pub voices_sz: u32,
    pub channels_sz: u32,
    pub effects_sz: u32,
    pub mixes_sz: u32,
    pub sinks_sz: u32,
    pub perfmgr_sz: u32,
    pub _padding: [u32; 6usize],
    pub total_sz: u32,
}
#[test]
fn bindgen_test_layout_AudioRendererUpdateDataHeader() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererUpdateDataHeader>(),
        64usize,
        concat!("Size of: ", stringify!(AudioRendererUpdateDataHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererUpdateDataHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererUpdateDataHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).behavior_sz as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(behavior_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).mempools_sz as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(mempools_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).voices_sz as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(voices_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).channels_sz as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(channels_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).effects_sz as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(effects_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).mixes_sz as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(mixes_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).sinks_sz as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(sinks_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).perfmgr_sz as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(perfmgr_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>()))._padding as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererUpdateDataHeader>())).total_sz as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererUpdateDataHeader),
            "::",
            stringify!(total_sz)
        )
    );
}
#[repr(C)]
pub struct AudioRendererBehaviorInfoIn {
    pub revision: u32,
    pub _padding1: u32,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_AudioRendererBehaviorInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererBehaviorInfoIn>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererBehaviorInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererBehaviorInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererBehaviorInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoIn>())).revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoIn),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoIn>()))._padding1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoIn>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoIn),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
pub struct AudioRendererBehaviorInfoOut {
    pub unknown: [u64; 20usize],
    pub _padding1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_AudioRendererBehaviorInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererBehaviorInfoOut>(),
        176usize,
        concat!("Size of: ", stringify!(AudioRendererBehaviorInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererBehaviorInfoOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererBehaviorInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoOut>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoOut),
            "::",
            stringify!(unknown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBehaviorInfoOut>()))._padding1 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBehaviorInfoOut),
            "::",
            stringify!(_padding1)
        )
    );
}
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Invalid: AudioRendererMemPoolState =
    0;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_New: AudioRendererMemPoolState = 1;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_RequestDetach:
    AudioRendererMemPoolState = 2;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Detached: AudioRendererMemPoolState =
    3;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_RequestAttach:
    AudioRendererMemPoolState = 4;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Attached: AudioRendererMemPoolState =
    5;
pub const AudioRendererMemPoolState_AudioRendererMemPoolState_Released: AudioRendererMemPoolState =
    6;
pub type AudioRendererMemPoolState = u32;
#[repr(C)]
pub struct AudioRendererMemPoolInfoIn {
    pub address: *const lang_items::c_void,
    pub size: u64,
    pub state: AudioRendererMemPoolState,
    pub _padding2: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererMemPoolInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererMemPoolInfoIn>(),
        32usize,
        concat!("Size of: ", stringify!(AudioRendererMemPoolInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererMemPoolInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererMemPoolInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>())).address as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>())).state as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoIn>()))._padding2 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
}
#[repr(C)]
pub struct AudioRendererMemPoolInfoOut {
    pub new_state: AudioRendererMemPoolState,
    pub _padding2: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererMemPoolInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererMemPoolInfoOut>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererMemPoolInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererMemPoolInfoOut>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererMemPoolInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoOut>())).new_state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoOut),
            "::",
            stringify!(new_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMemPoolInfoOut>()))._padding2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMemPoolInfoOut),
            "::",
            stringify!(_padding2)
        )
    );
}
#[repr(C)]
pub struct AudioRendererChannelInfoIn {
    pub id: u32,
    pub mix: [f32; 24usize],
    pub is_used: bool,
    pub _padding1: [u8; 11usize],
}
#[test]
fn bindgen_test_layout_AudioRendererChannelInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererChannelInfoIn>(),
        112usize,
        concat!("Size of: ", stringify!(AudioRendererChannelInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererChannelInfoIn>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererChannelInfoIn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererChannelInfoIn>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererChannelInfoIn>())).mix as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(mix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererChannelInfoIn>())).is_used as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererChannelInfoIn>()))._padding1 as *const _ as usize
        },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererChannelInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererBiquadFilter {
    pub enable: bool,
    pub _padding: u8,
    pub numerator: [s16; 3usize],
    pub denominator: [s16; 2usize],
}
#[test]
fn bindgen_test_layout_AudioRendererBiquadFilter() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererBiquadFilter>(),
        12usize,
        concat!("Size of: ", stringify!(AudioRendererBiquadFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererBiquadFilter>(),
        2usize,
        concat!("Alignment of ", stringify!(AudioRendererBiquadFilter))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>())).enable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>()))._padding as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>())).numerator as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererBiquadFilter>())).denominator as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererBiquadFilter),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
pub struct AudioRendererAdpcmParameters {
    pub coefficients: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_AudioRendererAdpcmParameters() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererAdpcmParameters>(),
        32usize,
        concat!("Size of: ", stringify!(AudioRendererAdpcmParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererAdpcmParameters>(),
        2usize,
        concat!("Alignment of ", stringify!(AudioRendererAdpcmParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmParameters>())).coefficients as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmParameters),
            "::",
            stringify!(coefficients)
        )
    );
}
#[repr(C)]
pub struct AudioRendererAdpcmContext {
    pub index: u16,
    pub history0: s16,
    pub history1: s16,
}
#[test]
fn bindgen_test_layout_AudioRendererAdpcmContext() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererAdpcmContext>(),
        6usize,
        concat!("Size of: ", stringify!(AudioRendererAdpcmContext))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererAdpcmContext>(),
        2usize,
        concat!("Alignment of ", stringify!(AudioRendererAdpcmContext))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmContext>())).index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmContext),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmContext>())).history0 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmContext),
            "::",
            stringify!(history0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererAdpcmContext>())).history1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererAdpcmContext),
            "::",
            stringify!(history1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererWaveBuf {
    pub address: *const lang_items::c_void,
    pub size: u64,
    pub start_sample_offset: s32,
    pub end_sample_offset: s32,
    pub is_looping: bool,
    pub end_of_stream: bool,
    pub sent_to_server: bool,
    pub _padding1: [u8; 5usize],
    pub context_addr: *const lang_items::c_void,
    pub context_sz: u64,
    pub _padding2: u64,
}
#[test]
fn bindgen_test_layout_AudioRendererWaveBuf() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererWaveBuf>(),
        56usize,
        concat!("Size of: ", stringify!(AudioRendererWaveBuf))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererWaveBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererWaveBuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).start_sample_offset as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(start_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).end_sample_offset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(end_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).is_looping as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(is_looping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).end_of_stream as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(end_of_stream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).sent_to_server as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(sent_to_server)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>()))._padding1 as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).context_addr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(context_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererWaveBuf>())).context_sz as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(context_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererWaveBuf>()))._padding2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererWaveBuf),
            "::",
            stringify!(_padding2)
        )
    );
}
pub const AudioRendererVoicePlayState_AudioRendererVoicePlayState_Started:
    AudioRendererVoicePlayState = 0;
pub const AudioRendererVoicePlayState_AudioRendererVoicePlayState_Stopped:
    AudioRendererVoicePlayState = 1;
pub const AudioRendererVoicePlayState_AudioRendererVoicePlayState_Paused:
    AudioRendererVoicePlayState = 2;
pub type AudioRendererVoicePlayState = u32;
#[repr(C)]
pub struct AudioRendererVoiceInfoIn {
    pub id: u32,
    pub node_id: u32,
    pub is_new: bool,
    pub is_used: bool,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub sample_rate: u32,
    pub priority: u32,
    pub sorting_order: u32,
    pub channel_count: u32,
    pub pitch: f32,
    pub volume: f32,
    pub biquads: [AudioRendererBiquadFilter; 2usize],
    pub wavebuf_count: u32,
    pub wavebuf_head: s16,
    pub _padding1: u16,
    pub _padding2: u32,
    pub extra_params_ptr: *const lang_items::c_void,
    pub extra_params_sz: u64,
    pub dest_mix_id: u32,
    pub dest_splitter_id: u32,
    pub wavebufs: [AudioRendererWaveBuf; 4usize],
    pub channel_ids: [u32; 6usize],
    pub _padding3: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_AudioRendererVoiceInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererVoiceInfoIn>(),
        368usize,
        concat!("Size of: ", stringify!(AudioRendererVoiceInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererVoiceInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererVoiceInfoIn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).node_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).is_new as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(is_new)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).is_used as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).sample_rate as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).priority as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).sorting_order as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(sorting_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).channel_count as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).pitch as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).volume as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).biquads as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(biquads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).wavebuf_count as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(wavebuf_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).wavebuf_head as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(wavebuf_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>()))._padding1 as *const _ as usize
        },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>()))._padding2 as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).extra_params_ptr as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(extra_params_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).extra_params_sz as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(extra_params_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).dest_mix_id as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(dest_mix_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).dest_splitter_id as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(dest_splitter_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).wavebufs as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(wavebufs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>())).channel_ids as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(channel_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoIn>()))._padding3 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoIn),
            "::",
            stringify!(_padding3)
        )
    );
}
impl AudioRendererVoiceInfoIn {
    #[inline]
    pub fn state(&self) -> AudioRendererVoicePlayState {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: AudioRendererVoicePlayState) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sample_format(&self) -> PcmFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sample_format(&mut self, val: PcmFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: AudioRendererVoicePlayState,
        sample_format: PcmFormat,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sample_format: u32 = unsafe { ::core::mem::transmute(sample_format) };
            sample_format as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct AudioRendererVoiceInfoOut {
    pub played_sample_count: u64,
    pub num_wavebufs_consumed: u32,
    pub voice_drops_count: u32,
}
#[test]
fn bindgen_test_layout_AudioRendererVoiceInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererVoiceInfoOut>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererVoiceInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererVoiceInfoOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererVoiceInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoOut>())).played_sample_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoOut),
            "::",
            stringify!(played_sample_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoOut>())).num_wavebufs_consumed as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoOut),
            "::",
            stringify!(num_wavebufs_consumed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererVoiceInfoOut>())).voice_drops_count as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererVoiceInfoOut),
            "::",
            stringify!(voice_drops_count)
        )
    );
}
#[repr(C)]
pub struct AudioRendererMixInfoIn {
    pub volume: f32,
    pub sample_rate: u32,
    pub buffer_count: u32,
    pub is_used: bool,
    pub _padding1: [u8; 3usize],
    pub mix_id: u32,
    pub _padding2: u32,
    pub node_id: u32,
    pub _padding3: [u32; 2usize],
    pub mix: [[f32; 24usize]; 24usize],
    pub dest_mix_id: u32,
    pub dest_splitter_id: u32,
    pub _padding4: u32,
}
#[test]
fn bindgen_test_layout_AudioRendererMixInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererMixInfoIn>(),
        2352usize,
        concat!("Size of: ", stringify!(AudioRendererMixInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererMixInfoIn>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererMixInfoIn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).volume as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).sample_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).buffer_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(buffer_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).is_used as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).mix_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(mix_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding2 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).node_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding3 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).mix as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(mix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).dest_mix_id as *const _ as usize
        },
        2340usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(dest_mix_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>())).dest_splitter_id as *const _
                as usize
        },
        2344usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(dest_splitter_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererMixInfoIn>()))._padding4 as *const _ as usize
        },
        2348usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererMixInfoIn),
            "::",
            stringify!(_padding4)
        )
    );
}
#[repr(C)]
pub struct AudioRendererDownMixParameters {
    pub coefficients: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_AudioRendererDownMixParameters() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererDownMixParameters>(),
        16usize,
        concat!("Size of: ", stringify!(AudioRendererDownMixParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererDownMixParameters>(),
        1usize,
        concat!("Alignment of ", stringify!(AudioRendererDownMixParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDownMixParameters>())).coefficients as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDownMixParameters),
            "::",
            stringify!(coefficients)
        )
    );
}
pub const AudioRendererSinkType_AudioRendererSinkType_Invalid: AudioRendererSinkType = 0;
pub const AudioRendererSinkType_AudioRendererSinkType_Device: AudioRendererSinkType = 1;
pub const AudioRendererSinkType_AudioRendererSinkType_CircularBuffer: AudioRendererSinkType = 2;
pub type AudioRendererSinkType = u32;
#[repr(C)]
pub struct AudioRendererDeviceSinkInfoIn {
    pub name: [lang_items::c_char; 255usize],
    pub _padding1: u8,
    pub input_count: u32,
    pub inputs: [u8; 6usize],
    pub _padding2: u8,
    pub downmix_params_enabled: bool,
    pub downmix_params: AudioRendererDownMixParameters,
}
#[test]
fn bindgen_test_layout_AudioRendererDeviceSinkInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererDeviceSinkInfoIn>(),
        284usize,
        concat!("Size of: ", stringify!(AudioRendererDeviceSinkInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererDeviceSinkInfoIn>(),
        4usize,
        concat!("Alignment of ", stringify!(AudioRendererDeviceSinkInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>()))._padding1 as *const _
                as usize
        },
        255usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).input_count as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(input_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).inputs as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>()))._padding2 as *const _
                as usize
        },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).downmix_params_enabled
                as *const _ as usize
        },
        267usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(downmix_params_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererDeviceSinkInfoIn>())).downmix_params as *const _
                as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererDeviceSinkInfoIn),
            "::",
            stringify!(downmix_params)
        )
    );
}
#[repr(C)]
pub struct AudioRendererCircularBufferSinkInfoIn {
    pub buffer_ptr: *mut lang_items::c_void,
    pub buffer_sz: u32,
    pub input_count: u32,
    pub sample_count: u32,
    pub last_read_offset: u32,
    pub sample_format: PcmFormat,
    pub inputs: [u8; 6usize],
    pub _padding2: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_AudioRendererCircularBufferSinkInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererCircularBufferSinkInfoIn>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererCircularBufferSinkInfoIn>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererCircularBufferSinkInfoIn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).buffer_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(buffer_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).buffer_sz as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(buffer_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).input_count
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(input_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).sample_count
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).last_read_offset
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(last_read_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).sample_format
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(sample_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>())).inputs as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererCircularBufferSinkInfoIn>()))._padding2 as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererCircularBufferSinkInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
}
#[repr(C)]
pub struct AudioRendererSinkInfoIn {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub is_used: bool,
    pub _padding1: [u8; 2usize],
    pub node_id: u32,
    pub _padding2: [u64; 3usize],
    pub __bindgen_anon_1: AudioRendererSinkInfoIn__bindgen_ty_1,
}
#[repr(C)]
pub struct AudioRendererSinkInfoIn__bindgen_ty_1 {
    pub device_sink: __BindgenUnionField<AudioRendererDeviceSinkInfoIn>,
    pub circular_buffer_sink: __BindgenUnionField<AudioRendererCircularBufferSinkInfoIn>,
    pub bindgen_union_field: [u64; 36usize],
}
#[test]
fn bindgen_test_layout_AudioRendererSinkInfoIn__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererSinkInfoIn__bindgen_ty_1>(),
        288usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererSinkInfoIn__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn__bindgen_ty_1>())).device_sink
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1),
            "::",
            stringify!(device_sink)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn__bindgen_ty_1>())).circular_buffer_sink
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn__bindgen_ty_1),
            "::",
            stringify!(circular_buffer_sink)
        )
    );
}
#[test]
fn bindgen_test_layout_AudioRendererSinkInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererSinkInfoIn>(),
        320usize,
        concat!("Size of: ", stringify!(AudioRendererSinkInfoIn))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererSinkInfoIn>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererSinkInfoIn))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>())).is_used as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(is_used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>()))._padding1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>())).node_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoIn>()))._padding2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoIn),
            "::",
            stringify!(_padding2)
        )
    );
}
impl AudioRendererSinkInfoIn {
    #[inline]
    pub fn type_(&self) -> AudioRendererSinkType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: AudioRendererSinkType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: AudioRendererSinkType) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct AudioRendererSinkInfoOut {
    pub last_written_offset: u32,
    pub unk1: u32,
    pub unk2: u64,
    pub _padding1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_AudioRendererSinkInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererSinkInfoOut>(),
        32usize,
        concat!("Size of: ", stringify!(AudioRendererSinkInfoOut))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererSinkInfoOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioRendererSinkInfoOut))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoOut>())).last_written_offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(last_written_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererSinkInfoOut>())).unk1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(unk1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioRendererSinkInfoOut>())).unk2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(unk2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererSinkInfoOut>()))._padding1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererSinkInfoOut),
            "::",
            stringify!(_padding1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererPerformanceBufferInfoIn {
    pub detail_target: u32,
    pub _padding1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererPerformanceBufferInfoIn() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererPerformanceBufferInfoIn>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererPerformanceBufferInfoIn)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererPerformanceBufferInfoIn>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererPerformanceBufferInfoIn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoIn>())).detail_target
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoIn),
            "::",
            stringify!(detail_target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoIn>()))._padding1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoIn),
            "::",
            stringify!(_padding1)
        )
    );
}
#[repr(C)]
pub struct AudioRendererPerformanceBufferInfoOut {
    pub written_sz: u32,
    pub _padding1: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_AudioRendererPerformanceBufferInfoOut() {
    assert_eq!(
        ::core::mem::size_of::<AudioRendererPerformanceBufferInfoOut>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(AudioRendererPerformanceBufferInfoOut)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<AudioRendererPerformanceBufferInfoOut>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(AudioRendererPerformanceBufferInfoOut)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoOut>())).written_sz
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoOut),
            "::",
            stringify!(written_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioRendererPerformanceBufferInfoOut>()))._padding1 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioRendererPerformanceBufferInfoOut),
            "::",
            stringify!(_padding1)
        )
    );
}
extern "C" {
    pub fn audrenInitialize(config: *const AudioRendererConfig) -> Result;
}
extern "C" {
    pub fn audrenExit();
}
extern "C" {
    pub fn audrenWaitFrame();
}
extern "C" {
    pub fn audrenGetState(out_state: *mut u32) -> Result;
}
extern "C" {
    pub fn audrenRequestUpdateAudioRenderer(
        in_param_buf: *const lang_items::c_void,
        in_param_buf_size: usize,
        out_param_buf: *mut lang_items::c_void,
        out_param_buf_size: usize,
        perf_buf: *mut lang_items::c_void,
        perf_buf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn audrenStartAudioRenderer() -> Result;
}
extern "C" {
    pub fn audrenStopAudioRenderer() -> Result;
}
extern "C" {
    pub fn audrenSetAudioRendererRenderingTimeLimit(percent: lang_items::c_int) -> Result;
}
extern "C" {
    pub fn auddevInitialize() -> Result;
}
extern "C" {
    pub fn auddevExit();
}
extern "C" {
    pub fn auddevListAudioDeviceName(
        DeviceNames: *mut AudioDeviceName,
        max_names: s32,
        total_names: *mut s32,
    ) -> Result;
}
extern "C" {
    pub fn auddevSetAudioDeviceOutputVolume(
        DeviceName: *const AudioDeviceName,
        volume: f32,
    ) -> Result;
}
extern "C" {
    pub fn auddevGetAudioDeviceOutputVolume(
        DeviceName: *const AudioDeviceName,
        volume: *mut f32,
    ) -> Result;
}
#[repr(C)]
pub struct HwopusDecoder {
    pub s: Service,
    pub tmem: TransferMemory,
    pub multistream: bool,
}
#[test]
fn bindgen_test_layout_HwopusDecoder() {
    assert_eq!(
        ::core::mem::size_of::<HwopusDecoder>(),
        64usize,
        concat!("Size of: ", stringify!(HwopusDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<HwopusDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(HwopusDecoder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusDecoder>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusDecoder),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusDecoder>())).tmem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusDecoder),
            "::",
            stringify!(tmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusDecoder>())).multistream as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusDecoder),
            "::",
            stringify!(multistream)
        )
    );
}
/// This structure is the start of opusin for \ref hwopusDecodeInterleaved, with the actual opus packet following this.
/// These fields are big-endian.
#[repr(C)]
pub struct HwopusHeader {
    /// < Size of the packet following this header.
    pub size: u32,
    /// < Unknown, can be left at zero.
    pub unk: u32,
}
#[test]
fn bindgen_test_layout_HwopusHeader() {
    assert_eq!(
        ::core::mem::size_of::<HwopusHeader>(),
        8usize,
        concat!("Size of: ", stringify!(HwopusHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HwopusHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(HwopusHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusHeader>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusHeader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HwopusHeader>())).unk as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusHeader),
            "::",
            stringify!(unk)
        )
    );
}
/// Used internally.
#[repr(C)]
pub struct HwopusMultistreamState {
    pub SampleRate: s32,
    pub ChannelCount: s32,
    pub TotalStreamCount: s32,
    pub StereoStreamCount: s32,
    pub channel_mapping: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_HwopusMultistreamState() {
    assert_eq!(
        ::core::mem::size_of::<HwopusMultistreamState>(),
        272usize,
        concat!("Size of: ", stringify!(HwopusMultistreamState))
    );
    assert_eq!(
        ::core::mem::align_of::<HwopusMultistreamState>(),
        4usize,
        concat!("Alignment of ", stringify!(HwopusMultistreamState))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).SampleRate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(SampleRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).ChannelCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(ChannelCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).TotalStreamCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(TotalStreamCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).StereoStreamCount as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(StereoStreamCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HwopusMultistreamState>())).channel_mapping as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HwopusMultistreamState),
            "::",
            stringify!(channel_mapping)
        )
    );
}
extern "C" {
    pub fn hwopusDecoderInitialize(
        decoder: *mut HwopusDecoder,
        SampleRate: s32,
        ChannelCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn hwopusDecoderExit(decoder: *mut HwopusDecoder);
}
extern "C" {
    /// Only available on 3.0.0+.
    /// See libopus multistream docs.
    pub fn hwopusDecoderMultistreamInitialize(
        decoder: *mut HwopusDecoder,
        SampleRate: s32,
        ChannelCount: s32,
        TotalStreamCount: s32,
        StereoStreamCount: s32,
        channel_mapping: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn hwopusDecodeInterleaved(
        decoder: *mut HwopusDecoder,
        DecodedDataSize: *mut s32,
        DecodedSampleCount: *mut s32,
        opusin: *const lang_items::c_void,
        opusin_size: usize,
        pcmbuf: *mut s16,
        pcmbuf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn csrngInitialize() -> Result;
}
extern "C" {
    pub fn csrngExit();
}
extern "C" {
    pub fn csrngGetRandomBytes(out: *mut lang_items::c_void, out_size: usize) -> Result;
}
extern "C" {
    pub fn lblInitialize() -> Result;
}
extern "C" {
    pub fn lblExit();
}
extern "C" {
    pub fn lblSwitchBacklightOn(fade_time: u64) -> Result;
}
extern "C" {
    pub fn lblSwitchBacklightOff(fade_time: u64) -> Result;
}
pub const I2cDevice_I2cDevice_AudioCodec: I2cDevice = 4;
pub type I2cDevice = u32;
#[repr(C)]
pub struct I2cSession {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_I2cSession() {
    assert_eq!(
        ::core::mem::size_of::<I2cSession>(),
        12usize,
        concat!("Size of: ", stringify!(I2cSession))
    );
    assert_eq!(
        ::core::mem::align_of::<I2cSession>(),
        4usize,
        concat!("Alignment of ", stringify!(I2cSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<I2cSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2cSession),
            "::",
            stringify!(s)
        )
    );
}
pub const I2cTransactionOption_I2cTransactionOption_Start: I2cTransactionOption = 1;
pub const I2cTransactionOption_I2cTransactionOption_Stop: I2cTransactionOption = 2;
pub const I2cTransactionOption_I2cTransactionOption_All: I2cTransactionOption = 3;
pub type I2cTransactionOption = u32;
extern "C" {
    pub fn i2cInitialize() -> Result;
}
extern "C" {
    pub fn i2cExit();
}
extern "C" {
    pub fn i2cOpenSession(out: *mut I2cSession, dev: I2cDevice) -> Result;
}
extern "C" {
    pub fn i2csessionSendAuto(
        s: *mut I2cSession,
        buf: *mut lang_items::c_void,
        size: usize,
        option: I2cTransactionOption,
    ) -> Result;
}
extern "C" {
    pub fn i2csessionClose(s: *mut I2cSession);
}
pub const GpioPadName_GpioPadName_AudioCodec: GpioPadName = 1;
pub const GpioPadName_GpioPadName_ButtonVolUp: GpioPadName = 25;
pub const GpioPadName_GpioPadName_ButtonVolDown: GpioPadName = 26;
pub type GpioPadName = u32;
#[repr(C)]
pub struct GpioPadSession {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_GpioPadSession() {
    assert_eq!(
        ::core::mem::size_of::<GpioPadSession>(),
        12usize,
        concat!("Size of: ", stringify!(GpioPadSession))
    );
    assert_eq!(
        ::core::mem::align_of::<GpioPadSession>(),
        4usize,
        concat!("Alignment of ", stringify!(GpioPadSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GpioPadSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPadSession),
            "::",
            stringify!(s)
        )
    );
}
pub const GpioDirection_GpioDirection_Input: GpioDirection = 0;
pub const GpioDirection_GpioDirection_Output: GpioDirection = 1;
pub type GpioDirection = u32;
pub const GpioValue_GpioValue_Low: GpioValue = 0;
pub const GpioValue_GpioValue_High: GpioValue = 1;
pub type GpioValue = u32;
extern "C" {
    pub fn gpioInitialize() -> Result;
}
extern "C" {
    pub fn gpioExit();
}
extern "C" {
    pub fn gpioOpenSession(out: *mut GpioPadSession, name: GpioPadName) -> Result;
}
extern "C" {
    pub fn gpioPadSetDirection(p: *mut GpioPadSession, dir: GpioDirection) -> Result;
}
extern "C" {
    pub fn gpioPadGetDirection(p: *mut GpioPadSession, out: *mut GpioDirection) -> Result;
}
extern "C" {
    pub fn gpioPadSetValue(p: *mut GpioPadSession, val: GpioValue) -> Result;
}
extern "C" {
    pub fn gpioPadGetValue(p: *mut GpioPadSession, out: *mut GpioValue) -> Result;
}
extern "C" {
    pub fn gpioPadClose(p: *mut GpioPadSession);
}
pub const BpcSleepButtonState_BpcSleepButtonState_Held: BpcSleepButtonState = 0;
pub const BpcSleepButtonState_BpcSleepButtonState_Released: BpcSleepButtonState = 1;
pub type BpcSleepButtonState = u32;
extern "C" {
    pub fn bpcInitialize() -> Result;
}
extern "C" {
    pub fn bpcExit();
}
extern "C" {
    pub fn bpcShutdownSystem() -> Result;
}
extern "C" {
    pub fn bpcRebootSystem() -> Result;
}
extern "C" {
    pub fn bpcGetSleepButtonState(out: *mut BpcSleepButtonState) -> Result;
}
pub const PcvModule_PcvModule_Cpu: PcvModule = 0;
pub const PcvModule_PcvModule_Gpu: PcvModule = 1;
pub const PcvModule_PcvModule_Emc: PcvModule = 56;
pub type PcvModule = u32;
extern "C" {
    pub fn pcvInitialize() -> Result;
}
extern "C" {
    pub fn pcvExit();
}
extern "C" {
    pub fn pcvGetClockRate(module: PcvModule, out_hz: *mut u32) -> Result;
}
extern "C" {
    pub fn pcvSetClockRate(module: PcvModule, hz: u32) -> Result;
}
extern "C" {
    pub fn pcvSetVoltageEnabled(state: bool, voltage: u32) -> Result;
}
extern "C" {
    pub fn pcvGetVoltageEnabled(isEnabled: *mut bool, voltage: u32) -> Result;
}
/// < No charger
pub const ChargerType_ChargerType_None: ChargerType = 0;
/// < Official charger or dock
pub const ChargerType_ChargerType_Charger: ChargerType = 1;
/// < Other USB-C chargers
pub const ChargerType_ChargerType_Usb: ChargerType = 2;
pub type ChargerType = u32;
/// < Power state should transition to shutdown
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_NeedsShutdown: PsmBatteryVoltageState = 0;
/// < Power state should transition to sleep
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_NeedsSleep: PsmBatteryVoltageState = 1;
/// < Performance boost modes cannot be entered
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_NoPerformanceBoost: PsmBatteryVoltageState =
    2;
/// < Everything is normal
pub const PsmBatteryVoltageState_PsmBatteryVoltageState_Normal: PsmBatteryVoltageState = 3;
pub type PsmBatteryVoltageState = u32;
extern "C" {
    pub fn psmInitialize() -> Result;
}
extern "C" {
    pub fn psmExit();
}
extern "C" {
    pub fn psmGetBatteryChargePercentage(out: *mut u32) -> Result;
}
extern "C" {
    pub fn psmGetChargerType(out: *mut ChargerType) -> Result;
}
extern "C" {
    pub fn psmGetBatteryVoltageState(out: *mut PsmBatteryVoltageState) -> Result;
}
extern "C" {
    /// @brief Wrapper func which handles event setup.
    /// @note Uses the actual BindStateChangeEvent cmd internally.
    /// @note The event is not signalled on BatteryChargePercentage changes.
    /// @param[in] ChargerType Passed to SetChargerTypeChangeEventEnabled.
    /// @param[in] PowerSupply Passed to SetPowerSupplyChangeEventEnabled.
    /// @param[in] BatteryVoltage Passed to SetBatteryVoltageStateChangeEventEnabled.
    pub fn psmBindStateChangeEvent(
        ChargerType: bool,
        PowerSupply: bool,
        BatteryVoltage: bool,
    ) -> Result;
}
extern "C" {
    /// Wait on the Event setup by psmBindStateChangeEvent.
    pub fn psmWaitStateChangeEvent(timeout: u64) -> Result;
}
extern "C" {
    /// Cleanup version of psmBindStateChangeEvent. Called automatically by \ref psmExit and \ref psmBindStateChangeEvent, if already initialized.
    pub fn psmUnbindStateChangeEvent() -> Result;
}
extern "C" {
    pub fn spsmInitialize() -> Result;
}
extern "C" {
    pub fn spsmExit();
}
extern "C" {
    pub fn spsmShutdown(reboot: bool) -> Result;
}
extern "C" {
    pub fn spsmPutErrorState() -> Result;
}
pub const FatalType_FatalType_ErrorReportAndErrorScreen: FatalType = 0;
pub const FatalType_FatalType_ErrorReport: FatalType = 1;
/// < Only available with 3.0.0+. If specified, FatalType_ErrorReportAndErrorScreen will be used instead on pre-3.0.0.
pub const FatalType_FatalType_ErrorScreen: FatalType = 2;
/// Type of thrown fatal error.
pub type FatalType = u32;
/// Struct for fatal Cpu context, 64-bit.
#[repr(C)]
pub struct FatalAarch64Context {
    pub __bindgen_anon_1: FatalAarch64Context__bindgen_ty_1,
    pub pstate: u64,
    pub afsr0: u64,
    pub afsr1: u64,
    pub esr: u64,
    pub far: u64,
    pub stack_trace: [u64; 32usize],
    /// < Address of first NSO loaded (generally, process entrypoint).
    pub start_address: u64,
    /// < Bitmask, bit i indicates GPR i has a value.
    pub register_set_flags: u64,
    pub stack_trace_size: u32,
}
#[repr(C)]
pub struct FatalAarch64Context__bindgen_ty_1 {
    pub x: __BindgenUnionField<[u64; 32usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 33usize],
}
#[repr(C)]
pub struct FatalAarch64Context__bindgen_ty_1__bindgen_ty_1 {
    pub _x: [u64; 29usize],
    pub fp: u64,
    pub lr: u64,
    pub sp: u64,
    pub pc: u64,
}
#[test]
fn bindgen_test_layout_FatalAarch64Context__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>()))._x
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).fp
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).lr
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).sp
                as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1__bindgen_ty_1>())).pc
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pc)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch64Context__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch64Context__bindgen_ty_1>(),
        264usize,
        concat!("Size of: ", stringify!(FatalAarch64Context__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch64Context__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch64Context__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch64Context() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch64Context>(),
        584usize,
        concat!("Size of: ", stringify!(FatalAarch64Context))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch64Context>(),
        8usize,
        concat!("Alignment of ", stringify!(FatalAarch64Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).pstate as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).afsr0 as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).afsr1 as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).esr as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch64Context>())).far as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(far)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).stack_trace as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(stack_trace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).start_address as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(start_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).register_set_flags as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(register_set_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch64Context>())).stack_trace_size as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch64Context),
            "::",
            stringify!(stack_trace_size)
        )
    );
}
/// Struct for fatal Cpu context, 32-bit.
#[repr(C)]
pub struct FatalAarch32Context {
    pub __bindgen_anon_1: FatalAarch32Context__bindgen_ty_1,
    pub pstate: u32,
    pub afsr0: u32,
    pub afsr1: u32,
    pub esr: u32,
    pub far: u32,
    pub stack_trace: [u32; 32usize],
    pub stack_trace_size: u32,
    /// < Address of first NSO loaded (generally, process entrypoint).
    pub start_address: u32,
    /// < Bitmask, bit i indicates GPR i has a value.
    pub register_set_flags: u32,
}
#[repr(C)]
pub struct FatalAarch32Context__bindgen_ty_1 {
    pub r: __BindgenUnionField<[u32; 16usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u32; 16usize],
}
#[repr(C)]
pub struct FatalAarch32Context__bindgen_ty_1__bindgen_ty_1 {
    pub _r: [u32; 11usize],
    pub fp: u32,
    pub ip: u32,
    pub sp: u32,
    pub lr: u32,
    pub pc: u32,
}
#[test]
fn bindgen_test_layout_FatalAarch32Context__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>()))._r
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).fp
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).ip
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).sp
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).lr
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1__bindgen_ty_1>())).pc
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pc)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch32Context__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch32Context__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(FatalAarch32Context__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch32Context__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(FatalAarch32Context__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context__bindgen_ty_1>())).r as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context__bindgen_ty_1),
            "::",
            stringify!(r)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalAarch32Context() {
    assert_eq!(
        ::core::mem::size_of::<FatalAarch32Context>(),
        224usize,
        concat!("Size of: ", stringify!(FatalAarch32Context))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalAarch32Context>(),
        4usize,
        concat!("Alignment of ", stringify!(FatalAarch32Context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).pstate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).afsr0 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(afsr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).afsr1 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(afsr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).esr as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalAarch32Context>())).far as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(far)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).stack_trace as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(stack_trace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).stack_trace_size as *const _ as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(stack_trace_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).start_address as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(start_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalAarch32Context>())).register_set_flags as *const _ as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalAarch32Context),
            "::",
            stringify!(register_set_flags)
        )
    );
}
#[repr(C)]
pub struct FatalContext {
    pub __bindgen_anon_1: FatalContext__bindgen_ty_1,
    pub is_aarch32: bool,
    pub type_: u32,
}
#[repr(C)]
pub struct FatalContext__bindgen_ty_1 {
    pub aarch64_ctx: __BindgenUnionField<FatalAarch64Context>,
    pub aarch32_ctx: __BindgenUnionField<FatalAarch32Context>,
    pub bindgen_union_field: [u64; 73usize],
}
#[test]
fn bindgen_test_layout_FatalContext__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FatalContext__bindgen_ty_1>(),
        584usize,
        concat!("Size of: ", stringify!(FatalContext__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalContext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(FatalContext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalContext__bindgen_ty_1>())).aarch64_ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext__bindgen_ty_1),
            "::",
            stringify!(aarch64_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<FatalContext__bindgen_ty_1>())).aarch32_ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext__bindgen_ty_1),
            "::",
            stringify!(aarch32_ctx)
        )
    );
}
#[test]
fn bindgen_test_layout_FatalContext() {
    assert_eq!(
        ::core::mem::size_of::<FatalContext>(),
        592usize,
        concat!("Size of: ", stringify!(FatalContext))
    );
    assert_eq!(
        ::core::mem::align_of::<FatalContext>(),
        8usize,
        concat!("Alignment of ", stringify!(FatalContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalContext>())).is_aarch32 as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext),
            "::",
            stringify!(is_aarch32)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FatalContext>())).type_ as *const _ as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(FatalContext),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    /// @brief Triggers a system fatal error.
    /// @param err[in] Result code to throw.
    /// @note This function does not return.
    /// @note This uses \ref fatalWithType with \ref FatalType_ErrorScreen internally.
    pub fn fatalSimple(err: Result);
}
extern "C" {
    /// @brief Triggers a system fatal error with a custom \ref FatalType.
    /// @param err[in] Result code to throw.
    /// @param type[in] Type of fatal error to throw.
    /// @note This function may not return, depending on \ref FatalType.
    pub fn fatalWithType(err: Result, type_: FatalType);
}
extern "C" {
    /// @brief Triggers a system fatal error with a custom \ref FatalType and \ref FatalContext.
    /// @param err[in]  Result code to throw.
    /// @param type[in] Type of fatal error to throw.
    /// @param ctx[in]  Cpu context for fatal error to throw.
    /// @note This function may not return, depending on \ref FatalType.
    pub fn fatalWithContext(err: Result, type_: FatalType, ctx: *mut FatalContext);
}
pub const TimeType_TimeType_UserSystemClock: TimeType = 0;
pub const TimeType_TimeType_NetworkSystemClock: TimeType = 1;
pub const TimeType_TimeType_LocalSystemClock: TimeType = 2;
pub const TimeType_TimeType_Default: TimeType = 0;
/// Time clock type.
pub type TimeType = u32;
#[repr(C)]
pub struct TimeCalendarTime {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub hour: u8,
    pub minute: u8,
    pub second: u8,
    pub pad: u8,
}
#[test]
fn bindgen_test_layout_TimeCalendarTime() {
    assert_eq!(
        ::core::mem::size_of::<TimeCalendarTime>(),
        8usize,
        concat!("Size of: ", stringify!(TimeCalendarTime))
    );
    assert_eq!(
        ::core::mem::align_of::<TimeCalendarTime>(),
        2usize,
        concat!("Alignment of ", stringify!(TimeCalendarTime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).month as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).day as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).hour as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).minute as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).second as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarTime>())).pad as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarTime),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
pub struct TimeCalendarAdditionalInfo {
    /// < 0-based day-of-week.
    pub wday: u32,
    /// < 0-based day-of-year.
    pub yday: u32,
    /// < Timezone name string.
    pub timezoneName: [lang_items::c_char; 8usize],
    /// < 0 = no DST, 1 = DST.
    pub DST: u32,
    /// < Seconds relative to UTC for this timezone.
    pub offset: s32,
}
#[test]
fn bindgen_test_layout_TimeCalendarAdditionalInfo() {
    assert_eq!(
        ::core::mem::size_of::<TimeCalendarAdditionalInfo>(),
        24usize,
        concat!("Size of: ", stringify!(TimeCalendarAdditionalInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<TimeCalendarAdditionalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(TimeCalendarAdditionalInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).wday as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(wday)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).yday as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(yday)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).timezoneName as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(timezoneName)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).DST as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(DST)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<TimeCalendarAdditionalInfo>())).offset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeCalendarAdditionalInfo),
            "::",
            stringify!(offset)
        )
    );
}
extern "C" {
    pub fn timeInitialize() -> Result;
}
extern "C" {
    pub fn timeExit();
}
extern "C" {
    pub fn timeGetSessionService() -> *mut Service;
}
extern "C" {
    pub fn timeGetCurrentTime(type_: TimeType, timestamp: *mut u64) -> Result;
}
extern "C" {
    /// @brief Sets the time for the specified clock.
    /// @param[in] type Clock to use.
    /// @param[in] timestamp POSIX UTC timestamp.
    /// @return Result code.
    pub fn timeSetCurrentTime(type_: TimeType, timestamp: u64) -> Result;
}
extern "C" {
    pub fn timeToCalendarTimeWithMyRule(
        timestamp: u64,
        caltime: *mut TimeCalendarTime,
        info: *mut TimeCalendarAdditionalInfo,
    ) -> Result;
}
/// Imported from libusb, with some adjustments.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct usb_endpoint_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_ENDPOINT.
    pub bDescriptorType: u8,
    /// < Should be one of the usb_endpoint_direction values, the endpoint-number is automatically allocated.
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
}
#[test]
fn bindgen_test_layout_usb_endpoint_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_endpoint_descriptor>(),
        7usize,
        concat!("Size of: ", stringify!(usb_endpoint_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_endpoint_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_endpoint_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bEndpointAddress as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bEndpointAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bmAttributes as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).wMaxPacketSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(wMaxPacketSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_endpoint_descriptor>())).bInterval as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_endpoint_descriptor),
            "::",
            stringify!(bInterval)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct usb_interface_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_INTERFACE.
    pub bDescriptorType: u8,
    /// < See also USBDS_DEFAULT_InterfaceNumber.
    pub bInterfaceNumber: u8,
    /// < Must match 0.
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
    /// < Ignored.
    pub iInterface: u8,
}
#[test]
fn bindgen_test_layout_usb_interface_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_interface_descriptor>(),
        9usize,
        concat!("Size of: ", stringify!(usb_interface_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_interface_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_interface_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bLength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bDescriptorType as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceNumber as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bAlternateSetting as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bAlternateSetting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bNumEndpoints as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bNumEndpoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceClass as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceSubClass as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).bInterfaceProtocol as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_interface_descriptor>())).iInterface as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_interface_descriptor),
            "::",
            stringify!(iInterface)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct usb_device_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_Device.
    pub bDescriptorType: u8,
    pub bcdUSB: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize0: u8,
    pub idVendor: u16,
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_device_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_device_descriptor>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).bcdUSB as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDeviceClass as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDeviceSubClass as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bDeviceProtocol as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bMaxPacketSize0 as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).idVendor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).idProduct as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bcdDevice as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).iManufacturer as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_device_descriptor>())).iProduct as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).iSerialNumber as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_device_descriptor>())).bNumConfigurations as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct usb_config_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub MaxPower: u8,
}
#[test]
fn bindgen_test_layout_usb_config_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_config_descriptor>(),
        9usize,
        concat!("Size of: ", stringify!(usb_config_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_config_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_config_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).wTotalLength as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(wTotalLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bNumInterfaces as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bNumInterfaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bConfigurationValue as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bConfigurationValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).iConfiguration as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(iConfiguration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_config_descriptor>())).bmAttributes as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_config_descriptor>())).MaxPower as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_config_descriptor),
            "::",
            stringify!(MaxPower)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct usb_ss_endpoint_companion_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_SS_ENDPOINT_COMPANION.
    pub bDescriptorType: u8,
    pub bMaxBurst: u8,
    pub bmAttributes: u8,
    pub wBytesPerInterval: u16,
}
#[test]
fn bindgen_test_layout_usb_ss_endpoint_companion_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_ss_endpoint_companion_descriptor>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(usb_ss_endpoint_companion_descriptor)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usb_ss_endpoint_companion_descriptor>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(usb_ss_endpoint_companion_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bLength as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bDescriptorType
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bMaxBurst as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bMaxBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).bmAttributes
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(bmAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_ss_endpoint_companion_descriptor>())).wBytesPerInterval
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_ss_endpoint_companion_descriptor),
            "::",
            stringify!(wBytesPerInterval)
        )
    );
}
/// Imported from libusb, with some adjustments.
#[repr(C)]
pub struct usb_string_descriptor {
    pub bLength: u8,
    /// < Must match USB_DT_STRING.
    pub bDescriptorType: u8,
    pub wData: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_usb_string_descriptor() {
    assert_eq!(
        ::core::mem::size_of::<usb_string_descriptor>(),
        130usize,
        concat!("Size of: ", stringify!(usb_string_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_string_descriptor>(),
        2usize,
        concat!("Alignment of ", stringify!(usb_string_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_string_descriptor>())).bLength as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<usb_string_descriptor>())).bDescriptorType as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<usb_string_descriptor>())).wData as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_string_descriptor),
            "::",
            stringify!(wData)
        )
    );
}
pub const usb_class_code_USB_CLASS_PER_INTERFACE: usb_class_code = 0;
pub const usb_class_code_USB_CLASS_AUDIO: usb_class_code = 1;
pub const usb_class_code_USB_CLASS_COMM: usb_class_code = 2;
pub const usb_class_code_USB_CLASS_HID: usb_class_code = 3;
pub const usb_class_code_USB_CLASS_PHYSICAL: usb_class_code = 5;
pub const usb_class_code_USB_CLASS_PRINTER: usb_class_code = 7;
pub const usb_class_code_USB_CLASS_PTP: usb_class_code = 6;
pub const usb_class_code_USB_CLASS_IMAGE: usb_class_code = 6;
pub const usb_class_code_USB_CLASS_MASS_STORAGE: usb_class_code = 8;
pub const usb_class_code_USB_CLASS_HUB: usb_class_code = 9;
pub const usb_class_code_USB_CLASS_DATA: usb_class_code = 10;
pub const usb_class_code_USB_CLASS_SMART_CARD: usb_class_code = 11;
pub const usb_class_code_USB_CLASS_CONTENT_SECURITY: usb_class_code = 13;
pub const usb_class_code_USB_CLASS_VIDEO: usb_class_code = 14;
pub const usb_class_code_USB_CLASS_PERSONAL_HEALTHCARE: usb_class_code = 15;
pub const usb_class_code_USB_CLASS_DIAGNOSTIC_DEVICE: usb_class_code = 220;
pub const usb_class_code_USB_CLASS_WIRELESS: usb_class_code = 224;
pub const usb_class_code_USB_CLASS_APPLICATION: usb_class_code = 254;
pub const usb_class_code_USB_CLASS_VENDOR_SPEC: usb_class_code = 255;
/// Imported from libusb, with changed names.
pub type usb_class_code = u32;
pub const usb_descriptor_type_USB_DT_DEVICE: usb_descriptor_type = 1;
pub const usb_descriptor_type_USB_DT_CONFIG: usb_descriptor_type = 2;
pub const usb_descriptor_type_USB_DT_STRING: usb_descriptor_type = 3;
pub const usb_descriptor_type_USB_DT_INTERFACE: usb_descriptor_type = 4;
pub const usb_descriptor_type_USB_DT_ENDPOINT: usb_descriptor_type = 5;
pub const usb_descriptor_type_USB_DT_BOS: usb_descriptor_type = 15;
pub const usb_descriptor_type_USB_DT_DEVICE_CAPABILITY: usb_descriptor_type = 16;
pub const usb_descriptor_type_USB_DT_HID: usb_descriptor_type = 33;
pub const usb_descriptor_type_USB_DT_REPORT: usb_descriptor_type = 34;
pub const usb_descriptor_type_USB_DT_PHYSICAL: usb_descriptor_type = 35;
pub const usb_descriptor_type_USB_DT_HUB: usb_descriptor_type = 41;
pub const usb_descriptor_type_USB_DT_SUPERSPEED_HUB: usb_descriptor_type = 42;
pub const usb_descriptor_type_USB_DT_SS_ENDPOINT_COMPANION: usb_descriptor_type = 48;
/// Imported from libusb, with changed names.
pub type usb_descriptor_type = u32;
pub const usb_endpoint_direction_USB_ENDPOINT_IN: usb_endpoint_direction = 128;
pub const usb_endpoint_direction_USB_ENDPOINT_OUT: usb_endpoint_direction = 0;
/// Imported from libusb, with changed names.
pub type usb_endpoint_direction = u32;
pub const usb_transfer_type_USB_TRANSFER_TYPE_CONTROL: usb_transfer_type = 0;
pub const usb_transfer_type_USB_TRANSFER_TYPE_ISOCHRONOUS: usb_transfer_type = 1;
pub const usb_transfer_type_USB_TRANSFER_TYPE_BULK: usb_transfer_type = 2;
pub const usb_transfer_type_USB_TRANSFER_TYPE_INTERRUPT: usb_transfer_type = 3;
pub const usb_transfer_type_USB_TRANSFER_TYPE_BULK_STREAM: usb_transfer_type = 4;
/// Imported from libusb, with changed names.
pub type usb_transfer_type = u32;
/// Request status of the specific recipient
pub const usb_standard_request_USB_REQUEST_GET_STATUS: usb_standard_request = 0;
/// Clear or disable a specific feature
pub const usb_standard_request_USB_REQUEST_CLEAR_FEATURE: usb_standard_request = 1;
/// Set or enable a specific feature
pub const usb_standard_request_USB_REQUEST_SET_FEATURE: usb_standard_request = 3;
/// Set device address for all future accesses
pub const usb_standard_request_USB_REQUEST_SET_ADDRESS: usb_standard_request = 5;
/// Get the specified descriptor
pub const usb_standard_request_USB_REQUEST_GET_DESCRIPTOR: usb_standard_request = 6;
/// Used to update existing descriptors or add new descriptors
pub const usb_standard_request_USB_REQUEST_SET_DESCRIPTOR: usb_standard_request = 7;
/// Get the current device configuration value
pub const usb_standard_request_USB_REQUEST_GET_CONFIGURATION: usb_standard_request = 8;
/// Set device configuration
pub const usb_standard_request_USB_REQUEST_SET_CONFIGURATION: usb_standard_request = 9;
/// Return the selected alternate setting for the specified interface
pub const usb_standard_request_USB_REQUEST_GET_INTERFACE: usb_standard_request = 10;
/// Select an alternate interface for the specified interface
pub const usb_standard_request_USB_REQUEST_SET_INTERFACE: usb_standard_request = 11;
/// Set then report an endpoint's synchronization frame
pub const usb_standard_request_USB_REQUEST_SYNCH_FRAME: usb_standard_request = 12;
/// Sets both the U1 and U2 Exit Latency
pub const usb_standard_request_USB_REQUEST_SET_SEL: usb_standard_request = 48;
/// Delay from the time a host transmits a packet to the time it is
/// received by the device.
pub const usb_standard_request_USB_SET_ISOCH_DELAY: usb_standard_request = 49;
/// Imported from libusb, with changed names.
pub type usb_standard_request = u32;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_NONE: usb_iso_sync_type = 0;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_ASYNC: usb_iso_sync_type = 1;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_ADAPTIVE: usb_iso_sync_type = 2;
pub const usb_iso_sync_type_USB_ISO_SYNC_TYPE_SYNC: usb_iso_sync_type = 3;
/// Imported from libusb, with changed names.
pub type usb_iso_sync_type = u32;
pub const usb_iso_usage_type_USB_ISO_USAGE_TYPE_DATA: usb_iso_usage_type = 0;
pub const usb_iso_usage_type_USB_ISO_USAGE_TYPE_FEEDBACK: usb_iso_usage_type = 1;
pub const usb_iso_usage_type_USB_ISO_USAGE_TYPE_IMPLICIT: usb_iso_usage_type = 2;
/// Imported from libusb, with changed names.
pub type usb_iso_usage_type = u32;
/// Value for usb_interface_descriptor bInterfaceNumber for automatically allocating the actual bInterfaceNumber.
#[repr(C)]
pub struct UsbDsDeviceInfo {
    /// < VID
    pub idVendor: u16,
    /// < PID
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub Manufacturer: [lang_items::c_char; 32usize],
    pub Product: [lang_items::c_char; 32usize],
    pub SerialNumber: [lang_items::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_UsbDsDeviceInfo() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsDeviceInfo>(),
        102usize,
        concat!("Size of: ", stringify!(UsbDsDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsDeviceInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(UsbDsDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).idVendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).idProduct as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).bcdDevice as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).Manufacturer as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(Manufacturer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).Product as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(Product)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsDeviceInfo>())).SerialNumber as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsDeviceInfo),
            "::",
            stringify!(SerialNumber)
        )
    );
}
#[repr(C)]
pub struct UsbDsReportEntry {
    /// < urbId from post-buffer cmds
    pub id: u32,
    pub requestedSize: u32,
    pub transferredSize: u32,
    pub urb_status: u32,
}
#[test]
fn bindgen_test_layout_UsbDsReportEntry() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsReportEntry>(),
        16usize,
        concat!("Size of: ", stringify!(UsbDsReportEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsReportEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsReportEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportEntry>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportEntry>())).requestedSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(requestedSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbDsReportEntry>())).transferredSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(transferredSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportEntry>())).urb_status as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportEntry),
            "::",
            stringify!(urb_status)
        )
    );
}
#[repr(C)]
pub struct UsbDsReportData {
    pub report: [UsbDsReportEntry; 8usize],
    pub report_count: u32,
}
#[test]
fn bindgen_test_layout_UsbDsReportData() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsReportData>(),
        132usize,
        concat!("Size of: ", stringify!(UsbDsReportData))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsReportData>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsReportData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportData>())).report as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportData),
            "::",
            stringify!(report)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsReportData>())).report_count as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsReportData),
            "::",
            stringify!(report_count)
        )
    );
}
#[repr(C)]
pub struct UsbDsInterface {
    pub initialized: bool,
    pub interface_index: u32,
    pub h: Service,
    pub SetupEvent: Event,
    pub CtrlInCompletionEvent: Event,
    pub CtrlOutCompletionEvent: Event,
}
#[test]
fn bindgen_test_layout_UsbDsInterface() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsInterface>(),
        56usize,
        concat!("Size of: ", stringify!(UsbDsInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsInterface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).interface_index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(interface_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsInterface>())).SetupEvent as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(SetupEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbDsInterface>())).CtrlInCompletionEvent as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(CtrlInCompletionEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbDsInterface>())).CtrlOutCompletionEvent as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsInterface),
            "::",
            stringify!(CtrlOutCompletionEvent)
        )
    );
}
#[repr(C)]
pub struct UsbDsEndpoint {
    pub initialized: bool,
    pub h: Service,
    pub CompletionEvent: Event,
}
#[test]
fn bindgen_test_layout_UsbDsEndpoint() {
    assert_eq!(
        ::core::mem::size_of::<UsbDsEndpoint>(),
        28usize,
        concat!("Size of: ", stringify!(UsbDsEndpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDsEndpoint>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDsEndpoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsEndpoint>())).initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsEndpoint),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsEndpoint>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsEndpoint),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbDsEndpoint>())).CompletionEvent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDsEndpoint),
            "::",
            stringify!(CompletionEvent)
        )
    );
}
pub const UsbComplexId_UsbComplexId_Default: UsbComplexId = 2;
pub type UsbComplexId = u32;
/// < USB 1.1 Full Speed
pub const UsbDeviceSpeed_UsbDeviceSpeed_Full: UsbDeviceSpeed = 2;
/// < USB 2.0 High Speed
pub const UsbDeviceSpeed_UsbDeviceSpeed_High: UsbDeviceSpeed = 3;
/// < USB 3.0 Super Speed
pub const UsbDeviceSpeed_UsbDeviceSpeed_Super: UsbDeviceSpeed = 4;
pub type UsbDeviceSpeed = u32;
extern "C" {
    /// Opens a session with usb:ds.
    pub fn usbDsInitialize() -> Result;
}
extern "C" {
    /// Closes the usb:ds session. Any interfaces/endpoints which are left open are automatically closed, since otherwise usb-sysmodule won't fully reset usb:ds to defaults.
    pub fn usbDsExit();
}
extern "C" {
    /// Helpers
    pub fn usbDsWaitReady(timeout: u64) -> Result;
}
extern "C" {
    pub fn usbDsParseReportData(
        reportdata: *mut UsbDsReportData,
        urbId: u32,
        requestedSize: *mut u32,
        transferredSize: *mut u32,
    ) -> Result;
}
extern "C" {
    /// IDsService
    pub fn usbDsGetStateChangeEvent() -> *mut Event;
}
extern "C" {
    pub fn usbDsGetState(out: *mut u32) -> Result;
}
extern "C" {
    /// Removed in 5.0.0
    pub fn usbDsGetDsInterface(
        out: *mut *mut UsbDsInterface,
        descriptor: *mut usb_interface_descriptor,
        interface_name: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn usbDsSetVidPidBcd(deviceinfo: *const UsbDsDeviceInfo) -> Result;
}
extern "C" {
    /// Added in 5.0.0
    pub fn usbDsRegisterInterface(out: *mut *mut UsbDsInterface) -> Result;
}
extern "C" {
    pub fn usbDsRegisterInterfaceEx(out: *mut *mut UsbDsInterface, intf_num: u32) -> Result;
}
extern "C" {
    pub fn usbDsClearDeviceData() -> Result;
}
extern "C" {
    pub fn usbDsAddUsbStringDescriptor(
        out_index: *mut u8,
        string: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn usbDsAddUsbLanguageStringDescriptor(
        out_index: *mut u8,
        lang_ids: *const u16,
        num_langs: u16,
    ) -> Result;
}
extern "C" {
    pub fn usbDsDeleteUsbStringDescriptor(index: u8) -> Result;
}
extern "C" {
    pub fn usbDsSetUsbDeviceDescriptor(
        speed: UsbDeviceSpeed,
        descriptor: *mut usb_device_descriptor,
    ) -> Result;
}
extern "C" {
    pub fn usbDsSetBinaryObjectStore(bos: *mut lang_items::c_void, bos_size: usize) -> Result;
}
extern "C" {
    pub fn usbDsEnable() -> Result;
}
extern "C" {
    pub fn usbDsDisable() -> Result;
}
extern "C" {
    /// IDsInterface
    pub fn usbDsInterface_Close(interface: *mut UsbDsInterface);
}
extern "C" {
    pub fn usbDsInterface_GetSetupPacket(
        interface: *mut UsbDsInterface,
        buffer: *mut lang_items::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_EnableInterface(interface: *mut UsbDsInterface) -> Result;
}
extern "C" {
    pub fn usbDsInterface_DisableInterface(interface: *mut UsbDsInterface) -> Result;
}
extern "C" {
    pub fn usbDsInterface_CtrlInPostBufferAsync(
        interface: *mut UsbDsInterface,
        buffer: *mut lang_items::c_void,
        size: usize,
        urbId: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_CtrlOutPostBufferAsync(
        interface: *mut UsbDsInterface,
        buffer: *mut lang_items::c_void,
        size: usize,
        urbId: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_GetCtrlInReportData(
        interface: *mut UsbDsInterface,
        out: *mut UsbDsReportData,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_GetCtrlOutReportData(
        interface: *mut UsbDsInterface,
        out: *mut UsbDsReportData,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_StallCtrl(interface: *mut UsbDsInterface) -> Result;
}
extern "C" {
    /// Removed in 5.0.0
    pub fn usbDsInterface_GetDsEndpoint(
        interface: *mut UsbDsInterface,
        endpoint: *mut *mut UsbDsEndpoint,
        descriptor: *mut usb_endpoint_descriptor,
    ) -> Result;
}
extern "C" {
    /// Added in 5.0.0
    pub fn usbDsInterface_RegisterEndpoint(
        interface: *mut UsbDsInterface,
        endpoint: *mut *mut UsbDsEndpoint,
        endpoint_address: u8,
    ) -> Result;
}
extern "C" {
    pub fn usbDsInterface_AppendConfigurationData(
        interface: *mut UsbDsInterface,
        speed: UsbDeviceSpeed,
        buffer: *mut lang_items::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    /// IDsEndpoint
    pub fn usbDsEndpoint_Close(endpoint: *mut UsbDsEndpoint);
}
extern "C" {
    pub fn usbDsEndpoint_Cancel(endpoint: *mut UsbDsEndpoint) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_PostBufferAsync(
        endpoint: *mut UsbDsEndpoint,
        buffer: *mut lang_items::c_void,
        size: usize,
        urbId: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_GetReportData(
        endpoint: *mut UsbDsEndpoint,
        out: *mut UsbDsReportData,
    ) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_StallCtrl(endpoint: *mut UsbDsEndpoint) -> Result;
}
extern "C" {
    pub fn usbDsEndpoint_SetZlt(endpoint: *mut UsbDsEndpoint, zlt: bool) -> Result;
}
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_idVendor: UsbHsInterfaceFilterFlags =
    1;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_idProduct: UsbHsInterfaceFilterFlags =
    2;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bcdDevice_Min:
    UsbHsInterfaceFilterFlags = 4;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bcdDevice_Max:
    UsbHsInterfaceFilterFlags = 8;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bDeviceClass:
    UsbHsInterfaceFilterFlags = 16;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bDeviceSubClass:
    UsbHsInterfaceFilterFlags = 32;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bDeviceProtocol:
    UsbHsInterfaceFilterFlags = 64;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bInterfaceClass:
    UsbHsInterfaceFilterFlags = 128;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bInterfaceSubClass:
    UsbHsInterfaceFilterFlags = 256;
pub const UsbHsInterfaceFilterFlags_UsbHsInterfaceFilterFlags_bInterfaceProtocol:
    UsbHsInterfaceFilterFlags = 512;
pub type UsbHsInterfaceFilterFlags = u16;
/// Interface filtering struct. When the associated flag bit is set, the associated descriptor field and struct field are compared, on mismatch the interface is filtered out.
#[repr(C)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub struct UsbHsInterfaceFilter {
    /// < See \ref UsbHsInterfaceFilterFlags. Setting this to 0 is equivalent to disabling filtering.
    pub Flags: u16,
    pub idVendor: u16,
    pub idProduct: u16,
    /// < Descriptor value must be >= bcdDevice_Min.
    pub bcdDevice_Min: u16,
    /// < Descriptor value must be <= bcdDevice_Max.
    pub bcdDevice_Max: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
}
#[test]
fn bindgen_test_layout_UsbHsInterfaceFilter() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsInterfaceFilter>(),
        16usize,
        concat!("Size of: ", stringify!(UsbHsInterfaceFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsInterfaceFilter>(),
        2usize,
        concat!("Alignment of ", stringify!(UsbHsInterfaceFilter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).Flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).idVendor as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).idProduct as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bcdDevice_Min as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bcdDevice_Min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bcdDevice_Max as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bcdDevice_Max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bDeviceClass as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bDeviceSubClass as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bDeviceProtocol as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bInterfaceClass as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bInterfaceSubClass as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceFilter>())).bInterfaceProtocol as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceFilter),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
}
/// Descriptors which are not available are set to all-zero.
#[repr(C, packed)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub struct UsbHsInterfaceInfo {
    pub ID: s32,
    pub deviceID_2: u32,
    pub unk_x8: u32,
    pub interface_desc: usb_interface_descriptor,
    pub pad_x15: [u8; 7usize],
    pub output_endpoint_descs: [usb_endpoint_descriptor; 15usize],
    pub pad_x85: [u8; 7usize],
    pub input_endpoint_descs: [usb_endpoint_descriptor; 15usize],
    pub pad_xf5: [u8; 6usize],
    /// < ?
    pub output_ss_endpoint_companion_descs: [usb_ss_endpoint_companion_descriptor; 15usize],
    pub pad_x155: [u8; 6usize],
    /// < ?
    pub input_ss_endpoint_companion_descs: [usb_ss_endpoint_companion_descriptor; 15usize],
    pub pad_x1b5: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_UsbHsInterfaceInfo() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsInterfaceInfo>(),
        440usize,
        concat!("Size of: ", stringify!(UsbHsInterfaceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsInterfaceInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbHsInterfaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).deviceID_2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(deviceID_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).unk_x8 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(unk_x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).interface_desc as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(interface_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x15 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).output_endpoint_descs as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(output_endpoint_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x85 as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x85)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).input_endpoint_descs as *const _
                as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(input_endpoint_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_xf5 as *const _ as usize },
        245usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_xf5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).output_ss_endpoint_companion_descs
                as *const _ as usize
        },
        251usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(output_ss_endpoint_companion_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x155 as *const _ as usize },
        341usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x155)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).input_ss_endpoint_companion_descs
                as *const _ as usize
        },
        347usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(input_ss_endpoint_companion_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterfaceInfo>())).pad_x1b5 as *const _ as usize },
        437usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterfaceInfo),
            "::",
            stringify!(pad_x1b5)
        )
    );
}
/// Interface struct. Note that devices have a seperate \ref UsbHsInterface for each interface.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct UsbHsInterface {
    pub inf: UsbHsInterfaceInfo,
    pub pathstr: [lang_items::c_char; 64usize],
    pub busID: u32,
    pub deviceID: u32,
    pub device_desc: usb_device_descriptor,
    pub config_desc: usb_config_descriptor,
    pub pad_x21b: [u8; 5usize],
    /// < Unknown u64 timestamp for when the device was inserted?
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_UsbHsInterface() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsInterface>(),
        552usize,
        concat!("Size of: ", stringify!(UsbHsInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsInterface>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbHsInterface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).inf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(inf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).pathstr as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(pathstr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).busID as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(busID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).deviceID as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(deviceID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).device_desc as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(device_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).config_desc as *const _ as usize },
        530usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(config_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).pad_x21b as *const _ as usize },
        539usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(pad_x21b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsInterface>())).timestamp as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsInterface),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
pub struct UsbHsXferReport {
    pub xferId: u32,
    pub res: Result,
    pub requestedSize: u32,
    pub transferredSize: u32,
    pub unk_x10: u64,
}
#[test]
fn bindgen_test_layout_UsbHsXferReport() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsXferReport>(),
        24usize,
        concat!("Size of: ", stringify!(UsbHsXferReport))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsXferReport>(),
        8usize,
        concat!("Alignment of ", stringify!(UsbHsXferReport))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).xferId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(xferId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).res as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).requestedSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(requestedSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsXferReport>())).transferredSize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(transferredSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsXferReport>())).unk_x10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsXferReport),
            "::",
            stringify!(unk_x10)
        )
    );
}
/// The interface service object. These Events have autoclear=false.
#[repr(C)]
pub struct UsbHsClientIfSession {
    pub s: Service,
    /// < Unknown.
    pub event0: Event,
    /// < [2.0.0+] Signaled when CtrlXferAsync finishes.
    pub eventCtrlXfer: Event,
    pub ID: s32,
    /// < Initialized with the input interface from \ref usbHsAcquireUsbIf, then the first 0x1B8-bytes are overwritten with the cmd output (data before pathstr).
    pub inf: UsbHsInterface,
}
#[test]
fn bindgen_test_layout_UsbHsClientIfSession() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsClientIfSession>(),
        592usize,
        concat!("Size of: ", stringify!(UsbHsClientIfSession))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsClientIfSession>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbHsClientIfSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).event0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(event0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbHsClientIfSession>())).eventCtrlXfer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(eventCtrlXfer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).ID as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientIfSession>())).inf as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientIfSession),
            "::",
            stringify!(inf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
pub struct UsbHsClientEpSession {
    pub s: Service,
    /// < [2.0.0+] Signaled when PostBufferAsync finishes.
    pub eventXfer: Event,
    pub desc: usb_endpoint_descriptor,
}
#[test]
fn bindgen_test_layout_UsbHsClientEpSession() {
    assert_eq!(
        ::core::mem::size_of::<UsbHsClientEpSession>(),
        32usize,
        concat!("Size of: ", stringify!(UsbHsClientEpSession))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbHsClientEpSession>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbHsClientEpSession))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientEpSession>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientEpSession),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientEpSession>())).eventXfer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientEpSession),
            "::",
            stringify!(eventXfer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<UsbHsClientEpSession>())).desc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbHsClientEpSession),
            "::",
            stringify!(desc)
        )
    );
}
extern "C" {
    /// Initialize/exit usb:hs.
    pub fn usbHsInitialize() -> Result;
}
extern "C" {
    pub fn usbHsExit();
}
extern "C" {
    /// Returns the Event loaded during init with autoclear=false.
    /// Signaled when a device was removed.
    /// When signaled, the user should use \ref usbHsQueryAcquiredInterfaces and cleanup state for all interfaces which are not listed in the output interfaces (none of the IDs match \ref usbHsIfGetID output).
    pub fn usbHsGetInterfaceStateChangeEvent() -> *mut Event;
}
extern "C" {
    /// @brief Returns an array of all \ref UsbHsInterface. Internally this loads the same interfaces as \ref usbHsQueryAvailableInterfaces, followed by \ref usbHsQueryAcquiredInterfaces. However, ID in \ref UsbHsInterface is set to -1, hence the output from this should not be used with \ref usbHsAcquireUsbIf.
    /// @param[in] filter \ref UsbHsInterfaceFilter.
    /// @param[out] interfaces Array of output interfaces.
    /// @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
    /// @param[out] total_entries Total number of output interfaces.
    pub fn usbHsQueryAllInterfaces(
        filter: *const UsbHsInterfaceFilter,
        interfaces: *mut UsbHsInterface,
        interfaces_maxsize: usize,
        total_entries: *mut s32,
    ) -> Result;
}
extern "C" {
    /// @brief Returns an array of \ref UsbHsInterface which are available.
    /// @param[in] filter \ref UsbHsInterfaceFilter.
    /// @param[out] interfaces Array of output interfaces.
    /// @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
    /// @param[out] total_entries Total number of output interfaces.
    pub fn usbHsQueryAvailableInterfaces(
        filter: *const UsbHsInterfaceFilter,
        interfaces: *mut UsbHsInterface,
        interfaces_maxsize: usize,
        total_entries: *mut s32,
    ) -> Result;
}
extern "C" {
    /// @brief Returns an array of \ref UsbHsInterface which were previously acquired.
    /// @param[out] interfaces Array of output interfaces.
    /// @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
    /// @param[out] total_entries Total number of output interfaces.
    pub fn usbHsQueryAcquiredInterfaces(
        interfaces: *mut UsbHsInterface,
        interfaces_maxsize: usize,
        total_entries: *mut s32,
    ) -> Result;
}
extern "C" {
    /// @brief Creates an event which is signaled when an interface is available which passes the filtering checks.
    /// @param[out] event Event object.
    /// @param[in] autoclear Event autoclear.
    /// @param[in] index Event index, must be 0..2.
    /// @param[in] filter \ref UsbHsInterfaceFilter.
    pub fn usbHsCreateInterfaceAvailableEvent(
        event: *mut Event,
        autoclear: bool,
        index: u8,
        filter: *const UsbHsInterfaceFilter,
    ) -> Result;
}
extern "C" {
    /// @brief Destroys an event setup by \ref usbHsCreateInterfaceAvailableEvent. This *must* be used at some point during cleanup.
    /// @param[in] event Event object to close.
    /// @param[in] index Event index, must be 0..2.
    pub fn usbHsDestroyInterfaceAvailableEvent(event: *mut Event, index: u8) -> Result;
}
extern "C" {
    /// @brief Acquires/opens the specified interface. This returns an error if the interface was already acquired by another process.
    /// @param[in] s The service object.
    /// @param[in] interface Interface to use.
    pub fn usbHsAcquireUsbIf(
        s: *mut UsbHsClientIfSession,
        interface: *mut UsbHsInterface,
    ) -> Result;
}
extern "C" {
    /// Closes the specified interface session.
    pub fn usbHsIfClose(s: *mut UsbHsClientIfSession);
}
extern "C" {
    /// @brief Selects an interface.
    /// @param[in] s The service object.
    /// @param[out] inf The output interface info. If NULL, the output is stored within s instead.
    /// @param[in] id ID
    pub fn usbHsIfSetInterface(
        s: *mut UsbHsClientIfSession,
        inf: *mut UsbHsInterfaceInfo,
        id: u8,
    ) -> Result;
}
extern "C" {
    /// @brief Gets an interface.
    /// @param[in] s The service object.
    /// @param[out] inf The output interface info. If NULL, the output is stored within s instead.
    pub fn usbHsIfGetInterface(
        s: *mut UsbHsClientIfSession,
        inf: *mut UsbHsInterfaceInfo,
    ) -> Result;
}
extern "C" {
    /// @brief Gets an alternate interface.
    /// @param[in] s The service object.
    /// @param[out] inf The output interface info. If NULL, the output is stored within s instead.
    /// @param[in] id ID
    pub fn usbHsIfGetAlternateInterface(
        s: *mut UsbHsClientIfSession,
        inf: *mut UsbHsInterfaceInfo,
        id: u8,
    ) -> Result;
}
extern "C" {
    /// On 1.0.0 this is stubbed, just returns 0 with out=0.
    pub fn usbHsIfGetCurrentFrame(s: *mut UsbHsClientIfSession, out: *mut u32) -> Result;
}
extern "C" {
    /// Uses a control transfer, this will block until the transfer finishes. The buffer address and size should be aligned to 0x1000-bytes, where wLength is the original size.
    pub fn usbHsIfCtrlXfer(
        s: *mut UsbHsClientIfSession,
        bmRequestType: u8,
        bRequest: u8,
        wValue: u16,
        wIndex: u16,
        wLength: u16,
        buffer: *mut lang_items::c_void,
        transferredSize: *mut u32,
    ) -> Result;
}
extern "C" {
    /// @brief Opens an endpoint. maxUrbCount*maxXferSize must be non-zero.
    /// @param[in] s The interface object.
    /// @param[out] ep The endpoint object.
    /// @param[in] maxUrbCount maxUrbCount, must be <0x11.
    /// @param[in] maxXferSize Max transfer size for a packet. This can be desc->wMaxPacketSize. Must be <=0xFF0000.
    /// @param[in] desc Endpoint descriptor.
    pub fn usbHsIfOpenUsbEp(
        s: *mut UsbHsClientIfSession,
        ep: *mut UsbHsClientEpSession,
        maxUrbCount: u16,
        maxXferSize: u32,
        desc: *mut usb_endpoint_descriptor,
    ) -> Result;
}
extern "C" {
    /// Resets the device: has the same affect as unplugging the device and plugging it back in.
    pub fn usbHsIfResetDevice(s: *mut UsbHsClientIfSession) -> Result;
}
extern "C" {
    /// Closes the specified endpoint session.
    pub fn usbHsEpClose(s: *mut UsbHsClientEpSession);
}
extern "C" {
    /// Uses a data transfer with the specified endpoint, this will block until the transfer finishes. The buffer address and size should be aligned to 0x1000-bytes, where the input size is the original size.
    pub fn usbHsEpPostBuffer(
        s: *mut UsbHsClientEpSession,
        buffer: *mut lang_items::c_void,
        size: u32,
        transferredSize: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn __assert(
        arg1: *const lang_items::c_char,
        arg2: lang_items::c_int,
        arg3: *const lang_items::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const lang_items::c_char,
        arg2: lang_items::c_int,
        arg3: *const lang_items::c_char,
        arg4: *const lang_items::c_char,
    );
}
impl HidMouseButton {
    pub const MOUSE_LEFT: HidMouseButton = HidMouseButton(1);
}
impl HidMouseButton {
    pub const MOUSE_RIGHT: HidMouseButton = HidMouseButton(2);
}
impl HidMouseButton {
    pub const MOUSE_MIDDLE: HidMouseButton = HidMouseButton(4);
}
impl HidMouseButton {
    pub const MOUSE_FORWARD: HidMouseButton = HidMouseButton(8);
}
impl HidMouseButton {
    pub const MOUSE_BACK: HidMouseButton = HidMouseButton(16);
}
impl ::core::ops::BitOr<HidMouseButton> for HidMouseButton {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HidMouseButton(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HidMouseButton {
    #[inline]
    fn bitor_assign(&mut self, rhs: HidMouseButton) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HidMouseButton> for HidMouseButton {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HidMouseButton(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HidMouseButton {
    #[inline]
    fn bitand_assign(&mut self, rhs: HidMouseButton) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HidMouseButton(pub u32);
impl HidKeyboardModifier {
    pub const KBD_MOD_LCTRL: HidKeyboardModifier = HidKeyboardModifier(1);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_LSHIFT: HidKeyboardModifier = HidKeyboardModifier(2);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_LALT: HidKeyboardModifier = HidKeyboardModifier(4);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_LMETA: HidKeyboardModifier = HidKeyboardModifier(8);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_RCTRL: HidKeyboardModifier = HidKeyboardModifier(16);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_RSHIFT: HidKeyboardModifier = HidKeyboardModifier(32);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_RALT: HidKeyboardModifier = HidKeyboardModifier(64);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_RMETA: HidKeyboardModifier = HidKeyboardModifier(128);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_CAPSLOCK: HidKeyboardModifier = HidKeyboardModifier(256);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_SCROLLLOCK: HidKeyboardModifier = HidKeyboardModifier(512);
}
impl HidKeyboardModifier {
    pub const KBD_MOD_NUMLOCK: HidKeyboardModifier = HidKeyboardModifier(1024);
}
impl ::core::ops::BitOr<HidKeyboardModifier> for HidKeyboardModifier {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HidKeyboardModifier(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HidKeyboardModifier {
    #[inline]
    fn bitor_assign(&mut self, rhs: HidKeyboardModifier) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HidKeyboardModifier> for HidKeyboardModifier {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HidKeyboardModifier(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HidKeyboardModifier {
    #[inline]
    fn bitand_assign(&mut self, rhs: HidKeyboardModifier) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HidKeyboardModifier(pub u32);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HidKeyboardScancode {
    KBD_NONE = 0,
    KBD_ERR_OVF = 1,
    KBD_A = 4,
    KBD_B = 5,
    KBD_C = 6,
    KBD_D = 7,
    KBD_E = 8,
    KBD_F = 9,
    KBD_G = 10,
    KBD_H = 11,
    KBD_I = 12,
    KBD_J = 13,
    KBD_K = 14,
    KBD_L = 15,
    KBD_M = 16,
    KBD_N = 17,
    KBD_O = 18,
    KBD_P = 19,
    KBD_Q = 20,
    KBD_R = 21,
    KBD_S = 22,
    KBD_T = 23,
    KBD_U = 24,
    KBD_V = 25,
    KBD_W = 26,
    KBD_X = 27,
    KBD_Y = 28,
    KBD_Z = 29,
    KBD_1 = 30,
    KBD_2 = 31,
    KBD_3 = 32,
    KBD_4 = 33,
    KBD_5 = 34,
    KBD_6 = 35,
    KBD_7 = 36,
    KBD_8 = 37,
    KBD_9 = 38,
    KBD_0 = 39,
    KBD_ENTER = 40,
    KBD_ESC = 41,
    KBD_BACKSPACE = 42,
    KBD_TAB = 43,
    KBD_SPACE = 44,
    KBD_MINUS = 45,
    KBD_EQUAL = 46,
    KBD_LEFTBRACE = 47,
    KBD_RIGHTBRACE = 48,
    KBD_BACKSLASH = 49,
    KBD_HASHTILDE = 50,
    KBD_SEMICOLON = 51,
    KBD_APOSTROPHE = 52,
    KBD_GRAVE = 53,
    KBD_COMMA = 54,
    KBD_DOT = 55,
    KBD_SLASH = 56,
    KBD_CAPSLOCK = 57,
    KBD_F1 = 58,
    KBD_F2 = 59,
    KBD_F3 = 60,
    KBD_F4 = 61,
    KBD_F5 = 62,
    KBD_F6 = 63,
    KBD_F7 = 64,
    KBD_F8 = 65,
    KBD_F9 = 66,
    KBD_F10 = 67,
    KBD_F11 = 68,
    KBD_F12 = 69,
    KBD_SYSRQ = 70,
    KBD_SCROLLLOCK = 71,
    KBD_PAUSE = 72,
    KBD_INSERT = 73,
    KBD_HOME = 74,
    KBD_PAGEUP = 75,
    KBD_DELETE = 76,
    KBD_END = 77,
    KBD_PAGEDOWN = 78,
    KBD_RIGHT = 79,
    KBD_LEFT = 80,
    KBD_DOWN = 81,
    KBD_UP = 82,
    KBD_NUMLOCK = 83,
    KBD_KPSLASH = 84,
    KBD_KPASTERISK = 85,
    KBD_KPMINUS = 86,
    KBD_KPPLUS = 87,
    KBD_KPENTER = 88,
    KBD_KP1 = 89,
    KBD_KP2 = 90,
    KBD_KP3 = 91,
    KBD_KP4 = 92,
    KBD_KP5 = 93,
    KBD_KP6 = 94,
    KBD_KP7 = 95,
    KBD_KP8 = 96,
    KBD_KP9 = 97,
    KBD_KP0 = 98,
    KBD_KPDOT = 99,
    KBD_102ND = 100,
    KBD_COMPOSE = 101,
    KBD_POWER = 102,
    KBD_KPEQUAL = 103,
    KBD_F13 = 104,
    KBD_F14 = 105,
    KBD_F15 = 106,
    KBD_F16 = 107,
    KBD_F17 = 108,
    KBD_F18 = 109,
    KBD_F19 = 110,
    KBD_F20 = 111,
    KBD_F21 = 112,
    KBD_F22 = 113,
    KBD_F23 = 114,
    KBD_F24 = 115,
    KBD_OPEN = 116,
    KBD_HELP = 117,
    KBD_PROPS = 118,
    KBD_FRONT = 119,
    KBD_STOP = 120,
    KBD_AGAIN = 121,
    KBD_UNDO = 122,
    KBD_CUT = 123,
    KBD_COPY = 124,
    KBD_PASTE = 125,
    KBD_FIND = 126,
    KBD_MUTE = 127,
    KBD_VOLUMEUP = 128,
    KBD_VOLUMEDOWN = 129,
    KBD_CAPSLOCK_ACTIVE = 130,
    KBD_NUMLOCK_ACTIVE = 131,
    KBD_SCROLLLOCK_ACTIVE = 132,
    KBD_KPCOMMA = 133,
    KBD_KPLEFTPAREN = 182,
    KBD_KPRIGHTPAREN = 183,
    KBD_LEFTCTRL = 224,
    KBD_LEFTSHIFT = 225,
    KBD_LEFTALT = 226,
    KBD_LEFTMETA = 227,
    KBD_RIGHTCTRL = 228,
    KBD_RIGHTSHIFT = 229,
    KBD_RIGHTALT = 230,
    KBD_RIGHTMETA = 231,
    KBD_MEDIA_PLAYPAUSE = 232,
    KBD_MEDIA_STOPCD = 233,
    KBD_MEDIA_PREVIOUSSONG = 234,
    KBD_MEDIA_NEXTSONG = 235,
    KBD_MEDIA_EJECTCD = 236,
    KBD_MEDIA_VOLUMEUP = 237,
    KBD_MEDIA_VOLUMEDOWN = 238,
    KBD_MEDIA_MUTE = 239,
    KBD_MEDIA_WWW = 240,
    KBD_MEDIA_BACK = 241,
    KBD_MEDIA_FORWARD = 242,
    KBD_MEDIA_STOP = 243,
    KBD_MEDIA_FIND = 244,
    KBD_MEDIA_SCROLLUP = 245,
    KBD_MEDIA_SCROLLDOWN = 246,
    KBD_MEDIA_EDIT = 247,
    KBD_MEDIA_SLEEP = 248,
    KBD_MEDIA_COFFEE = 249,
    KBD_MEDIA_REFRESH = 250,
    KBD_MEDIA_CALC = 251,
}
impl HidControllerType {
    pub const TYPE_PROCONTROLLER: HidControllerType = HidControllerType(1);
}
impl HidControllerType {
    pub const TYPE_HANDHELD: HidControllerType = HidControllerType(2);
}
impl HidControllerType {
    pub const TYPE_JOYCON_PAIR: HidControllerType = HidControllerType(4);
}
impl HidControllerType {
    pub const TYPE_JOYCON_LEFT: HidControllerType = HidControllerType(8);
}
impl HidControllerType {
    pub const TYPE_JOYCON_RIGHT: HidControllerType = HidControllerType(16);
}
impl ::core::ops::BitOr<HidControllerType> for HidControllerType {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HidControllerType(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HidControllerType {
    #[inline]
    fn bitor_assign(&mut self, rhs: HidControllerType) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HidControllerType> for HidControllerType {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HidControllerType(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HidControllerType {
    #[inline]
    fn bitand_assign(&mut self, rhs: HidControllerType) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HidControllerType(pub u32);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HidControllerLayoutType {
    /// < Pro Controller or Hid gamepad.
    LAYOUT_PROCONTROLLER = 0,
    /// < Two Joy-Con docked to rails.
    LAYOUT_HANDHELD = 1,
    /// < Single Joy-Con or pair of Joy-Con, only available in dual-mode with no orientation adjustment.
    LAYOUT_SINGLE = 2,
    /// < Only single-mode raw left Joy-Con state, no orientation adjustment.
    LAYOUT_LEFT = 3,
    /// < Only single-mode raw right Joy-Con state, no orientation adjustment.
    LAYOUT_RIGHT = 4,
    /// < Same as next, but sticks have 8-direction values only.
    LAYOUT_DEFAULT_DIGITAL = 5,
    /// < Safe default. Single-mode and \ref HidJoyHoldType_Horizontal: Joy-Con have buttons/sticks rotated for orientation, where physical Z(L/R) are unavailable and S(L/R) are mapped to L/R (with physical L/R unavailable).
    LAYOUT_DEFAULT = 6,
}
impl HidControllerColorDescription {
    pub const COLORS_NONEXISTENT: HidControllerColorDescription = HidControllerColorDescription(2);
}
impl ::core::ops::BitOr<HidControllerColorDescription> for HidControllerColorDescription {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HidControllerColorDescription(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HidControllerColorDescription {
    #[inline]
    fn bitor_assign(&mut self, rhs: HidControllerColorDescription) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HidControllerColorDescription> for HidControllerColorDescription {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HidControllerColorDescription(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HidControllerColorDescription {
    #[inline]
    fn bitand_assign(&mut self, rhs: HidControllerColorDescription) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HidControllerColorDescription(pub u32);
impl HidControllerKeys {
    /// < A
    pub const KEY_A: HidControllerKeys = HidControllerKeys(1);
}
impl HidControllerKeys {
    /// < B
    pub const KEY_B: HidControllerKeys = HidControllerKeys(2);
}
impl HidControllerKeys {
    /// < X
    pub const KEY_X: HidControllerKeys = HidControllerKeys(4);
}
impl HidControllerKeys {
    /// < Y
    pub const KEY_Y: HidControllerKeys = HidControllerKeys(8);
}
impl HidControllerKeys {
    /// < Left Stick Button
    pub const KEY_LSTICK: HidControllerKeys = HidControllerKeys(16);
}
impl HidControllerKeys {
    /// < Right Stick Button
    pub const KEY_RSTICK: HidControllerKeys = HidControllerKeys(32);
}
impl HidControllerKeys {
    /// < L
    pub const KEY_L: HidControllerKeys = HidControllerKeys(64);
}
impl HidControllerKeys {
    /// < R
    pub const KEY_R: HidControllerKeys = HidControllerKeys(128);
}
impl HidControllerKeys {
    /// < ZL
    pub const KEY_ZL: HidControllerKeys = HidControllerKeys(256);
}
impl HidControllerKeys {
    /// < ZR
    pub const KEY_ZR: HidControllerKeys = HidControllerKeys(512);
}
impl HidControllerKeys {
    /// < Plus
    pub const KEY_PLUS: HidControllerKeys = HidControllerKeys(1024);
}
impl HidControllerKeys {
    /// < Minus
    pub const KEY_MINUS: HidControllerKeys = HidControllerKeys(2048);
}
impl HidControllerKeys {
    /// < D-Pad Left
    pub const KEY_DLEFT: HidControllerKeys = HidControllerKeys(4096);
}
impl HidControllerKeys {
    /// < D-Pad Up
    pub const KEY_DUP: HidControllerKeys = HidControllerKeys(8192);
}
impl HidControllerKeys {
    /// < D-Pad Right
    pub const KEY_DRIGHT: HidControllerKeys = HidControllerKeys(16384);
}
impl HidControllerKeys {
    /// < D-Pad Down
    pub const KEY_DDOWN: HidControllerKeys = HidControllerKeys(32768);
}
impl HidControllerKeys {
    /// < Left Stick Left
    pub const KEY_LSTICK_LEFT: HidControllerKeys = HidControllerKeys(65536);
}
impl HidControllerKeys {
    /// < Left Stick Up
    pub const KEY_LSTICK_UP: HidControllerKeys = HidControllerKeys(131072);
}
impl HidControllerKeys {
    /// < Left Stick Right
    pub const KEY_LSTICK_RIGHT: HidControllerKeys = HidControllerKeys(262144);
}
impl HidControllerKeys {
    /// < Left Stick Down
    pub const KEY_LSTICK_DOWN: HidControllerKeys = HidControllerKeys(524288);
}
impl HidControllerKeys {
    /// < Right Stick Left
    pub const KEY_RSTICK_LEFT: HidControllerKeys = HidControllerKeys(1048576);
}
impl HidControllerKeys {
    /// < Right Stick Up
    pub const KEY_RSTICK_UP: HidControllerKeys = HidControllerKeys(2097152);
}
impl HidControllerKeys {
    /// < Right Stick Right
    pub const KEY_RSTICK_RIGHT: HidControllerKeys = HidControllerKeys(4194304);
}
impl HidControllerKeys {
    /// < Right Stick Down
    pub const KEY_RSTICK_DOWN: HidControllerKeys = HidControllerKeys(8388608);
}
impl HidControllerKeys {
    /// < SL on Left Joy-Con
    pub const KEY_SL_LEFT: HidControllerKeys = HidControllerKeys(16777216);
}
impl HidControllerKeys {
    /// < SR on Left Joy-Con
    pub const KEY_SR_LEFT: HidControllerKeys = HidControllerKeys(33554432);
}
impl HidControllerKeys {
    /// < SL on Right Joy-Con
    pub const KEY_SL_RIGHT: HidControllerKeys = HidControllerKeys(67108864);
}
impl HidControllerKeys {
    /// < SR on Right Joy-Con
    pub const KEY_SR_RIGHT: HidControllerKeys = HidControllerKeys(134217728);
}
impl HidControllerKeys {
    pub const KEY_TOUCH: HidControllerKeys = HidControllerKeys(268435456);
}
impl HidControllerKeys {
    pub const KEY_JOYCON_RIGHT: HidControllerKeys = HidControllerKeys(1);
}
impl HidControllerKeys {
    pub const KEY_JOYCON_DOWN: HidControllerKeys = HidControllerKeys(2);
}
impl HidControllerKeys {
    pub const KEY_JOYCON_UP: HidControllerKeys = HidControllerKeys(4);
}
impl HidControllerKeys {
    pub const KEY_JOYCON_LEFT: HidControllerKeys = HidControllerKeys(8);
}
impl HidControllerKeys {
    /// < D-Pad Up or Sticks Up
    pub const KEY_UP: HidControllerKeys = HidControllerKeys(2236416);
}
impl HidControllerKeys {
    /// < D-Pad Down or Sticks Down
    pub const KEY_DOWN: HidControllerKeys = HidControllerKeys(8945664);
}
impl HidControllerKeys {
    /// < D-Pad Left or Sticks Left
    pub const KEY_LEFT: HidControllerKeys = HidControllerKeys(1118208);
}
impl HidControllerKeys {
    /// < D-Pad Right or Sticks Right
    pub const KEY_RIGHT: HidControllerKeys = HidControllerKeys(4472832);
}
impl HidControllerKeys {
    /// < SL on Left or Right Joy-Con
    pub const KEY_SL: HidControllerKeys = HidControllerKeys(83886080);
}
impl HidControllerKeys {
    /// < SR on Left or Right Joy-Con
    pub const KEY_SR: HidControllerKeys = HidControllerKeys(167772160);
}
impl ::core::ops::BitOr<HidControllerKeys> for HidControllerKeys {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HidControllerKeys(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HidControllerKeys {
    #[inline]
    fn bitor_assign(&mut self, rhs: HidControllerKeys) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HidControllerKeys> for HidControllerKeys {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HidControllerKeys(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HidControllerKeys {
    #[inline]
    fn bitand_assign(&mut self, rhs: HidControllerKeys) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HidControllerKeys(pub u32);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HidControllerJoystick {
    JOYSTICK_LEFT = 0,
    JOYSTICK_RIGHT = 1,
    JOYSTICK_NUM_STICKS = 2,
}
impl HidControllerConnectionState {
    pub const CONTROLLER_STATE_CONNECTED: HidControllerConnectionState =
        HidControllerConnectionState(1);
}
impl HidControllerConnectionState {
    pub const CONTROLLER_STATE_WIRED: HidControllerConnectionState =
        HidControllerConnectionState(2);
}
impl ::core::ops::BitOr<HidControllerConnectionState> for HidControllerConnectionState {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        HidControllerConnectionState(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for HidControllerConnectionState {
    #[inline]
    fn bitor_assign(&mut self, rhs: HidControllerConnectionState) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<HidControllerConnectionState> for HidControllerConnectionState {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        HidControllerConnectionState(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for HidControllerConnectionState {
    #[inline]
    fn bitand_assign(&mut self, rhs: HidControllerConnectionState) {
        self.0 &= rhs.0;
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct HidControllerConnectionState(pub u32);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HidControllerID {
    CONTROLLER_PLAYER_1 = 0,
    CONTROLLER_PLAYER_2 = 1,
    CONTROLLER_PLAYER_3 = 2,
    CONTROLLER_PLAYER_4 = 3,
    CONTROLLER_PLAYER_5 = 4,
    CONTROLLER_PLAYER_6 = 5,
    CONTROLLER_PLAYER_7 = 6,
    CONTROLLER_PLAYER_8 = 7,
    CONTROLLER_HANDHELD = 8,
    CONTROLLER_UNKNOWN = 9,
    /// < Not an actual HID-sysmodule ID. Only for hidKeys*()/hidJoystickRead()/hidSixAxisSensorValuesRead()/hidGetControllerType()/hidGetControllerColors()/hidIsControllerConnected(). Automatically uses CONTROLLER_PLAYER_1 when connected, otherwise uses CONTROLLER_HANDHELD.
    CONTROLLER_P1_AUTO = 10,
}
/// < Default / Joy-Con held vertically.
pub const HidJoyHoldType_HidJoyHoldType_Default: HidJoyHoldType = 0;
/// < Joy-Con held horizontally with HID state orientation adjustment, see \ref HidControllerLayoutType.
pub const HidJoyHoldType_HidJoyHoldType_Horizontal: HidJoyHoldType = 1;
pub type HidJoyHoldType = u32;
#[repr(C)]
pub struct touchPosition {
    pub px: u32,
    pub py: u32,
    pub dx: u32,
    pub dy: u32,
    pub angle: u32,
}
#[test]
fn bindgen_test_layout_touchPosition() {
    assert_eq!(
        ::core::mem::size_of::<touchPosition>(),
        20usize,
        concat!("Size of: ", stringify!(touchPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<touchPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(touchPosition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).px as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(px)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).py as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(py)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).dx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).dy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<touchPosition>())).angle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(touchPosition),
            "::",
            stringify!(angle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoystickPosition {
    pub dx: s32,
    pub dy: s32,
}
#[test]
fn bindgen_test_layout_JoystickPosition() {
    assert_eq!(
        ::core::mem::size_of::<JoystickPosition>(),
        8usize,
        concat!("Size of: ", stringify!(JoystickPosition))
    );
    assert_eq!(
        ::core::mem::align_of::<JoystickPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(JoystickPosition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<JoystickPosition>())).dx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickPosition),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<JoystickPosition>())).dy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickPosition),
            "::",
            stringify!(dy)
        )
    );
}
#[repr(C)]
pub struct MousePosition {
    pub x: u32,
    pub y: u32,
    pub velocityX: u32,
    pub velocityY: u32,
    pub scrollVelocityX: u32,
    pub scrollVelocityY: u32,
}
#[test]
fn bindgen_test_layout_MousePosition() {
    assert_eq!(
        ::core::mem::size_of::<MousePosition>(),
        24usize,
        concat!("Size of: ", stringify!(MousePosition))
    );
    assert_eq!(
        ::core::mem::align_of::<MousePosition>(),
        4usize,
        concat!("Alignment of ", stringify!(MousePosition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).velocityX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(velocityX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).velocityY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(velocityY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).scrollVelocityX as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(scrollVelocityX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MousePosition>())).scrollVelocityY as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MousePosition),
            "::",
            stringify!(scrollVelocityY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HidVector {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_HidVector() {
    assert_eq!(
        ::core::mem::size_of::<HidVector>(),
        12usize,
        concat!("Size of: ", stringify!(HidVector))
    );
    assert_eq!(
        ::core::mem::align_of::<HidVector>(),
        4usize,
        concat!("Alignment of ", stringify!(HidVector))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVector>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVector),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVector>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVector),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVector>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVector),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SixAxisSensorValues {
    pub accelerometer: HidVector,
    pub gyroscope: HidVector,
    pub unk: HidVector,
    pub orientation: [HidVector; 3usize],
}
#[test]
fn bindgen_test_layout_SixAxisSensorValues() {
    assert_eq!(
        ::core::mem::size_of::<SixAxisSensorValues>(),
        72usize,
        concat!("Size of: ", stringify!(SixAxisSensorValues))
    );
    assert_eq!(
        ::core::mem::align_of::<SixAxisSensorValues>(),
        4usize,
        concat!("Alignment of ", stringify!(SixAxisSensorValues))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SixAxisSensorValues>())).accelerometer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(accelerometer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SixAxisSensorValues>())).gyroscope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(gyroscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SixAxisSensorValues>())).unk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(unk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SixAxisSensorValues>())).orientation as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SixAxisSensorValues),
            "::",
            stringify!(orientation)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_HidTouchScreenHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenHeader>(),
        40usize,
        concat!("Size of: ", stringify!(HidTouchScreenHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).timestampTicks as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).numEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).latestEntry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenHeader>())).maxEntryIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenHeader>())).timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenHeader),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenEntryHeader {
    pub timestamp: u64,
    pub numTouches: u64,
}
#[test]
fn bindgen_test_layout_HidTouchScreenEntryHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenEntryHeader>(),
        16usize,
        concat!("Size of: ", stringify!(HidTouchScreenEntryHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenEntryHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenEntryHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryHeader>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryHeader),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryHeader>())).numTouches as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryHeader),
            "::",
            stringify!(numTouches)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenEntryTouch {
    pub timestamp: u64,
    pub padding: u32,
    pub touchIndex: u32,
    pub x: u32,
    pub y: u32,
    pub diameterX: u32,
    pub diameterY: u32,
    pub angle: u32,
    pub padding_2: u32,
}
#[test]
fn bindgen_test_layout_HidTouchScreenEntryTouch() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenEntryTouch>(),
        40usize,
        concat!("Size of: ", stringify!(HidTouchScreenEntryTouch))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenEntryTouch>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenEntryTouch))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).padding as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).touchIndex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(touchIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).y as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).diameterX as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(diameterX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).diameterY as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(diameterY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).angle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidTouchScreenEntryTouch>())).padding_2 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntryTouch),
            "::",
            stringify!(padding_2)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreenEntry {
    pub header: HidTouchScreenEntryHeader,
    pub touches: [HidTouchScreenEntryTouch; 16usize],
    pub unk: u64,
}
#[test]
fn bindgen_test_layout_HidTouchScreenEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreenEntry>(),
        664usize,
        concat!("Size of: ", stringify!(HidTouchScreenEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreenEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreenEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntry>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntry),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntry>())).touches as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntry),
            "::",
            stringify!(touches)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreenEntry>())).unk as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreenEntry),
            "::",
            stringify!(unk)
        )
    );
}
#[repr(C)]
pub struct HidTouchScreen {
    pub header: HidTouchScreenHeader,
    pub entries: [HidTouchScreenEntry; 17usize],
    pub padding: [u8; 960usize],
}
#[test]
fn bindgen_test_layout_HidTouchScreen() {
    assert_eq!(
        ::core::mem::size_of::<HidTouchScreen>(),
        12288usize,
        concat!("Size of: ", stringify!(HidTouchScreen))
    );
    assert_eq!(
        ::core::mem::align_of::<HidTouchScreen>(),
        8usize,
        concat!("Alignment of ", stringify!(HidTouchScreen))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreen>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreen),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreen>())).entries as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreen),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidTouchScreen>())).padding as *const _ as usize },
        11328usize,
        concat!(
            "Offset of field: ",
            stringify!(HidTouchScreen),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct HidMouseHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidMouseHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidMouseHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidMouseHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidMouseHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidMouseHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).timestampTicks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).numEntries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).latestEntry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseHeader>())).maxEntryIndex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidMouseEntry {
    pub timestamp: u64,
    pub timestamp_2: u64,
    pub position: MousePosition,
    pub buttons: u64,
}
#[test]
fn bindgen_test_layout_HidMouseEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidMouseEntry>(),
        48usize,
        concat!("Size of: ", stringify!(HidMouseEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidMouseEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidMouseEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).timestamp_2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).position as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouseEntry>())).buttons as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouseEntry),
            "::",
            stringify!(buttons)
        )
    );
}
#[repr(C)]
pub struct HidMouse {
    pub header: HidMouseHeader,
    pub entries: [HidMouseEntry; 17usize],
    pub padding: [u8; 176usize],
}
#[test]
fn bindgen_test_layout_HidMouse() {
    assert_eq!(
        ::core::mem::size_of::<HidMouse>(),
        1024usize,
        concat!("Size of: ", stringify!(HidMouse))
    );
    assert_eq!(
        ::core::mem::align_of::<HidMouse>(),
        8usize,
        concat!("Alignment of ", stringify!(HidMouse))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouse>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouse),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouse>())).entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouse),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidMouse>())).padding as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(HidMouse),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct HidKeyboardHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidKeyboardHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidKeyboardHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidKeyboardHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidKeyboardHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidKeyboardHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidKeyboardHeader>())).timestampTicks as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardHeader>())).numEntries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardHeader>())).latestEntry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidKeyboardHeader>())).maxEntryIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidKeyboardEntry {
    pub timestamp: u64,
    pub timestamp_2: u64,
    pub modifier: u64,
    pub keys: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_HidKeyboardEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidKeyboardEntry>(),
        56usize,
        concat!("Size of: ", stringify!(HidKeyboardEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidKeyboardEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidKeyboardEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).timestamp_2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).modifier as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboardEntry>())).keys as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboardEntry),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
pub struct HidKeyboard {
    pub header: HidKeyboardHeader,
    pub entries: [HidKeyboardEntry; 17usize],
    pub padding: [u8; 40usize],
}
#[test]
fn bindgen_test_layout_HidKeyboard() {
    assert_eq!(
        ::core::mem::size_of::<HidKeyboard>(),
        1024usize,
        concat!("Size of: ", stringify!(HidKeyboard))
    );
    assert_eq!(
        ::core::mem::align_of::<HidKeyboard>(),
        8usize,
        concat!("Alignment of ", stringify!(HidKeyboard))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboard>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboard),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboard>())).entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboard),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidKeyboard>())).padding as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(HidKeyboard),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct HidControllerMAC {
    pub timestamp: u64,
    pub mac: [u8; 8usize],
    pub unk: u64,
    pub timestamp_2: u64,
}
#[test]
fn bindgen_test_layout_HidControllerMAC() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerMAC>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerMAC))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerMAC>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerMAC))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).mac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).unk as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(unk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerMAC>())).timestamp_2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerMAC),
            "::",
            stringify!(timestamp_2)
        )
    );
}
#[repr(C)]
pub struct HidControllerHeader {
    pub type_: u32,
    pub isHalf: u32,
    pub singleColorsDescriptor: u32,
    pub singleColorBody: u32,
    pub singleColorButtons: u32,
    pub splitColorsDescriptor: u32,
    pub leftColorBody: u32,
    pub leftColorButtons: u32,
    pub rightColorBody: u32,
    pub rightColorButtons: u32,
}
#[test]
fn bindgen_test_layout_HidControllerHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerHeader>(),
        40usize,
        concat!("Size of: ", stringify!(HidControllerHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(HidControllerHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerHeader>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerHeader>())).isHalf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(isHalf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).singleColorsDescriptor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(singleColorsDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).singleColorBody as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(singleColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).singleColorButtons as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(singleColorButtons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).splitColorsDescriptor as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(splitColorsDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).leftColorBody as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(leftColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).leftColorButtons as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(leftColorButtons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).rightColorBody as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(rightColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerHeader>())).rightColorButtons as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerHeader),
            "::",
            stringify!(rightColorButtons)
        )
    );
}
/// Info struct extracted from HidControllerHeader.
/// Color fields are zero when not set. This can happen even when the *Set fields are set to true.
#[repr(C)]
pub struct HidControllerColors {
    /// < Set to true when the below fields are valid.
    pub singleSet: bool,
    /// < RGBA Single Body Color
    pub singleColorBody: u32,
    /// < RGBA Single Buttons Color
    pub singleColorButtons: u32,
    /// < Set to true when the below fields are valid.
    pub splitSet: bool,
    /// < RGBA Left Body Color
    pub leftColorBody: u32,
    /// < RGBA Left Buttons Color
    pub leftColorButtons: u32,
    /// < RGBA Right Body Color
    pub rightColorBody: u32,
    /// < RGBA Right Buttons Color
    pub rightColorButtons: u32,
}
#[test]
fn bindgen_test_layout_HidControllerColors() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerColors>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerColors))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerColors>(),
        4usize,
        concat!("Alignment of ", stringify!(HidControllerColors))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerColors>())).singleSet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(singleSet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).singleColorBody as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(singleColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).singleColorButtons as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(singleColorButtons)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerColors>())).splitSet as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(splitSet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).leftColorBody as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(leftColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).leftColorButtons as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(leftColorButtons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).rightColorBody as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(rightColorBody)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerColors>())).rightColorButtons as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerColors),
            "::",
            stringify!(rightColorButtons)
        )
    );
}
#[repr(C)]
pub struct HidControllerLayoutHeader {
    pub timestampTicks: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidControllerLayoutHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerLayoutHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerLayoutHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerLayoutHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerLayoutHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).timestampTicks as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(timestampTicks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).numEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).latestEntry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerLayoutHeader>())).maxEntryIndex as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayoutHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidControllerInputEntry {
    pub timestamp: u64,
    pub timestamp_2: u64,
    pub buttons: u64,
    pub joysticks: [JoystickPosition; 2usize],
    pub connectionState: u64,
}
#[test]
fn bindgen_test_layout_HidControllerInputEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerInputEntry>(),
        48usize,
        concat!("Size of: ", stringify!(HidControllerInputEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerInputEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerInputEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).timestamp_2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).buttons as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).joysticks as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(joysticks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerInputEntry>())).connectionState as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerInputEntry),
            "::",
            stringify!(connectionState)
        )
    );
}
#[repr(C)]
pub struct HidControllerLayout {
    pub header: HidControllerLayoutHeader,
    pub entries: [HidControllerInputEntry; 17usize],
}
#[test]
fn bindgen_test_layout_HidControllerLayout() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerLayout>(),
        848usize,
        concat!("Size of: ", stringify!(HidControllerLayout))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerLayout))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerLayout>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayout),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidControllerLayout>())).entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerLayout),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
pub struct HidControllerSixAxisHeader {
    pub timestamp: u64,
    pub numEntries: u64,
    pub latestEntry: u64,
    pub maxEntryIndex: u64,
}
#[test]
fn bindgen_test_layout_HidControllerSixAxisHeader() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerSixAxisHeader>(),
        32usize,
        concat!("Size of: ", stringify!(HidControllerSixAxisHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerSixAxisHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerSixAxisHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).numEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).latestEntry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(latestEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisHeader>())).maxEntryIndex as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisHeader),
            "::",
            stringify!(maxEntryIndex)
        )
    );
}
#[repr(C)]
pub struct HidControllerSixAxisEntry {
    pub timestamp: u64,
    pub unk_1: u64,
    pub timestamp_2: u64,
    pub values: SixAxisSensorValues,
    pub unk_3: u64,
}
#[test]
fn bindgen_test_layout_HidControllerSixAxisEntry() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerSixAxisEntry>(),
        104usize,
        concat!("Size of: ", stringify!(HidControllerSixAxisEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerSixAxisEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerSixAxisEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).timestamp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).unk_1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(unk_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).timestamp_2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(timestamp_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).values as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisEntry>())).unk_3 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisEntry),
            "::",
            stringify!(unk_3)
        )
    );
}
#[repr(C)]
pub struct HidControllerSixAxisLayout {
    pub header: HidControllerSixAxisHeader,
    pub entries: [HidControllerSixAxisEntry; 17usize],
}
#[test]
fn bindgen_test_layout_HidControllerSixAxisLayout() {
    assert_eq!(
        ::core::mem::size_of::<HidControllerSixAxisLayout>(),
        1800usize,
        concat!("Size of: ", stringify!(HidControllerSixAxisLayout))
    );
    assert_eq!(
        ::core::mem::align_of::<HidControllerSixAxisLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(HidControllerSixAxisLayout))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisLayout>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisLayout),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidControllerSixAxisLayout>())).entries as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HidControllerSixAxisLayout),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C)]
pub struct HidController {
    pub header: HidControllerHeader,
    pub layouts: [HidControllerLayout; 7usize],
    pub sixaxis: [HidControllerSixAxisLayout; 6usize],
    pub unk_1: [u8; 64usize],
    pub macLeft: HidControllerMAC,
    pub macRight: HidControllerMAC,
    pub unk_2: [u8; 3576usize],
}
#[test]
fn bindgen_test_layout_HidController() {
    assert_eq!(
        ::core::mem::size_of::<HidController>(),
        20480usize,
        concat!("Size of: ", stringify!(HidController))
    );
    assert_eq!(
        ::core::mem::align_of::<HidController>(),
        8usize,
        concat!("Alignment of ", stringify!(HidController))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).layouts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).sixaxis as *const _ as usize },
        5976usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(sixaxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).unk_1 as *const _ as usize },
        16776usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(unk_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).macLeft as *const _ as usize },
        16840usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(macLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).macRight as *const _ as usize },
        16872usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(macRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidController>())).unk_2 as *const _ as usize },
        16904usize,
        concat!(
            "Offset of field: ",
            stringify!(HidController),
            "::",
            stringify!(unk_2)
        )
    );
}
#[repr(C)]
pub struct HidSharedMemory {
    pub header: [u8; 1024usize],
    pub touchscreen: HidTouchScreen,
    pub mouse: HidMouse,
    pub keyboard: HidKeyboard,
    pub unkSection1: [u8; 1024usize],
    pub unkSection2: [u8; 1024usize],
    pub unkSection3: [u8; 1024usize],
    pub unkSection4: [u8; 1024usize],
    pub unkSection5: [u8; 512usize],
    pub unkSection6: [u8; 512usize],
    pub unkSection7: [u8; 512usize],
    pub unkSection8: [u8; 2048usize],
    pub controllerSerials: [u8; 16384usize],
    pub controllers: [HidController; 10usize],
    pub unkSection9: [u8; 17920usize],
}
#[test]
fn bindgen_test_layout_HidSharedMemory() {
    assert_eq!(
        ::core::mem::size_of::<HidSharedMemory>(),
        262144usize,
        concat!("Size of: ", stringify!(HidSharedMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<HidSharedMemory>(),
        8usize,
        concat!("Alignment of ", stringify!(HidSharedMemory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).touchscreen as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(touchscreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).mouse as *const _ as usize },
        13312usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(mouse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).keyboard as *const _ as usize },
        14336usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(keyboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection1 as *const _ as usize },
        15360usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection2 as *const _ as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection3 as *const _ as usize },
        17408usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection4 as *const _ as usize },
        18432usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection5 as *const _ as usize },
        19456usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection6 as *const _ as usize },
        19968usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection7 as *const _ as usize },
        20480usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection8 as *const _ as usize },
        20992usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<HidSharedMemory>())).controllerSerials as *const _ as usize
        },
        23040usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(controllerSerials)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).controllers as *const _ as usize },
        39424usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(controllers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidSharedMemory>())).unkSection9 as *const _ as usize },
        244224usize,
        concat!(
            "Offset of field: ",
            stringify!(HidSharedMemory),
            "::",
            stringify!(unkSection9)
        )
    );
}
#[repr(C)]
pub struct HidVibrationDeviceInfo {
    pub unk_x0: u32,
    /// < 0x1 for left-joycon, 0x2 for right-joycon.
    pub unk_x4: u32,
}
#[test]
fn bindgen_test_layout_HidVibrationDeviceInfo() {
    assert_eq!(
        ::core::mem::size_of::<HidVibrationDeviceInfo>(),
        8usize,
        concat!("Size of: ", stringify!(HidVibrationDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<HidVibrationDeviceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(HidVibrationDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationDeviceInfo>())).unk_x0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationDeviceInfo),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationDeviceInfo>())).unk_x4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationDeviceInfo),
            "::",
            stringify!(unk_x4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HidVibrationValue {
    /// < Low Band amplitude. 1.0f: Max amplitude.
    pub amp_low: f32,
    /// < Low Band frequency in Hz.
    pub freq_low: f32,
    /// < High Band amplitude. 1.0f: Max amplitude.
    pub amp_high: f32,
    /// < High Band frequency in Hz.
    pub freq_high: f32,
}
#[test]
fn bindgen_test_layout_HidVibrationValue() {
    assert_eq!(
        ::core::mem::size_of::<HidVibrationValue>(),
        16usize,
        concat!("Size of: ", stringify!(HidVibrationValue))
    );
    assert_eq!(
        ::core::mem::align_of::<HidVibrationValue>(),
        4usize,
        concat!("Alignment of ", stringify!(HidVibrationValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).amp_low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(amp_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).freq_low as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(freq_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).amp_high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(amp_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HidVibrationValue>())).freq_high as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HidVibrationValue),
            "::",
            stringify!(freq_high)
        )
    );
}
extern "C" {
    pub fn hidInitialize() -> Result;
}
extern "C" {
    pub fn hidExit();
}
extern "C" {
    pub fn hidReset();
}
extern "C" {
    pub fn hidGetSessionService() -> *mut Service;
}
extern "C" {
    pub fn hidGetSharedmemAddr() -> *mut lang_items::c_void;
}
extern "C" {
    pub fn hidSetControllerLayout(id: HidControllerID, layoutType: HidControllerLayoutType);
}
extern "C" {
    pub fn hidGetControllerLayout(id: HidControllerID) -> HidControllerLayoutType;
}
extern "C" {
    pub fn hidGetControllerType(id: HidControllerID) -> HidControllerType;
}
extern "C" {
    pub fn hidGetControllerColors(id: HidControllerID, colors: *mut HidControllerColors);
}
extern "C" {
    pub fn hidIsControllerConnected(id: HidControllerID) -> bool;
}
extern "C" {
    pub fn hidScanInput();
}
extern "C" {
    pub fn hidKeysHeld(id: HidControllerID) -> u64;
}
extern "C" {
    pub fn hidKeysDown(id: HidControllerID) -> u64;
}
extern "C" {
    pub fn hidKeysUp(id: HidControllerID) -> u64;
}
extern "C" {
    pub fn hidMouseButtonsHeld() -> u64;
}
extern "C" {
    pub fn hidMouseButtonsDown() -> u64;
}
extern "C" {
    pub fn hidMouseButtonsUp() -> u64;
}
extern "C" {
    pub fn hidMouseRead(pos: *mut MousePosition);
}
extern "C" {
    pub fn hidKeyboardModifierHeld(modifier: HidKeyboardModifier) -> bool;
}
extern "C" {
    pub fn hidKeyboardModifierDown(modifier: HidKeyboardModifier) -> bool;
}
extern "C" {
    pub fn hidKeyboardModifierUp(modifier: HidKeyboardModifier) -> bool;
}
extern "C" {
    pub fn hidKeyboardHeld(key: HidKeyboardScancode) -> bool;
}
extern "C" {
    pub fn hidKeyboardDown(key: HidKeyboardScancode) -> bool;
}
extern "C" {
    pub fn hidKeyboardUp(key: HidKeyboardScancode) -> bool;
}
extern "C" {
    pub fn hidTouchCount() -> u32;
}
extern "C" {
    pub fn hidTouchRead(pos: *mut touchPosition, point_id: u32);
}
extern "C" {
    pub fn hidJoystickRead(
        pos: *mut JoystickPosition,
        id: HidControllerID,
        stick: HidControllerJoystick,
    );
}
extern "C" {
    pub fn hidSixAxisSensorValuesRead(
        values: *mut SixAxisSensorValues,
        id: HidControllerID,
        num_entries: u32,
    ) -> u32;
}
extern "C" {
    /// This can be used to check what CONTROLLER_P1_AUTO uses.
    /// Returns 0 when CONTROLLER_PLAYER_1 is connected, otherwise returns 1 for handheld-mode.
    pub fn hidGetHandheldMode() -> bool;
}
extern "C" {
    /// This is automatically called with CONTROLLER_PLAYER_{1-8} and CONTROLLER_HANDHELD in \ref hidInitialize.
    /// count must be <=10. Each entry in buf must be CONTROLLER_PLAYER_{1-8} or CONTROLLER_HANDHELD.
    pub fn hidSetSupportedNpadIdType(buf: *mut HidControllerID, count: usize) -> Result;
}
extern "C" {
    /// Sets which controller types are supported. This is automatically called with all types in \ref hidInitialize.
    pub fn hidSetSupportedNpadStyleSet(type_: HidControllerType) -> Result;
}
extern "C" {
    /// Gets an event with the specified autoclear for the input controller.
    /// The user *must* close the event when finished with it / before the app exits.
    /// This is signaled when the \ref hidGetControllerType output is updated for the controller.
    pub fn hidAcquireNpadStyleSetUpdateEventHandle(
        id: HidControllerID,
        event: *mut Event,
        autoclear: bool,
    ) -> Result;
}
extern "C" {
    /// Sets the hold-type, see \ref HidJoyHoldType.
    pub fn hidSetNpadJoyHoldType(type_: HidJoyHoldType) -> Result;
}
extern "C" {
    /// Use this if you want to use a single joy-con as a dedicated CONTROLLER_PLAYER_*.
    /// When used, both joy-cons in a pair should be used with this (CONTROLLER_PLAYER_1 and CONTROLLER_PLAYER_2 for example).
    /// id must be CONTROLLER_PLAYER_*.
    pub fn hidSetNpadJoyAssignmentModeSingleByDefault(id: HidControllerID) -> Result;
}
extern "C" {
    /// Use this if you want to use a pair of joy-cons as a single CONTROLLER_PLAYER_*. Only necessary if you want to use this mode in your application after \ref hidSetNpadJoyAssignmentModeSingleByDefault was used with this pair of joy-cons.
    /// Used automatically during app startup/exit for all controllers.
    /// When used, both joy-cons in a pair should be used with this (CONTROLLER_PLAYER_1 and CONTROLLER_PLAYER_2 for example).
    /// id must be CONTROLLER_PLAYER_*.
    pub fn hidSetNpadJoyAssignmentModeDual(id: HidControllerID) -> Result;
}
extern "C" {
    /// Merge two single joy-cons into a dual-mode controller. Use this after \ref hidSetNpadJoyAssignmentModeDual, when \ref hidSetNpadJoyAssignmentModeSingleByDefault was previously used (this includes using this manually at application exit).
    /// To be successful, id0/id1 must correspond to controller types TYPE_JOYCON_LEFT/TYPE_JOYCON_RIGHT, or TYPE_JOYCON_RIGHT/TYPE_JOYCON_LEFT.
    /// If successful, the id of the resulting dual controller is set to id0.
    pub fn hidMergeSingleJoyAsDualJoy(id0: HidControllerID, id1: HidControllerID) -> Result;
}
extern "C" {
    pub fn hidInitializeVibrationDevices(
        VibrationDeviceHandles: *mut u32,
        total_handles: usize,
        id: HidControllerID,
        type_: HidControllerType,
    ) -> Result;
}
extern "C" {
    /// Gets HidVibrationDeviceInfo for the specified VibrationDeviceHandle.
    pub fn hidGetVibrationDeviceInfo(
        VibrationDeviceHandle: *mut u32,
        VibrationDeviceInfo: *mut HidVibrationDeviceInfo,
    ) -> Result;
}
extern "C" {
    /// Send the VibrationValue to the specified VibrationDeviceHandle.
    pub fn hidSendVibrationValue(
        VibrationDeviceHandle: *mut u32,
        VibrationValue: *mut HidVibrationValue,
    ) -> Result;
}
extern "C" {
    /// Gets the current HidVibrationValue for the specified VibrationDeviceHandle.
    pub fn hidGetActualVibrationValue(
        VibrationDeviceHandle: *mut u32,
        VibrationValue: *mut HidVibrationValue,
    ) -> Result;
}
extern "C" {
    /// Sets whether vibration is allowed, this also affects the config displayed by System Settings.
    pub fn hidPermitVibration(flag: bool) -> Result;
}
extern "C" {
    /// Gets whether vibration is allowed.
    pub fn hidIsVibrationPermitted(flag: *mut bool) -> Result;
}
extern "C" {
    /// Send VibrationValues[index] to VibrationDeviceHandles[index], where count is the number of entries in the VibrationDeviceHandles/VibrationValues arrays.
    pub fn hidSendVibrationValues(
        VibrationDeviceHandles: *mut u32,
        VibrationValues: *mut HidVibrationValue,
        count: usize,
    ) -> Result;
}
extern "C" {
    /// Gets SixAxisSensorHandles. total_handles==2 can only be used with TYPE_JOYCON_PAIR.
    pub fn hidGetSixAxisSensorHandles(
        SixAxisSensorHandles: *mut u32,
        total_handles: usize,
        id: HidControllerID,
        type_: HidControllerType,
    ) -> Result;
}
extern "C" {
    /// Starts the SixAxisSensor for the specified handle.
    pub fn hidStartSixAxisSensor(SixAxisSensorHandle: u32) -> Result;
}
extern "C" {
    /// Stops the SixAxisSensor for the specified handle.
    pub fn hidStopSixAxisSensor(SixAxisSensorHandle: u32) -> Result;
}
#[repr(C, packed)]
pub struct IrsPackedMomentProcessorConfig {
    pub unk_x0: u64,
    pub unk_x8: u8,
    pub unk_x9: u8,
    pub unk_xa: u8,
    pub pad: [u8; 5usize],
    pub unk_x10: u16,
    pub unk_x12: u32,
    pub unk_x16: u16,
    pub unk_constant: u32,
    pub unk_x1c: u8,
    pub unk_x1d: u8,
    pub pad2: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_IrsPackedMomentProcessorConfig() {
    assert_eq!(
        ::core::mem::size_of::<IrsPackedMomentProcessorConfig>(),
        32usize,
        concat!("Size of: ", stringify!(IrsPackedMomentProcessorConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<IrsPackedMomentProcessorConfig>(),
        1usize,
        concat!("Alignment of ", stringify!(IrsPackedMomentProcessorConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x8 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x9 as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_xa as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_xa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).pad as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x10 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x12 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x16 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_constant as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_constant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x1c as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x1c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).unk_x1d as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(unk_x1d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedMomentProcessorConfig>())).pad2 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedMomentProcessorConfig),
            "::",
            stringify!(pad2)
        )
    );
}
#[repr(C)]
pub struct IrsImageTransferProcessorConfig {
    /// < IR Sensor exposure time in nanoseconds.
    pub exposure: u64,
    /// < Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    pub ir_leds: u32,
    /// < IR sensor signal's digital gain.
    pub digital_gain: u32,
    /// < Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    pub color_invert: u8,
    pub pad: [u8; 7usize],
    /// < IR Sensor resolution. 0: 240x320, 1: 120x160, 2: 60x80.
    pub sensor_res: u32,
}
#[test]
fn bindgen_test_layout_IrsImageTransferProcessorConfig() {
    assert_eq!(
        ::core::mem::size_of::<IrsImageTransferProcessorConfig>(),
        32usize,
        concat!("Size of: ", stringify!(IrsImageTransferProcessorConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<IrsImageTransferProcessorConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(IrsImageTransferProcessorConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).exposure as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).ir_leds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(ir_leds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).digital_gain as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(digital_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).color_invert as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(color_invert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).pad as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorConfig>())).sensor_res as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorConfig),
            "::",
            stringify!(sensor_res)
        )
    );
}
#[repr(C)]
pub struct IrsPackedImageTransferProcessorConfig {
    /// < IR Sensor exposure time in nanoseconds.
    pub exposure: u64,
    /// < Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    pub ir_leds: u8,
    /// < IR sensor signal's digital gain.
    pub digital_gain: u8,
    /// < Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    pub color_invert: u8,
    pub pad: [u8; 5usize],
    pub unk_constant: u32,
    /// < IR Sensor resolution. 0: 240x320, 1: 120x160, 2: 60x80.
    pub sensor_res: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_IrsPackedImageTransferProcessorConfig() {
    assert_eq!(
        ::core::mem::size_of::<IrsPackedImageTransferProcessorConfig>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(IrsPackedImageTransferProcessorConfig)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<IrsPackedImageTransferProcessorConfig>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(IrsPackedImageTransferProcessorConfig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).exposure as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(exposure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).ir_leds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(ir_leds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).digital_gain
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(digital_gain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).color_invert
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(color_invert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).pad as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).unk_constant
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(unk_constant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).sensor_res
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(sensor_res)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsPackedImageTransferProcessorConfig>())).pad2 as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsPackedImageTransferProcessorConfig),
            "::",
            stringify!(pad2)
        )
    );
}
#[repr(C, packed)]
pub struct IrsImageTransferProcessorState {
    pub unk_x0: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_IrsImageTransferProcessorState() {
    assert_eq!(
        ::core::mem::size_of::<IrsImageTransferProcessorState>(),
        16usize,
        concat!("Size of: ", stringify!(IrsImageTransferProcessorState))
    );
    assert_eq!(
        ::core::mem::align_of::<IrsImageTransferProcessorState>(),
        1usize,
        concat!("Alignment of ", stringify!(IrsImageTransferProcessorState))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<IrsImageTransferProcessorState>())).unk_x0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IrsImageTransferProcessorState),
            "::",
            stringify!(unk_x0)
        )
    );
}
extern "C" {
    pub fn irsInitialize() -> Result;
}
extern "C" {
    pub fn irsExit();
}
extern "C" {
    pub fn irsGetSessionService() -> *mut Service;
}
extern "C" {
    pub fn irsGetSharedmemAddr() -> *mut lang_items::c_void;
}
extern "C" {
    /// (De)activate the IR sensor, this is automatically used by irsExit(). Must be called after irsInitialize() to activate the IR sensor.
    pub fn irsActivateIrsensor(activate: bool) -> Result;
}
extern "C" {
    pub fn irsGetIrCameraHandle(IrCameraHandle: *mut u32, id: HidControllerID) -> Result;
}
extern "C" {
    /// @brief Start ImageTransferProcessor.
    /// @param[in] IrCameraHandle Camera handle.
    /// @param[in] config Input config.
    /// @param[in] size Work-buffer size, must be 0x1000-byte aligned.
    /// @note Do not use if already started.
    pub fn irsRunImageTransferProcessor(
        IrCameraHandle: u32,
        config: *mut IrsImageTransferProcessorConfig,
        size: usize,
    ) -> Result;
}
extern "C" {
    pub fn irsGetImageTransferProcessorState(
        IrCameraHandle: u32,
        buffer: *mut lang_items::c_void,
        size: usize,
        state: *mut IrsImageTransferProcessorState,
    ) -> Result;
}
extern "C" {
    /// Stop ImageTransferProcessor. Do not use if already stopped.
    /// \ref irsExit calls this with all IrCameraHandles which were not already used with \ref irsStopImageProcessor.
    pub fn irsStopImageProcessor(IrCameraHandle: u32) -> Result;
}
extern "C" {
    /// "Suspend" ImageTransferProcessor.
    /// TODO: What does this really do?
    pub fn irsSuspendImageProcessor(IrCameraHandle: u32) -> Result;
}
extern "C" {
    /// Gets the default configuration for Image Transfer mode.
    /// Defaults are exposure 300us, IR LEDs all ON, 8x digital gain, normal image and resolution 240 x 320.
    pub fn irsGetDefaultImageTransferProcessorConfig(config: *mut IrsImageTransferProcessorConfig);
}
/// < Japan, US and Europe
pub const PlSharedFontType_PlSharedFontType_Standard: PlSharedFontType = 0;
/// < Chinese Simplified
pub const PlSharedFontType_PlSharedFontType_ChineseSimplified: PlSharedFontType = 1;
/// < Extended Chinese Simplified
pub const PlSharedFontType_PlSharedFontType_ExtChineseSimplified: PlSharedFontType = 2;
/// < Chinese Traditional
pub const PlSharedFontType_PlSharedFontType_ChineseTraditional: PlSharedFontType = 3;
/// < Korean (Hangul)
pub const PlSharedFontType_PlSharedFontType_KO: PlSharedFontType = 4;
/// < Nintendo Extended. This font only has the special Nintendo-specific characters, which aren't available with the other fonts.
pub const PlSharedFontType_PlSharedFontType_NintendoExt: PlSharedFontType = 5;
/// < Total fonts supported by this enum.
pub const PlSharedFontType_PlSharedFontType_Total: PlSharedFontType = 6;
pub type PlSharedFontType = u32;
#[repr(C)]
pub struct PlFontData {
    pub type_: u32,
    pub offset: u32,
    pub size: u32,
    pub address: *mut lang_items::c_void,
}
#[test]
fn bindgen_test_layout_PlFontData() {
    assert_eq!(
        ::core::mem::size_of::<PlFontData>(),
        24usize,
        concat!("Size of: ", stringify!(PlFontData))
    );
    assert_eq!(
        ::core::mem::align_of::<PlFontData>(),
        8usize,
        concat!("Alignment of ", stringify!(PlFontData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PlFontData>())).address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PlFontData),
            "::",
            stringify!(address)
        )
    );
}
extern "C" {
    pub fn plInitialize() -> Result;
}
extern "C" {
    pub fn plExit();
}
extern "C" {
    pub fn plGetSharedmemAddr() -> *mut lang_items::c_void;
}
extern "C" {
    pub fn plGetSharedFontByType(font: *mut PlFontData, SharedFontType: u32) -> Result;
}
extern "C" {
    pub fn plGetSharedFont(
        LanguageCode: u64,
        fonts: *mut PlFontData,
        max_fonts: usize,
        total_fonts: *mut usize,
    ) -> Result;
}
#[repr(C)]
pub struct ViDisplay {
    pub display_id: u64,
    pub display_name: [lang_items::c_char; 64usize],
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_ViDisplay() {
    assert_eq!(
        ::core::mem::size_of::<ViDisplay>(),
        80usize,
        concat!("Size of: ", stringify!(ViDisplay))
    );
    assert_eq!(
        ::core::mem::align_of::<ViDisplay>(),
        8usize,
        concat!("Alignment of ", stringify!(ViDisplay))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViDisplay>())).display_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ViDisplay),
            "::",
            stringify!(display_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViDisplay>())).display_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ViDisplay),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViDisplay>())).initialized as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ViDisplay),
            "::",
            stringify!(initialized)
        )
    );
}
#[repr(C)]
pub struct ViLayer {
    pub layer_id: u64,
    pub igbp_binder_obj_id: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_ViLayer() {
    assert_eq!(
        ::core::mem::size_of::<ViLayer>(),
        16usize,
        concat!("Size of: ", stringify!(ViLayer))
    );
    assert_eq!(
        ::core::mem::align_of::<ViLayer>(),
        8usize,
        concat!("Alignment of ", stringify!(ViLayer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViLayer>())).layer_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ViLayer),
            "::",
            stringify!(layer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ViLayer>())).igbp_binder_obj_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ViLayer),
            "::",
            stringify!(igbp_binder_obj_id)
        )
    );
}
impl ViLayer {
    #[inline]
    pub fn initialized(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stray_layer(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stray_layer(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        initialized: bool,
        stray_layer: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u8 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let stray_layer: u8 = unsafe { ::core::mem::transmute(stray_layer) };
            stray_layer as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ViServiceType_ViServiceType_Default: ViServiceType = -1;
pub const ViServiceType_ViServiceType_Application: ViServiceType = 0;
pub const ViServiceType_ViServiceType_System: ViServiceType = 1;
pub const ViServiceType_ViServiceType_Manager: ViServiceType = 2;
pub type ViServiceType = i32;
pub const ViLayerFlags_ViLayerFlags_Default: ViLayerFlags = 1;
/// Used by viCreateLayer when CreateStrayLayer is used internally.
pub type ViLayerFlags = u32;
pub const ViScalingMode_ViScalingMode_Default: ViScalingMode = 2;
/// Used with viSetLayerScalingMode.
pub type ViScalingMode = u32;
extern "C" {
    pub fn viInitialize(service_type: ViServiceType) -> Result;
}
extern "C" {
    pub fn viExit();
}
extern "C" {
    pub fn viGetSession_IApplicationDisplayService() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_IHOSBinderDriverRelay() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_ISystemDisplayService() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_IManagerDisplayService() -> *mut Service;
}
extern "C" {
    pub fn viGetSession_IHOSBinderDriverIndirect() -> *mut Service;
}
extern "C" {
    pub fn viOpenDisplay(
        display_name: *const lang_items::c_char,
        display: *mut ViDisplay,
    ) -> Result;
}
extern "C" {
    pub fn viCloseDisplay(display: *mut ViDisplay) -> Result;
}
extern "C" {
    pub fn viGetDisplayResolution(
        display: *mut ViDisplay,
        width: *mut u64,
        height: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn viGetDisplayVsyncEvent(display: *mut ViDisplay, event_out: *mut Event) -> Result;
}
extern "C" {
    pub fn viCreateLayer(display: *const ViDisplay, layer: *mut ViLayer) -> Result;
}
extern "C" {
    pub fn viCreateManagedLayer(
        display: *const ViDisplay,
        layer_flags: ViLayerFlags,
        aruid: u64,
        layer_id: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn viCloseLayer(layer: *mut ViLayer) -> Result;
}
extern "C" {
    pub fn viSetLayerScalingMode(layer: *mut ViLayer, scaling_mode: ViScalingMode) -> Result;
}
extern "C" {
    pub fn nvInitialize() -> Result;
}
extern "C" {
    pub fn nvExit();
}
pub const NvEventId_NvEventId_Gpu_SmException_BptIntReport: NvEventId = 1;
pub const NvEventId_NvEventId_Gpu_SmException_BptPauseReport: NvEventId = 2;
pub const NvEventId_NvEventId_Gpu_ErrorNotifier: NvEventId = 3;
pub const NvEventId_NvEventId_CtrlGpu_ErrorEventHandle: NvEventId = 1;
pub const NvEventId_NvEventId_CtrlGpu_Unknown: NvEventId = 2;
pub type NvEventId = u32;
extern "C" {
    pub fn nvOpen(fd: *mut u32, devicepath: *const lang_items::c_char) -> Result;
}
extern "C" {
    pub fn nvIoctl(fd: u32, request: u32, argp: *mut lang_items::c_void) -> Result;
}
extern "C" {
    pub fn nvIoctl2(
        fd: u32,
        request: u32,
        argp: *mut lang_items::c_void,
        inbuf: *const lang_items::c_void,
        inbuf_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn nvClose(fd: u32) -> Result;
}
extern "C" {
    pub fn nvQueryEvent(fd: u32, event_id: u32, event_out: *mut Event) -> Result;
}
extern "C" {
    pub fn nvConvertError(rc: lang_items::c_int) -> Result;
}
extern "C" {
    pub fn nifmInitialize() -> Result;
}
extern "C" {
    pub fn nifmExit();
}
extern "C" {
    pub fn nifmGetCurrentIpAddress(out: *mut u32) -> Result;
}
#[repr(C)]
pub struct NsApplicationControlData {
    pub nacp: NacpStruct,
    pub icon: [u8; 131072usize],
}
#[test]
fn bindgen_test_layout_NsApplicationControlData() {
    assert_eq!(
        ::core::mem::size_of::<NsApplicationControlData>(),
        147456usize,
        concat!("Size of: ", stringify!(NsApplicationControlData))
    );
    assert_eq!(
        ::core::mem::align_of::<NsApplicationControlData>(),
        8usize,
        concat!("Alignment of ", stringify!(NsApplicationControlData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationControlData>())).nacp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationControlData),
            "::",
            stringify!(nacp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationControlData>())).icon as *const _ as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationControlData),
            "::",
            stringify!(icon)
        )
    );
}
#[repr(C)]
pub struct NsApplicationContentMetaStatus {
    pub title_type: u8,
    pub storageID: u8,
    pub unk_x02: u8,
    pub padding: u8,
    pub title_version: u32,
    pub titleID: u64,
}
#[test]
fn bindgen_test_layout_NsApplicationContentMetaStatus() {
    assert_eq!(
        ::core::mem::size_of::<NsApplicationContentMetaStatus>(),
        16usize,
        concat!("Size of: ", stringify!(NsApplicationContentMetaStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<NsApplicationContentMetaStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(NsApplicationContentMetaStatus))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).title_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(title_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).storageID as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(storageID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).unk_x02 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(unk_x02)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).padding as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).title_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(title_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsApplicationContentMetaStatus>())).titleID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationContentMetaStatus),
            "::",
            stringify!(titleID)
        )
    );
}
#[repr(C)]
pub struct NsApplicationRecord {
    pub titleID: u64,
    pub type_: u8,
    pub unk_x09: u8,
    pub unk_x0A: [u8; 6usize],
    pub unk_x10: u8,
    pub unk_x11: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_NsApplicationRecord() {
    assert_eq!(
        ::core::mem::size_of::<NsApplicationRecord>(),
        24usize,
        concat!("Size of: ", stringify!(NsApplicationRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<NsApplicationRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(NsApplicationRecord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).titleID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x09 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x09)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x0A as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x0A)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsApplicationRecord>())).unk_x11 as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(NsApplicationRecord),
            "::",
            stringify!(unk_x11)
        )
    );
}
#[repr(C)]
pub struct NsLaunchProperties {
    pub titleID: u64,
    pub version: u32,
    pub storageID: u8,
    pub index: u8,
    pub is_application: u8,
}
#[test]
fn bindgen_test_layout_NsLaunchProperties() {
    assert_eq!(
        ::core::mem::size_of::<NsLaunchProperties>(),
        16usize,
        concat!("Size of: ", stringify!(NsLaunchProperties))
    );
    assert_eq!(
        ::core::mem::align_of::<NsLaunchProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(NsLaunchProperties))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).titleID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(titleID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).storageID as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(storageID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsLaunchProperties>())).index as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NsLaunchProperties>())).is_application as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(NsLaunchProperties),
            "::",
            stringify!(is_application)
        )
    );
}
pub const NsShellEvent_NsShellEvent_None: NsShellEvent = 0;
pub const NsShellEvent_NsShellEvent_Exit: NsShellEvent = 1;
pub const NsShellEvent_NsShellEvent_Start: NsShellEvent = 2;
pub const NsShellEvent_NsShellEvent_Crash: NsShellEvent = 3;
pub const NsShellEvent_NsShellEvent_Debug: NsShellEvent = 4;
pub type NsShellEvent = u32;
#[repr(C)]
pub struct NsShellEventInfo {
    pub event: NsShellEvent,
    pub process_id: u64,
}
#[test]
fn bindgen_test_layout_NsShellEventInfo() {
    assert_eq!(
        ::core::mem::size_of::<NsShellEventInfo>(),
        16usize,
        concat!("Size of: ", stringify!(NsShellEventInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NsShellEventInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NsShellEventInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsShellEventInfo>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NsShellEventInfo),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NsShellEventInfo>())).process_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NsShellEventInfo),
            "::",
            stringify!(process_id)
        )
    );
}
extern "C" {
    pub fn nsInitialize() -> Result;
}
extern "C" {
    pub fn nsExit();
}
extern "C" {
    pub fn nsListApplicationRecord(
        buffer: *mut NsApplicationRecord,
        size: usize,
        entry_offset: usize,
        out_entrycount: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn nsListApplicationContentMetaStatus(
        titleID: u64,
        index: u32,
        buffer: *mut NsApplicationContentMetaStatus,
        size: usize,
        out_entrycount: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn nsGetApplicationControlData(
        flag: u8,
        titleID: u64,
        buffer: *mut NsApplicationControlData,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    /// @brief Returns the total storage capacity (used + free) from content manager services.
    /// @param storage_id Specified FsStorageId. (Must be FsStorageId_SdCard)
    /// @param size Pointer to output the total storage size to.
    pub fn nsGetTotalSpaceSize(storage_id: FsStorageId, size: *mut u64) -> Result;
}
extern "C" {
    /// @brief Returns the available storage capacity from content manager services.
    /// @param storage_id Specified FsStorageId. (Must be FsStorageId_SdCard)
    /// @param size Pointer to output the free storage size to.
    pub fn nsGetFreeSpaceSize(storage_id: FsStorageId, size: *mut u64) -> Result;
}
extern "C" {
    pub fn nsvmInitialize() -> Result;
}
extern "C" {
    pub fn nsvmExit();
}
extern "C" {
    pub fn nsvmNeedsUpdateVulnerability(out: *mut bool) -> Result;
}
extern "C" {
    pub fn nsvmGetSafeSystemVersion(out: *mut u16) -> Result;
}
extern "C" {
    pub fn nsdevInitialize() -> Result;
}
extern "C" {
    pub fn nsdevExit();
}
extern "C" {
    pub fn nsdevLaunchProgram(
        out_pid: *mut u64,
        properties: *const NsLaunchProperties,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn nsdevTerminateProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn nsdevTerminateProgram(tid: u64) -> Result;
}
extern "C" {
    pub fn nsdevGetShellEvent(out: *mut Event) -> Result;
}
extern "C" {
    pub fn nsdevGetShellEventInfo(out: *mut NsShellEventInfo) -> Result;
}
extern "C" {
    pub fn nsdevTerminateApplication() -> Result;
}
extern "C" {
    pub fn nsdevPrepareLaunchProgramFromHost(
        out: *mut NsLaunchProperties,
        path: *const lang_items::c_char,
        path_len: usize,
    ) -> Result;
}
extern "C" {
    pub fn nsdevLaunchApplication(out_pid: *mut u64, app_title_id: u64, flags: u32) -> Result;
}
extern "C" {
    pub fn nsdevLaunchApplicationWithStorageId(
        out_pid: *mut u64,
        app_title_id: u64,
        flags: u32,
        app_storage_id: u8,
        patch_storage_id: u8,
    ) -> Result;
}
extern "C" {
    pub fn nsdevIsSystemMemoryResourceLimitBoosted(out: *mut bool) -> Result;
}
extern "C" {
    pub fn nsdevGetRunningApplicationProcessId(out_pid: *mut u64) -> Result;
}
extern "C" {
    pub fn nsdevSetCurrentApplicationRightsEnvironmentCanBeActive(can_be_active: bool) -> Result;
}
#[repr(C)]
pub struct LoaderProgramInfo {
    pub main_thread_priority: u8,
    pub default_cpu_id: u8,
    pub application_type: u16,
    pub main_thread_stack_size: u32,
    pub title_id: u64,
    pub acid_sac_size: u32,
    pub aci0_sac_size: u32,
    pub acid_fac_size: u32,
    pub aci0_fah_size: u32,
    pub ac_buffer: [u8; 992usize],
}
#[test]
fn bindgen_test_layout_LoaderProgramInfo() {
    assert_eq!(
        ::core::mem::size_of::<LoaderProgramInfo>(),
        1024usize,
        concat!("Size of: ", stringify!(LoaderProgramInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<LoaderProgramInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(LoaderProgramInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).main_thread_priority as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(main_thread_priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).default_cpu_id as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(default_cpu_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).application_type as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(application_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).main_thread_stack_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(main_thread_stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderProgramInfo>())).title_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(title_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).acid_sac_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(acid_sac_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).aci0_sac_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(aci0_sac_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).acid_fac_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(acid_fac_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<LoaderProgramInfo>())).aci0_fah_size as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(aci0_fah_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderProgramInfo>())).ac_buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderProgramInfo),
            "::",
            stringify!(ac_buffer)
        )
    );
}
#[repr(C)]
pub struct LoaderModuleInfo {
    pub base_address: u64,
    pub size: u64,
    pub build_id: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_LoaderModuleInfo() {
    assert_eq!(
        ::core::mem::size_of::<LoaderModuleInfo>(),
        48usize,
        concat!("Size of: ", stringify!(LoaderModuleInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<LoaderModuleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(LoaderModuleInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderModuleInfo>())).base_address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderModuleInfo),
            "::",
            stringify!(base_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderModuleInfo>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderModuleInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LoaderModuleInfo>())).build_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LoaderModuleInfo),
            "::",
            stringify!(build_id)
        )
    );
}
extern "C" {
    pub fn ldrShellInitialize() -> Result;
}
extern "C" {
    pub fn ldrShellExit();
}
extern "C" {
    pub fn ldrDmntInitialize() -> Result;
}
extern "C" {
    pub fn ldrDmntExit();
}
extern "C" {
    pub fn ldrPmInitialize() -> Result;
}
extern "C" {
    pub fn ldrPmExit();
}
extern "C" {
    pub fn ldrShellAddTitleToLaunchQueue(
        tid: u64,
        args: *const lang_items::c_void,
        args_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn ldrShellClearLaunchQueue() -> Result;
}
extern "C" {
    pub fn ldrDmntAddTitleToLaunchQueue(
        tid: u64,
        args: *const lang_items::c_void,
        args_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn ldrDmntClearLaunchQueue() -> Result;
}
extern "C" {
    pub fn ldrDmntGetModuleInfos(
        pid: u64,
        out_module_infos: *mut LoaderModuleInfo,
        out_size: usize,
        num_out: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmCreateProcess(
        flags: u64,
        launch_index: u64,
        reslimit_h: Handle,
        out_process_h: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmGetProgramInfo(
        title_id: u64,
        storage_id: FsStorageId,
        out_program_info: *mut LoaderProgramInfo,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmRegisterTitle(
        title_id: u64,
        storage_id: FsStorageId,
        out_index: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn ldrPmUnregisterTitle(launch_index: u64) -> Result;
}
extern "C" {
    pub fn ldrRoInitialize() -> Result;
}
extern "C" {
    pub fn ldrRoExit();
}
extern "C" {
    pub fn roDmntInitialize() -> Result;
}
extern "C" {
    pub fn roDmntExit();
}
extern "C" {
    pub fn ldrRoLoadNro(
        out_address: *mut u64,
        nro_address: u64,
        nro_size: u64,
        bss_address: u64,
        bss_size: u64,
    ) -> Result;
}
extern "C" {
    pub fn ldrRoUnloadNro(nro_address: u64) -> Result;
}
extern "C" {
    pub fn ldrRoLoadNrr(nrr_address: u64, nrr_size: u64) -> Result;
}
extern "C" {
    pub fn ldrRoUnloadNrr(nrr_address: u64) -> Result;
}
extern "C" {
    pub fn roDmntGetModuleInfos(
        pid: u64,
        out_module_infos: *mut LoaderModuleInfo,
        out_size: usize,
        num_out: *mut u32,
    ) -> Result;
}
pub const PmLaunchFlag_PmLaunchFlag_None: PmLaunchFlag = 0;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnExit: PmLaunchFlag = 1;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnStart: PmLaunchFlag = 2;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnCrash: PmLaunchFlag = 4;
pub const PmLaunchFlag_PmLaunchFlag_SignalOnDebug: PmLaunchFlag = 8;
pub const PmLaunchFlag_PmLaunchFlag_StartSuspended: PmLaunchFlag = 16;
pub const PmLaunchFlag_PmLaunchFlag_DisableAslr: PmLaunchFlag = 32;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnExit: PmLaunchFlag = 1;
pub const PmLaunchFlag_PmLaunchFlagOld_StartSuspended: PmLaunchFlag = 2;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnCrash: PmLaunchFlag = 4;
pub const PmLaunchFlag_PmLaunchFlagOld_DisableAslr: PmLaunchFlag = 8;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnDebug: PmLaunchFlag = 16;
pub const PmLaunchFlag_PmLaunchFlagOld_SignalOnStart: PmLaunchFlag = 32;
pub type PmLaunchFlag = u32;
pub const PmProcessEvent_PmProcessEvent_None: PmProcessEvent = 0;
pub const PmProcessEvent_PmProcessEvent_Exit: PmProcessEvent = 1;
pub const PmProcessEvent_PmProcessEvent_Start: PmProcessEvent = 2;
pub const PmProcessEvent_PmProcessEvent_Crash: PmProcessEvent = 3;
pub const PmProcessEvent_PmProcessEvent_DebugStart: PmProcessEvent = 4;
pub const PmProcessEvent_PmProcessEvent_DebugBreak: PmProcessEvent = 5;
pub type PmProcessEvent = u32;
#[repr(C)]
pub struct PmProcessEventInfo {
    pub event: PmProcessEvent,
    pub process_id: u64,
}
#[test]
fn bindgen_test_layout_PmProcessEventInfo() {
    assert_eq!(
        ::core::mem::size_of::<PmProcessEventInfo>(),
        16usize,
        concat!("Size of: ", stringify!(PmProcessEventInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PmProcessEventInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PmProcessEventInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PmProcessEventInfo>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PmProcessEventInfo),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PmProcessEventInfo>())).process_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PmProcessEventInfo),
            "::",
            stringify!(process_id)
        )
    );
}
extern "C" {
    pub fn pmdmntInitialize() -> Result;
}
extern "C" {
    pub fn pmdmntExit();
}
extern "C" {
    pub fn pminfoInitialize() -> Result;
}
extern "C" {
    pub fn pminfoExit();
}
extern "C" {
    pub fn pmshellInitialize() -> Result;
}
extern "C" {
    pub fn pmshellExit();
}
extern "C" {
    pub fn pmdmntGetDebugProcesses(
        out_count: *mut u32,
        out_pids: *mut u64,
        max_pids: usize,
    ) -> Result;
}
extern "C" {
    pub fn pmdmntStartProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn pmdmntGetTitlePid(pid_out: *mut u64, title_id: u64) -> Result;
}
extern "C" {
    pub fn pmdmntEnableDebugForTitleId(handle_out: *mut Handle, title_id: u64) -> Result;
}
extern "C" {
    pub fn pmdmntGetApplicationPid(pid_out: *mut u64) -> Result;
}
extern "C" {
    pub fn pmdmntEnableDebugForApplication(handle_out: *mut Handle) -> Result;
}
extern "C" {
    pub fn pmdmntDisableDebug() -> Result;
}
extern "C" {
    pub fn pminfoGetTitleId(title_id_out: *mut u64, pid: u64) -> Result;
}
extern "C" {
    pub fn pmshellLaunchProcess(
        launch_flags: u32,
        titleID: u64,
        storageID: u64,
        pid: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn pmshellTerminateProcessByProcessId(processID: u64) -> Result;
}
extern "C" {
    pub fn pmshellTerminateProcessByTitleId(titleID: u64) -> Result;
}
extern "C" {
    pub fn pmshellGetProcessEvent(out: *mut Event) -> Result;
}
extern "C" {
    pub fn pmshellGetProcessEventInfo(out: *mut PmProcessEventInfo) -> Result;
}
extern "C" {
    pub fn pmshellFinalizeDeadProcess(pid: u64) -> Result;
}
extern "C" {
    pub fn pmshellClearProcessExceptionOccurred(pid: u64) -> Result;
}
extern "C" {
    pub fn pmshellNotifyBootFinished() -> Result;
}
extern "C" {
    pub fn pmshellGetApplicationPid(pid_out: *mut u64) -> Result;
}
extern "C" {
    pub fn pmshellBoostSystemMemoryResourceLimit(boost_size: u64) -> Result;
}
pub const ColorSetId_ColorSetId_Light: ColorSetId = 0;
pub const ColorSetId_ColorSetId_Dark: ColorSetId = 1;
pub type ColorSetId = u32;
/// < Japanese
pub const SetLanguage_SetLanguage_JA: SetLanguage = 0;
/// < US English ("AmericanEnglish")
pub const SetLanguage_SetLanguage_ENUS: SetLanguage = 1;
/// < French
pub const SetLanguage_SetLanguage_FR: SetLanguage = 2;
/// < German
pub const SetLanguage_SetLanguage_DE: SetLanguage = 3;
/// < Italian
pub const SetLanguage_SetLanguage_IT: SetLanguage = 4;
/// < Spanish
pub const SetLanguage_SetLanguage_ES: SetLanguage = 5;
/// < Simplified Chinese ("Chinese")
pub const SetLanguage_SetLanguage_ZHCN: SetLanguage = 6;
/// < Korean
pub const SetLanguage_SetLanguage_KO: SetLanguage = 7;
/// < Dutch
pub const SetLanguage_SetLanguage_NL: SetLanguage = 8;
/// < Portuguese
pub const SetLanguage_SetLanguage_PT: SetLanguage = 9;
/// < Russian
pub const SetLanguage_SetLanguage_RU: SetLanguage = 10;
/// < Traditional Chinese ("Taiwanese")
pub const SetLanguage_SetLanguage_ZHTW: SetLanguage = 11;
/// < GB English ("BritishEnglish")
pub const SetLanguage_SetLanguage_ENGB: SetLanguage = 12;
/// < CA French ("CanadianFrench")
pub const SetLanguage_SetLanguage_FRCA: SetLanguage = 13;
/// < "LatinAmericanSpanish"
pub const SetLanguage_SetLanguage_ES419: SetLanguage = 14;
/// < Total languages supported by this enum.
pub const SetLanguage_SetLanguage_Total: SetLanguage = 15;
/// IDs for Language.
pub type SetLanguage = u32;
/// < Japan
pub const SetRegion_SetRegion_JPN: SetRegion = 0;
/// < The Americas
pub const SetRegion_SetRegion_USA: SetRegion = 1;
/// < Europe
pub const SetRegion_SetRegion_EUR: SetRegion = 2;
/// < Australia/New Zealand
pub const SetRegion_SetRegion_AUS: SetRegion = 3;
/// Region codes.
pub type SetRegion = u32;
pub const SetSysFlag_SetSysFlag_LockScreen: SetSysFlag = 7;
pub const SetSysFlag_SetSysFlag_ConsoleInformationUpload: SetSysFlag = 25;
pub const SetSysFlag_SetSysFlag_AutomaticApplicationDownload: SetSysFlag = 27;
pub const SetSysFlag_SetSysFlag_Quest: SetSysFlag = 47;
pub const SetSysFlag_SetSysFlag_Usb30Enable: SetSysFlag = 65;
pub const SetSysFlag_SetSysFlag_NfcEnable: SetSysFlag = 69;
pub const SetSysFlag_SetSysFlag_WirelessLanEnable: SetSysFlag = 73;
pub const SetSysFlag_SetSysFlag_BluetoothEnable: SetSysFlag = 88;
pub const SetSysFlag_SetSysFlag_AutoUpdateEnable: SetSysFlag = 95;
pub const SetSysFlag_SetSysFlag_BatteryPercentage: SetSysFlag = 99;
pub const SetSysFlag_SetSysFlag_ExternalRtcReset: SetSysFlag = 101;
pub const SetSysFlag_SetSysFlag_UsbFullKeyEnable: SetSysFlag = 103;
pub const SetSysFlag_SetSysFlag_BluetoothAfhEnable: SetSysFlag = 111;
pub const SetSysFlag_SetSysFlag_BluetoothBoostEnable: SetSysFlag = 113;
pub const SetSysFlag_SetSysFlag_InRepairProcessEnable: SetSysFlag = 115;
pub const SetSysFlag_SetSysFlag_HeadphoneVolumeUpdate: SetSysFlag = 117;
pub const SetSysFlag_SetSysFlag_RequiresRunRepairTimeReviser: SetSysFlag = 141;
/// Command IDs for setsysGetFlag/setsysSetFlag.
pub type SetSysFlag = u32;
/// Structure returned by \ref setsysGetFirmwareVersion
#[repr(C)]
pub struct SetSysFirmwareVersion {
    pub major: u8,
    pub minor: u8,
    pub micro: u8,
    pub padding1: u8,
    pub revision_major: u8,
    pub revision_minor: u8,
    pub padding2: u8,
    pub padding3: u8,
    pub platform: [lang_items::c_char; 32usize],
    pub version_hash: [lang_items::c_char; 64usize],
    pub display_version: [lang_items::c_char; 24usize],
    pub display_title: [lang_items::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_SetSysFirmwareVersion() {
    assert_eq!(
        ::core::mem::size_of::<SetSysFirmwareVersion>(),
        256usize,
        concat!("Size of: ", stringify!(SetSysFirmwareVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<SetSysFirmwareVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(SetSysFirmwareVersion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).micro as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(micro)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).padding1 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).revision_major as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(revision_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).revision_minor as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(revision_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).padding2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).padding3 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SetSysFirmwareVersion>())).platform as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(platform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).version_hash as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(version_hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).display_version as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(display_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SetSysFirmwareVersion>())).display_title as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SetSysFirmwareVersion),
            "::",
            stringify!(display_title)
        )
    );
}
extern "C" {
    pub fn setInitialize() -> Result;
}
extern "C" {
    pub fn setExit();
}
extern "C" {
    /// Converts LanguageCode to Language.
    pub fn setMakeLanguage(LanguageCode: u64, Language: *mut s32) -> Result;
}
extern "C" {
    /// Converts Language to LanguageCode.
    pub fn setMakeLanguageCode(Language: s32, LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Gets the current system LanguageCode.
    /// Normally this should be used instead of \ref setGetLanguageCode.
    /// LanguageCode is a string, see here: https://switchbrew.org/wiki/Settings_services#LanguageCode
    pub fn setGetSystemLanguage(LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Gets the current LanguageCode, \ref setGetSystemLanguage should be used instead normally.
    pub fn setGetLanguageCode(LanguageCode: *mut u64) -> Result;
}
extern "C" {
    /// Gets available LanguageCodes.
    /// On system-version <4.0.0, max_entries is set to the output from \ref setGetAvailableLanguageCodeCount if max_entries is larger than that.
    pub fn setGetAvailableLanguageCodes(
        total_entries: *mut s32,
        LanguageCodes: *mut u64,
        max_entries: usize,
    ) -> Result;
}
extern "C" {
    /// Gets total available LanguageCodes.
    /// Output total is overridden with value 0 if the total is <0.
    pub fn setGetAvailableLanguageCodeCount(total: *mut s32) -> Result;
}
extern "C" {
    /// Gets the RegionCode.
    pub fn setGetRegionCode(out: *mut SetRegion) -> Result;
}
extern "C" {
    pub fn setsysInitialize() -> Result;
}
extern "C" {
    pub fn setsysExit();
}
extern "C" {
    /// Gets the current system theme.
    pub fn setsysGetColorSetId(out: *mut ColorSetId) -> Result;
}
extern "C" {
    /// Sets the current system theme.
    pub fn setsysSetColorSetId(id: ColorSetId) -> Result;
}
extern "C" {
    /// @brief Gets the size of a settings item value.
    /// @param out Pointer to output the size to.
    pub fn setsysGetSettingsItemValueSize(
        name: *const lang_items::c_char,
        item_key: *const lang_items::c_char,
        size_out: *mut u64,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the value of a settings item.
    /// @param out Pointer to output the value to.
    pub fn setsysGetSettingsItemValue(
        name: *const lang_items::c_char,
        item_key: *const lang_items::c_char,
        value_out: *mut lang_items::c_void,
        value_out_size: usize,
    ) -> Result;
}
extern "C" {
    /// @brief Gets the system's serial number.
    /// @param serial Pointer to output the serial to. (The buffer size needs to be at least 0x19 bytes)
    pub fn setsysGetSerialNumber(serial: *mut lang_items::c_char) -> Result;
}
extern "C" {
    /// @brief Gets the status of the specified settings flag.
    /// @param flag The specified settings flag.
    /// @param out Output pointer for the status.
    pub fn setsysGetFlag(flag: SetSysFlag, out: *mut bool) -> Result;
}
extern "C" {
    /// @brief Enables/disables the specified settings flag.
    /// @param flag The specified settings flag.
    /// @param enable To enable/disable the flag.
    pub fn setsysSetFlag(flag: SetSysFlag, enable: bool) -> Result;
}
extern "C" {
    /// @brief Gets the system firmware version.
    /// @param out Firmware version to populate.
    pub fn setsysGetFirmwareVersion(out: *mut SetSysFirmwareVersion) -> Result;
}
extern "C" {
    /// @brief Gets an event that settings will signal on flag change.
    /// @param out Event to bind. Output event will have autoclear=false.
    pub fn setsysBindFatalDirtyFlagEvent(out: *mut Event) -> Result;
}
extern "C" {
    /// @brief Gets the settings flags that have changed.
    /// @param flags_0 Pointer to populate with first 64 flags.
    /// @param flags_0 Pointer to populate with second 64 flags.
    pub fn setsysGetFatalDirtyFlags(flags_0: *mut u64, flags_1: *mut u64) -> Result;
}
#[repr(C)]
pub struct LrLocationResolver {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_LrLocationResolver() {
    assert_eq!(
        ::core::mem::size_of::<LrLocationResolver>(),
        12usize,
        concat!("Size of: ", stringify!(LrLocationResolver))
    );
    assert_eq!(
        ::core::mem::align_of::<LrLocationResolver>(),
        4usize,
        concat!("Alignment of ", stringify!(LrLocationResolver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LrLocationResolver>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LrLocationResolver),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct LrRegisteredLocationResolver {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_LrRegisteredLocationResolver() {
    assert_eq!(
        ::core::mem::size_of::<LrRegisteredLocationResolver>(),
        12usize,
        concat!("Size of: ", stringify!(LrRegisteredLocationResolver))
    );
    assert_eq!(
        ::core::mem::align_of::<LrRegisteredLocationResolver>(),
        4usize,
        concat!("Alignment of ", stringify!(LrRegisteredLocationResolver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<LrRegisteredLocationResolver>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LrRegisteredLocationResolver),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    pub fn lrInitialize() -> Result;
}
extern "C" {
    pub fn lrExit();
}
extern "C" {
    pub fn lrOpenLocationResolver(storage: FsStorageId, out: *mut LrLocationResolver) -> Result;
}
extern "C" {
    pub fn lrOpenRegisteredLocationResolver(out: *mut LrRegisteredLocationResolver) -> Result;
}
extern "C" {
    pub fn lrLrResolveProgramPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectProgramPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveApplicationControlPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveApplicationHtmlDocumentPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveDataPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectApplicationControlPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectApplicationHtmlDocumentPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrResolveLegalInformationPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        out: *mut lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRedirectLegalInformationPath(
        lr: *mut LrLocationResolver,
        tid: u64,
        path: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    pub fn lrLrRefresh(lr: *mut LrLocationResolver) -> Result;
}
extern "C" {
    pub fn lrRegLrResolveProgramPath(
        reg: *mut LrRegisteredLocationResolver,
        tid: u64,
        out: *mut lang_items::c_char,
    ) -> Result;
}
pub const SplConfigItem_SplConfigItem_DisableProgramVerification: SplConfigItem = 1;
pub const SplConfigItem_SplConfigItem_DramId: SplConfigItem = 2;
pub const SplConfigItem_SplConfigItem_SecurityEngineIrqNumber: SplConfigItem = 3;
pub const SplConfigItem_SplConfigItem_Version: SplConfigItem = 4;
pub const SplConfigItem_SplConfigItem_HardwareType: SplConfigItem = 5;
pub const SplConfigItem_SplConfigItem_IsRetail: SplConfigItem = 6;
pub const SplConfigItem_SplConfigItem_IsRecoveryBoot: SplConfigItem = 7;
pub const SplConfigItem_SplConfigItem_DeviceId: SplConfigItem = 8;
pub const SplConfigItem_SplConfigItem_BootReason: SplConfigItem = 9;
pub const SplConfigItem_SplConfigItem_MemoryArrange: SplConfigItem = 10;
pub const SplConfigItem_SplConfigItem_IsDebugMode: SplConfigItem = 11;
pub const SplConfigItem_SplConfigItem_KernelMemoryConfiguration: SplConfigItem = 12;
pub const SplConfigItem_SplConfigItem_IsChargerHiZModeEnabled: SplConfigItem = 13;
pub const SplConfigItem_SplConfigItem_IsKiosk: SplConfigItem = 14;
pub const SplConfigItem_SplConfigItem_NewHardwareType: SplConfigItem = 15;
pub const SplConfigItem_SplConfigItem_NewKeyGeneration: SplConfigItem = 16;
pub const SplConfigItem_SplConfigItem_Package2Hash: SplConfigItem = 17;
pub type SplConfigItem = u32;
pub const RsaKeyVersion_RsaKeyVersion_Deprecated: RsaKeyVersion = 0;
pub const RsaKeyVersion_RsaKeyVersion_Extended: RsaKeyVersion = 1;
pub type RsaKeyVersion = u32;
extern "C" {
    pub fn splInitialize() -> Result;
}
extern "C" {
    pub fn splExit();
}
extern "C" {
    pub fn splCryptoInitialize() -> Result;
}
extern "C" {
    pub fn splCryptoExit();
}
extern "C" {
    pub fn splSslInitialize() -> Result;
}
extern "C" {
    pub fn splSslExit();
}
extern "C" {
    pub fn splEsInitialize() -> Result;
}
extern "C" {
    pub fn splEsExit();
}
extern "C" {
    pub fn splFsInitialize() -> Result;
}
extern "C" {
    pub fn splFsExit();
}
extern "C" {
    pub fn splManuInitialize() -> Result;
}
extern "C" {
    pub fn splManuExit();
}
extern "C" {
    pub fn splGetConfig(config_item: SplConfigItem, out_config: *mut u64) -> Result;
}
extern "C" {
    pub fn splUserExpMod(
        input: *const lang_items::c_void,
        modulus: *const lang_items::c_void,
        exp: *const lang_items::c_void,
        exp_size: usize,
        dst: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splSetConfig(config_item: SplConfigItem, value: u64) -> Result;
}
extern "C" {
    pub fn splGetRandomBytes(out: *mut lang_items::c_void, out_size: usize) -> Result;
}
extern "C" {
    pub fn splIsDevelopment(out_is_development: *mut bool) -> Result;
}
extern "C" {
    pub fn splSetSharedData(value: u32) -> Result;
}
extern "C" {
    pub fn splGetSharedData(out_value: *mut u32) -> Result;
}
extern "C" {
    pub fn splCryptoGenerateAesKek(
        wrapped_kek: *const lang_items::c_void,
        key_generation: u32,
        option: u32,
        out_sealed_kek: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoLoadAesKey(
        sealed_kek: *const lang_items::c_void,
        wrapped_key: *const lang_items::c_void,
        keyslot: u32,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoGenerateAesKey(
        sealed_kek: *const lang_items::c_void,
        wrapped_key: *const lang_items::c_void,
        out_sealed_key: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoDecryptAesKey(
        wrapped_key: *const lang_items::c_void,
        key_generation: u32,
        option: u32,
        out_sealed_key: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoCryptAesCtr(
        input: *const lang_items::c_void,
        output: *mut lang_items::c_void,
        size: usize,
        ctr: *const lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoComputeCmac(
        input: *const lang_items::c_void,
        size: usize,
        keyslot: u32,
        out_cmac: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splCryptoLockAesEngine(out_keyslot: *mut u32) -> Result;
}
extern "C" {
    pub fn splCryptoUnlockAesEngine(keyslot: u32) -> Result;
}
extern "C" {
    pub fn splCryptoGetSecurityEngineEvent(out_event: *mut Handle) -> Result;
}
extern "C" {
    pub fn splRsaDecryptPrivateKey(
        sealed_kek: *const lang_items::c_void,
        wrapped_key: *const lang_items::c_void,
        wrapped_rsa_key: *const lang_items::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
        dst: *mut lang_items::c_void,
        dst_size: usize,
    ) -> Result;
}
extern "C" {
    pub fn splSslLoadSecureExpModKey(
        sealed_kek: *const lang_items::c_void,
        wrapped_key: *const lang_items::c_void,
        wrapped_rsa_key: *const lang_items::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splSslSecureExpMod(
        input: *const lang_items::c_void,
        modulus: *const lang_items::c_void,
        dst: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splEsLoadRsaOaepKey(
        sealed_kek: *const lang_items::c_void,
        wrapped_key: *const lang_items::c_void,
        wrapped_rsa_key: *const lang_items::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splEsUnwrapRsaOaepWrappedTitlekey(
        rsa_wrapped_titlekey: *const lang_items::c_void,
        modulus: *const lang_items::c_void,
        label_hash: *const lang_items::c_void,
        label_hash_size: usize,
        key_generation: u32,
        out_sealed_titlekey: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splEsUnwrapAesWrappedTitlekey(
        aes_wrapped_titlekey: *const lang_items::c_void,
        key_generation: u32,
        out_sealed_titlekey: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splEsLoadSecureExpModKey(
        sealed_kek: *const lang_items::c_void,
        wrapped_key: *const lang_items::c_void,
        wrapped_rsa_key: *const lang_items::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splEsSecureExpMod(
        input: *const lang_items::c_void,
        modulus: *const lang_items::c_void,
        dst: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splFsLoadSecureExpModKey(
        sealed_kek: *const lang_items::c_void,
        wrapped_key: *const lang_items::c_void,
        wrapped_rsa_key: *const lang_items::c_void,
        wrapped_rsa_key_size: usize,
        version: RsaKeyVersion,
    ) -> Result;
}
extern "C" {
    pub fn splFsSecureExpMod(
        input: *const lang_items::c_void,
        modulus: *const lang_items::c_void,
        dst: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splFsGenerateSpecificAesKey(
        wrapped_key: *const lang_items::c_void,
        key_generation: u32,
        option: u32,
        out_sealed_key: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn splFsLoadTitlekey(sealed_titlekey: *const lang_items::c_void, keyslot: u32) -> Result;
}
extern "C" {
    pub fn splFsGetPackage2Hash(out_hash: *mut lang_items::c_void) -> Result;
}
extern "C" {
    pub fn splManuEncryptRsaKeyForImport(
        sealed_kek_pre: *const lang_items::c_void,
        wrapped_key_pre: *const lang_items::c_void,
        sealed_kek_post: *const lang_items::c_void,
        wrapped_kek_post: *const lang_items::c_void,
        option: u32,
        wrapped_rsa_key: *const lang_items::c_void,
        out_wrapped_rsa_key: *mut lang_items::c_void,
        rsa_key_size: usize,
    ) -> Result;
}
pub const NcmContentType_NcmContentType_CNMT: NcmContentType = 0;
pub const NcmContentType_NcmContentType_Program: NcmContentType = 1;
pub const NcmContentType_NcmContentType_Data: NcmContentType = 2;
pub const NcmContentType_NcmContentType_Icon: NcmContentType = 3;
pub const NcmContentType_NcmContentType_Doc: NcmContentType = 4;
pub const NcmContentType_NcmContentType_Info: NcmContentType = 5;
pub type NcmContentType = u32;
#[repr(C)]
pub struct NcmContentStorage {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_NcmContentStorage() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentStorage>(),
        12usize,
        concat!("Size of: ", stringify!(NcmContentStorage))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentStorage>(),
        4usize,
        concat!("Alignment of ", stringify!(NcmContentStorage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentStorage>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentStorage),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct NcmContentMetaDatabase {
    pub s: Service,
}
#[test]
fn bindgen_test_layout_NcmContentMetaDatabase() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentMetaDatabase>(),
        12usize,
        concat!("Size of: ", stringify!(NcmContentMetaDatabase))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentMetaDatabase>(),
        4usize,
        concat!("Alignment of ", stringify!(NcmContentMetaDatabase))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentMetaDatabase>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaDatabase),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
pub struct NcmNcaId {
    pub c: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_NcmNcaId() {
    assert_eq!(
        ::core::mem::size_of::<NcmNcaId>(),
        16usize,
        concat!("Size of: ", stringify!(NcmNcaId))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmNcaId>(),
        1usize,
        concat!("Alignment of ", stringify!(NcmNcaId))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmNcaId>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmNcaId),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
pub struct NcmMetaRecord {
    pub titleId: u64,
    pub version: u32,
    pub type_: u8,
    pub flags: u8,
    pub padding: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_NcmMetaRecord() {
    assert_eq!(
        ::core::mem::size_of::<NcmMetaRecord>(),
        16usize,
        concat!("Size of: ", stringify!(NcmMetaRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmMetaRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(NcmMetaRecord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).titleId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(titleId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).flags as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmMetaRecord>())).padding as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmMetaRecord),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct NcmContentRecord {
    pub ncaId: NcmNcaId,
    pub size: [u8; 6usize],
    pub type_: u8,
    pub padding: u8,
}
#[test]
fn bindgen_test_layout_NcmContentRecord() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentRecord>(),
        24usize,
        concat!("Size of: ", stringify!(NcmContentRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(NcmContentRecord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).ncaId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(ncaId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).type_ as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmContentRecord>())).padding as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentRecord),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct NcmContentMetaRecordsHeader {
    /// < Size of optional struct that comes after this one.
    pub numExtraBytes: u16,
    /// < Number of NcmContentRecord entries after the extra bytes.
    pub numContentRecords: u16,
    /// < Number of NcmMetaRecord entries that come after the NcmContentRecords.
    pub numMetaRecords: u16,
    /// < Always zero.
    pub padding: u16,
}
#[test]
fn bindgen_test_layout_NcmContentMetaRecordsHeader() {
    assert_eq!(
        ::core::mem::size_of::<NcmContentMetaRecordsHeader>(),
        8usize,
        concat!("Size of: ", stringify!(NcmContentMetaRecordsHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmContentMetaRecordsHeader>(),
        2usize,
        concat!("Alignment of ", stringify!(NcmContentMetaRecordsHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).numExtraBytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(numExtraBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).numContentRecords as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(numContentRecords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).numMetaRecords as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(numMetaRecords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmContentMetaRecordsHeader>())).padding as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmContentMetaRecordsHeader),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
pub struct NcmApplicationContentMetaKey {
    pub metaRecord: NcmMetaRecord,
    pub baseTitleId: u64,
}
#[test]
fn bindgen_test_layout_NcmApplicationContentMetaKey() {
    assert_eq!(
        ::core::mem::size_of::<NcmApplicationContentMetaKey>(),
        24usize,
        concat!("Size of: ", stringify!(NcmApplicationContentMetaKey))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmApplicationContentMetaKey>(),
        8usize,
        concat!("Alignment of ", stringify!(NcmApplicationContentMetaKey))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmApplicationContentMetaKey>())).metaRecord as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmApplicationContentMetaKey),
            "::",
            stringify!(metaRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<NcmApplicationContentMetaKey>())).baseTitleId as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmApplicationContentMetaKey),
            "::",
            stringify!(baseTitleId)
        )
    );
}
#[repr(C)]
pub struct NcmRightsId {
    pub c: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_NcmRightsId() {
    assert_eq!(
        ::core::mem::size_of::<NcmRightsId>(),
        16usize,
        concat!("Size of: ", stringify!(NcmRightsId))
    );
    assert_eq!(
        ::core::mem::align_of::<NcmRightsId>(),
        1usize,
        concat!("Alignment of ", stringify!(NcmRightsId))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NcmRightsId>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NcmRightsId),
            "::",
            stringify!(c)
        )
    );
}
extern "C" {
    pub fn ncmInitialize() -> Result;
}
extern "C" {
    pub fn ncmExit();
}
extern "C" {
    pub fn ncmOpenContentStorage(storage: FsStorageId, out: *mut NcmContentStorage) -> Result;
}
extern "C" {
    pub fn ncmOpenContentMetaDatabase(
        storage: FsStorageId,
        out: *mut NcmContentMetaDatabase,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGeneratePlaceHolderId(
        cs: *mut NcmContentStorage,
        outputId: *mut NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageCreatePlaceHolder(
        cs: *mut NcmContentStorage,
        registeredId: *const NcmNcaId,
        placeholderId: *const NcmNcaId,
        size: u64,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageDeletePlaceHolder(
        cs: *mut NcmContentStorage,
        placeholderId: *const NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageWritePlaceHolder(
        cs: *mut NcmContentStorage,
        placeholderId: *const NcmNcaId,
        offset: u64,
        srcData: *const lang_items::c_void,
        srcDataSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageRegister(
        cs: *mut NcmContentStorage,
        registeredId: *const NcmNcaId,
        placeholderId: *const NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageDelete(
        cs: *mut NcmContentStorage,
        registeredId: *const NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageHas(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetPath(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut lang_items::c_char,
        outSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetPlaceHolderPath(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut lang_items::c_char,
        outSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageCleanupAllPlaceHolder(cs: *mut NcmContentStorage) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetSize(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageDisableForcibly(cs: *mut NcmContentStorage) -> Result;
}
extern "C" {
    pub fn ncmContentStorageReadContentIdFile(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        offset: u64,
        outBuf: *mut lang_items::c_void,
        bufSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentStorageGetRightsIdFromContentId(
        cs: *mut NcmContentStorage,
        ncaId: *const NcmNcaId,
        rightsIdOut: *mut NcmRightsId,
        keyGenerationOut: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseSet(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        inDataSize: u64,
        srcRecordsData: *const NcmContentMetaRecordsHeader,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseGet(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        outDataSize: u64,
        outRecordsData: *mut NcmContentMetaRecordsHeader,
        sizeRead: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseRemove(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseGetContentIdByType(
        db: *mut NcmContentMetaDatabase,
        contentType: NcmContentType,
        record: *const NcmMetaRecord,
        out: *mut NcmNcaId,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseListContentInfo(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        index: u32,
        contentRecordsOut: *mut NcmContentRecord,
        contentRecordsBufSize: usize,
        numEntriesRead: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseList(
        db: *mut NcmContentMetaDatabase,
        titleType: u32,
        titleIdExact: u64,
        titleIdLow: u64,
        titleIdHigh: u64,
        metaRecordsOut: *mut NcmMetaRecord,
        metaRecordsBufSize: usize,
        numEntriesWritten: *mut u32,
        numEntriesTotal: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseGetLatestContentMetaKey(
        db: *mut NcmContentMetaDatabase,
        titleId: u64,
        out: *mut NcmMetaRecord,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseListApplication(
        db: *mut NcmContentMetaDatabase,
        filter: u8,
        outBuf: *mut NcmApplicationContentMetaKey,
        outBufSize: usize,
        numEntriesWritten: *mut u32,
        numEntriesTotal: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseHas(
        db: *mut NcmContentMetaDatabase,
        record: *const NcmMetaRecord,
        out: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseDisableForcibly(db: *mut NcmContentMetaDatabase) -> Result;
}
extern "C" {
    pub fn ncmContentMetaDatabaseCommit(db: *mut NcmContentMetaDatabase) -> Result;
}
/// < Everything is awake.
pub const PscPmState_PscPmState_Awake: PscPmState = 0;
/// < Preparing to transition to awake.
pub const PscPmState_PscPmState_ReadyAwaken: PscPmState = 1;
/// < Preparing to transition to sleep.
pub const PscPmState_PscPmState_ReadySleep: PscPmState = 2;
/// < Critical services are ready to sleep.
pub const PscPmState_PscPmState_ReadySleepCritical: PscPmState = 3;
/// < Critical services are ready to wake up.
pub const PscPmState_PscPmState_ReadyAwakenCritical: PscPmState = 4;
/// < Preparing to transition to shutdown.
pub const PscPmState_PscPmState_ReadyShutdown: PscPmState = 5;
pub type PscPmState = u32;
#[repr(C)]
pub struct PscPmModule {
    pub event: Event,
    pub srv: Service,
    pub module_id: u16,
}
#[test]
fn bindgen_test_layout_PscPmModule() {
    assert_eq!(
        ::core::mem::size_of::<PscPmModule>(),
        28usize,
        concat!("Size of: ", stringify!(PscPmModule))
    );
    assert_eq!(
        ::core::mem::align_of::<PscPmModule>(),
        4usize,
        concat!("Alignment of ", stringify!(PscPmModule))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PscPmModule>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PscPmModule),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PscPmModule>())).srv as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PscPmModule),
            "::",
            stringify!(srv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PscPmModule>())).module_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PscPmModule),
            "::",
            stringify!(module_id)
        )
    );
}
extern "C" {
    pub fn pscInitialize() -> Result;
}
extern "C" {
    pub fn pscExit();
}
extern "C" {
    pub fn pscGetPmModule(
        out: *mut PscPmModule,
        module_id: u16,
        dependencies: *const u16,
        dependency_count: usize,
        autoclear: bool,
    ) -> Result;
}
extern "C" {
    pub fn pscPmModuleGetRequest(
        module: *mut PscPmModule,
        out_state: *mut PscPmState,
        out_flags: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn pscPmModuleAcknowledge(module: *mut PscPmModule, state: PscPmState) -> Result;
}
extern "C" {
    pub fn pscPmModuleFinalize(module: *mut PscPmModule) -> Result;
}
pub type iova_t = u64;
pub const NvLayout_NvLayout_Pitch: NvLayout = 1;
pub const NvLayout_NvLayout_Tiled: NvLayout = 2;
pub const NvLayout_NvLayout_BlockLinear: NvLayout = 3;
pub type NvLayout = u32;
pub const NvDisplayScanFormat_NvDisplayScanFormat_Progressive: NvDisplayScanFormat = 0;
pub const NvDisplayScanFormat_NvDisplayScanFormat_Interlaced: NvDisplayScanFormat = 1;
pub type NvDisplayScanFormat = u32;
pub const NvKind_NvKind_Pitch: NvKind = 0;
pub const NvKind_NvKind_Z16: NvKind = 1;
pub const NvKind_NvKind_Z16_2C: NvKind = 2;
pub const NvKind_NvKind_Z16_MS2_2C: NvKind = 3;
pub const NvKind_NvKind_Z16_MS4_2C: NvKind = 4;
pub const NvKind_NvKind_Z16_MS8_2C: NvKind = 5;
pub const NvKind_NvKind_Z16_MS16_2C: NvKind = 6;
pub const NvKind_NvKind_Z16_2Z: NvKind = 7;
pub const NvKind_NvKind_Z16_MS2_2Z: NvKind = 8;
pub const NvKind_NvKind_Z16_MS4_2Z: NvKind = 9;
pub const NvKind_NvKind_Z16_MS8_2Z: NvKind = 10;
pub const NvKind_NvKind_Z16_MS16_2Z: NvKind = 11;
pub const NvKind_NvKind_Z16_4CZ: NvKind = 12;
pub const NvKind_NvKind_Z16_MS2_4CZ: NvKind = 13;
pub const NvKind_NvKind_Z16_MS4_4CZ: NvKind = 14;
pub const NvKind_NvKind_Z16_MS8_4CZ: NvKind = 15;
pub const NvKind_NvKind_Z16_MS16_4CZ: NvKind = 16;
pub const NvKind_NvKind_S8Z24: NvKind = 17;
pub const NvKind_NvKind_S8Z24_1Z: NvKind = 18;
pub const NvKind_NvKind_S8Z24_MS2_1Z: NvKind = 19;
pub const NvKind_NvKind_S8Z24_MS4_1Z: NvKind = 20;
pub const NvKind_NvKind_S8Z24_MS8_1Z: NvKind = 21;
pub const NvKind_NvKind_S8Z24_MS16_1Z: NvKind = 22;
pub const NvKind_NvKind_S8Z24_2CZ: NvKind = 23;
pub const NvKind_NvKind_S8Z24_MS2_2CZ: NvKind = 24;
pub const NvKind_NvKind_S8Z24_MS4_2CZ: NvKind = 25;
pub const NvKind_NvKind_S8Z24_MS8_2CZ: NvKind = 26;
pub const NvKind_NvKind_S8Z24_MS16_2CZ: NvKind = 27;
pub const NvKind_NvKind_S8Z24_2CS: NvKind = 28;
pub const NvKind_NvKind_S8Z24_MS2_2CS: NvKind = 29;
pub const NvKind_NvKind_S8Z24_MS4_2CS: NvKind = 30;
pub const NvKind_NvKind_S8Z24_MS8_2CS: NvKind = 31;
pub const NvKind_NvKind_S8Z24_MS16_2CS: NvKind = 32;
pub const NvKind_NvKind_S8Z24_4CSZV: NvKind = 33;
pub const NvKind_NvKind_S8Z24_MS2_4CSZV: NvKind = 34;
pub const NvKind_NvKind_S8Z24_MS4_4CSZV: NvKind = 35;
pub const NvKind_NvKind_S8Z24_MS8_4CSZV: NvKind = 36;
pub const NvKind_NvKind_S8Z24_MS16_4CSZV: NvKind = 37;
pub const NvKind_NvKind_V8Z24_MS4_VC12: NvKind = 38;
pub const NvKind_NvKind_V8Z24_MS4_VC4: NvKind = 39;
pub const NvKind_NvKind_V8Z24_MS8_VC8: NvKind = 40;
pub const NvKind_NvKind_V8Z24_MS8_VC24: NvKind = 41;
pub const NvKind_NvKind_S8: NvKind = 42;
pub const NvKind_NvKind_S8_2S: NvKind = 43;
pub const NvKind_NvKind_V8Z24_MS4_VC12_1ZV: NvKind = 46;
pub const NvKind_NvKind_V8Z24_MS4_VC4_1ZV: NvKind = 47;
pub const NvKind_NvKind_V8Z24_MS8_VC8_1ZV: NvKind = 48;
pub const NvKind_NvKind_V8Z24_MS8_VC24_1ZV: NvKind = 49;
pub const NvKind_NvKind_V8Z24_MS4_VC12_2CS: NvKind = 50;
pub const NvKind_NvKind_V8Z24_MS4_VC4_2CS: NvKind = 51;
pub const NvKind_NvKind_V8Z24_MS8_VC8_2CS: NvKind = 52;
pub const NvKind_NvKind_V8Z24_MS8_VC24_2CS: NvKind = 53;
pub const NvKind_NvKind_V8Z24_MS4_VC12_2CZV: NvKind = 58;
pub const NvKind_NvKind_V8Z24_MS4_VC4_2CZV: NvKind = 59;
pub const NvKind_NvKind_V8Z24_MS8_VC8_2CZV: NvKind = 60;
pub const NvKind_NvKind_V8Z24_MS8_VC24_2CZV: NvKind = 61;
pub const NvKind_NvKind_V8Z24_MS4_VC12_2ZV: NvKind = 62;
pub const NvKind_NvKind_V8Z24_MS4_VC4_2ZV: NvKind = 63;
pub const NvKind_NvKind_V8Z24_MS8_VC8_2ZV: NvKind = 64;
pub const NvKind_NvKind_V8Z24_MS8_VC24_2ZV: NvKind = 65;
pub const NvKind_NvKind_V8Z24_MS4_VC12_4CSZV: NvKind = 66;
pub const NvKind_NvKind_V8Z24_MS4_VC4_4CSZV: NvKind = 67;
pub const NvKind_NvKind_V8Z24_MS8_VC8_4CSZV: NvKind = 68;
pub const NvKind_NvKind_V8Z24_MS8_VC24_4CSZV: NvKind = 69;
pub const NvKind_NvKind_Z24S8: NvKind = 70;
pub const NvKind_NvKind_Z24S8_1Z: NvKind = 71;
pub const NvKind_NvKind_Z24S8_MS2_1Z: NvKind = 72;
pub const NvKind_NvKind_Z24S8_MS4_1Z: NvKind = 73;
pub const NvKind_NvKind_Z24S8_MS8_1Z: NvKind = 74;
pub const NvKind_NvKind_Z24S8_MS16_1Z: NvKind = 75;
pub const NvKind_NvKind_Z24S8_2CS: NvKind = 76;
pub const NvKind_NvKind_Z24S8_MS2_2CS: NvKind = 77;
pub const NvKind_NvKind_Z24S8_MS4_2CS: NvKind = 78;
pub const NvKind_NvKind_Z24S8_MS8_2CS: NvKind = 79;
pub const NvKind_NvKind_Z24S8_MS16_2CS: NvKind = 80;
pub const NvKind_NvKind_Z24S8_2CZ: NvKind = 81;
pub const NvKind_NvKind_Z24S8_MS2_2CZ: NvKind = 82;
pub const NvKind_NvKind_Z24S8_MS4_2CZ: NvKind = 83;
pub const NvKind_NvKind_Z24S8_MS8_2CZ: NvKind = 84;
pub const NvKind_NvKind_Z24S8_MS16_2CZ: NvKind = 85;
pub const NvKind_NvKind_Z24S8_4CSZV: NvKind = 86;
pub const NvKind_NvKind_Z24S8_MS2_4CSZV: NvKind = 87;
pub const NvKind_NvKind_Z24S8_MS4_4CSZV: NvKind = 88;
pub const NvKind_NvKind_Z24S8_MS8_4CSZV: NvKind = 89;
pub const NvKind_NvKind_Z24S8_MS16_4CSZV: NvKind = 90;
pub const NvKind_NvKind_Z24V8_MS4_VC12: NvKind = 91;
pub const NvKind_NvKind_Z24V8_MS4_VC4: NvKind = 92;
pub const NvKind_NvKind_Z24V8_MS8_VC8: NvKind = 93;
pub const NvKind_NvKind_Z24V8_MS8_VC24: NvKind = 94;
pub const NvKind_NvKind_Z24V8_MS4_VC12_1ZV: NvKind = 99;
pub const NvKind_NvKind_Z24V8_MS4_VC4_1ZV: NvKind = 100;
pub const NvKind_NvKind_Z24V8_MS8_VC8_1ZV: NvKind = 101;
pub const NvKind_NvKind_Z24V8_MS8_VC24_1ZV: NvKind = 102;
pub const NvKind_NvKind_Z24V8_MS4_VC12_2CS: NvKind = 103;
pub const NvKind_NvKind_Z24V8_MS4_VC4_2CS: NvKind = 104;
pub const NvKind_NvKind_Z24V8_MS8_VC8_2CS: NvKind = 105;
pub const NvKind_NvKind_Z24V8_MS8_VC24_2CS: NvKind = 106;
pub const NvKind_NvKind_Z24V8_MS4_VC12_2CZV: NvKind = 111;
pub const NvKind_NvKind_Z24V8_MS4_VC4_2CZV: NvKind = 112;
pub const NvKind_NvKind_Z24V8_MS8_VC8_2CZV: NvKind = 113;
pub const NvKind_NvKind_Z24V8_MS8_VC24_2CZV: NvKind = 114;
pub const NvKind_NvKind_Z24V8_MS4_VC12_2ZV: NvKind = 115;
pub const NvKind_NvKind_Z24V8_MS4_VC4_2ZV: NvKind = 116;
pub const NvKind_NvKind_Z24V8_MS8_VC8_2ZV: NvKind = 117;
pub const NvKind_NvKind_Z24V8_MS8_VC24_2ZV: NvKind = 118;
pub const NvKind_NvKind_Z24V8_MS4_VC12_4CSZV: NvKind = 119;
pub const NvKind_NvKind_Z24V8_MS4_VC4_4CSZV: NvKind = 120;
pub const NvKind_NvKind_Z24V8_MS8_VC8_4CSZV: NvKind = 121;
pub const NvKind_NvKind_Z24V8_MS8_VC24_4CSZV: NvKind = 122;
pub const NvKind_NvKind_ZF32: NvKind = 123;
pub const NvKind_NvKind_ZF32_1Z: NvKind = 124;
pub const NvKind_NvKind_ZF32_MS2_1Z: NvKind = 125;
pub const NvKind_NvKind_ZF32_MS4_1Z: NvKind = 126;
pub const NvKind_NvKind_ZF32_MS8_1Z: NvKind = 127;
pub const NvKind_NvKind_ZF32_MS16_1Z: NvKind = 128;
pub const NvKind_NvKind_ZF32_2CS: NvKind = 129;
pub const NvKind_NvKind_ZF32_MS2_2CS: NvKind = 130;
pub const NvKind_NvKind_ZF32_MS4_2CS: NvKind = 131;
pub const NvKind_NvKind_ZF32_MS8_2CS: NvKind = 132;
pub const NvKind_NvKind_ZF32_MS16_2CS: NvKind = 133;
pub const NvKind_NvKind_ZF32_2CZ: NvKind = 134;
pub const NvKind_NvKind_ZF32_MS2_2CZ: NvKind = 135;
pub const NvKind_NvKind_ZF32_MS4_2CZ: NvKind = 136;
pub const NvKind_NvKind_ZF32_MS8_2CZ: NvKind = 137;
pub const NvKind_NvKind_ZF32_MS16_2CZ: NvKind = 138;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12: NvKind = 139;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4: NvKind = 140;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8: NvKind = 141;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24: NvKind = 142;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_1CS: NvKind = 143;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_1CS: NvKind = 144;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_1CS: NvKind = 145;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_1CS: NvKind = 146;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_1ZV: NvKind = 151;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_1ZV: NvKind = 152;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_1ZV: NvKind = 153;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_1ZV: NvKind = 154;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_1CZV: NvKind = 155;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_1CZV: NvKind = 156;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_1CZV: NvKind = 157;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_1CZV: NvKind = 158;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_2CS: NvKind = 159;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_2CS: NvKind = 160;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_2CS: NvKind = 161;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_2CS: NvKind = 162;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC12_2CSZV: NvKind = 163;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS4_VC4_2CSZV: NvKind = 164;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC8_2CSZV: NvKind = 165;
pub const NvKind_NvKind_X8Z24_X16V8S8_MS8_VC24_2CSZV: NvKind = 166;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12: NvKind = 167;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4: NvKind = 168;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8: NvKind = 169;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24: NvKind = 170;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_1CS: NvKind = 171;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_1CS: NvKind = 172;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_1CS: NvKind = 173;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_1CS: NvKind = 174;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_1ZV: NvKind = 179;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_1ZV: NvKind = 180;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_1ZV: NvKind = 181;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_1ZV: NvKind = 182;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_1CZV: NvKind = 183;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_1CZV: NvKind = 184;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_1CZV: NvKind = 185;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_1CZV: NvKind = 186;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_2CS: NvKind = 187;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_2CS: NvKind = 188;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_2CS: NvKind = 189;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_2CS: NvKind = 190;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC12_2CSZV: NvKind = 191;
pub const NvKind_NvKind_ZF32_X16V8S8_MS4_VC4_2CSZV: NvKind = 192;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC8_2CSZV: NvKind = 193;
pub const NvKind_NvKind_ZF32_X16V8S8_MS8_VC24_2CSZV: NvKind = 194;
pub const NvKind_NvKind_ZF32_X24S8: NvKind = 195;
pub const NvKind_NvKind_ZF32_X24S8_1CS: NvKind = 196;
pub const NvKind_NvKind_ZF32_X24S8_MS2_1CS: NvKind = 197;
pub const NvKind_NvKind_ZF32_X24S8_MS4_1CS: NvKind = 198;
pub const NvKind_NvKind_ZF32_X24S8_MS8_1CS: NvKind = 199;
pub const NvKind_NvKind_ZF32_X24S8_MS16_1CS: NvKind = 200;
pub const NvKind_NvKind_SmskedMessage: NvKind = 202;
pub const NvKind_NvKind_SmhostMessage: NvKind = 203;
pub const NvKind_NvKind_C64_MS2_2CRA: NvKind = 205;
pub const NvKind_NvKind_ZF32_X24S8_2CSZV: NvKind = 206;
pub const NvKind_NvKind_ZF32_X24S8_MS2_2CSZV: NvKind = 207;
pub const NvKind_NvKind_ZF32_X24S8_MS4_2CSZV: NvKind = 208;
pub const NvKind_NvKind_ZF32_X24S8_MS8_2CSZV: NvKind = 209;
pub const NvKind_NvKind_ZF32_X24S8_MS16_2CSZV: NvKind = 210;
pub const NvKind_NvKind_ZF32_X24S8_2CS: NvKind = 211;
pub const NvKind_NvKind_ZF32_X24S8_MS2_2CS: NvKind = 212;
pub const NvKind_NvKind_ZF32_X24S8_MS4_2CS: NvKind = 213;
pub const NvKind_NvKind_ZF32_X24S8_MS8_2CS: NvKind = 214;
pub const NvKind_NvKind_ZF32_X24S8_MS16_2CS: NvKind = 215;
pub const NvKind_NvKind_C32_2C: NvKind = 216;
pub const NvKind_NvKind_C32_2CBR: NvKind = 217;
pub const NvKind_NvKind_C32_2CBA: NvKind = 218;
pub const NvKind_NvKind_C32_2CRA: NvKind = 219;
pub const NvKind_NvKind_C32_2BRA: NvKind = 220;
pub const NvKind_NvKind_C32_MS2_2C: NvKind = 221;
pub const NvKind_NvKind_C32_MS2_2CBR: NvKind = 222;
pub const NvKind_NvKind_C32_MS2_2CRA: NvKind = 204;
pub const NvKind_NvKind_C32_MS4_2C: NvKind = 223;
pub const NvKind_NvKind_C32_MS4_2CBR: NvKind = 224;
pub const NvKind_NvKind_C32_MS4_2CBA: NvKind = 225;
pub const NvKind_NvKind_C32_MS4_2CRA: NvKind = 226;
pub const NvKind_NvKind_C32_MS4_2BRA: NvKind = 227;
pub const NvKind_NvKind_C32_MS8_MS16_2C: NvKind = 228;
pub const NvKind_NvKind_C32_MS8_MS16_2CRA: NvKind = 229;
pub const NvKind_NvKind_C64_2C: NvKind = 230;
pub const NvKind_NvKind_C64_2CBR: NvKind = 231;
pub const NvKind_NvKind_C64_2CBA: NvKind = 232;
pub const NvKind_NvKind_C64_2CRA: NvKind = 233;
pub const NvKind_NvKind_C64_2BRA: NvKind = 234;
pub const NvKind_NvKind_C64_MS2_2C: NvKind = 235;
pub const NvKind_NvKind_C64_MS2_2CBR: NvKind = 236;
pub const NvKind_NvKind_C64_MS4_2C: NvKind = 237;
pub const NvKind_NvKind_C64_MS4_2CBR: NvKind = 238;
pub const NvKind_NvKind_C64_MS4_2CBA: NvKind = 239;
pub const NvKind_NvKind_C64_MS4_2CRA: NvKind = 240;
pub const NvKind_NvKind_C64_MS4_2BRA: NvKind = 241;
pub const NvKind_NvKind_C64_MS8_MS16_2C: NvKind = 242;
pub const NvKind_NvKind_C64_MS8_MS16_2CRA: NvKind = 243;
pub const NvKind_NvKind_C128_2C: NvKind = 244;
pub const NvKind_NvKind_C128_2CR: NvKind = 245;
pub const NvKind_NvKind_C128_MS2_2C: NvKind = 246;
pub const NvKind_NvKind_C128_MS2_2CR: NvKind = 247;
pub const NvKind_NvKind_C128_MS4_2C: NvKind = 248;
pub const NvKind_NvKind_C128_MS4_2CR: NvKind = 249;
pub const NvKind_NvKind_C128_MS8_MS16_2C: NvKind = 250;
pub const NvKind_NvKind_C128_MS8_MS16_2CR: NvKind = 251;
pub const NvKind_NvKind_X8C24: NvKind = 252;
pub const NvKind_NvKind_PitchNoSwizzle: NvKind = 253;
pub const NvKind_NvKind_Generic_16BX2: NvKind = 254;
pub const NvKind_NvKind_Invalid: NvKind = 255;
pub type NvKind = u32;
#[repr(C)]
pub struct nvioctl_gpu_characteristics {
    pub arch: u32,
    pub impl_: u32,
    pub rev: u32,
    pub num_gpc: u32,
    pub L2_cache_size: u64,
    pub on_board_video_memory_size: u64,
    pub num_tpc_per_gpc: u32,
    pub bus_type: u32,
    pub big_page_size: u32,
    pub compression_page_size: u32,
    pub pde_coverage_bit_count: u32,
    pub available_big_page_sizes: u32,
    pub gpc_mask: u32,
    pub sm_arch_sm_version: u32,
    pub sm_arch_spa_version: u32,
    pub sm_arch_warp_count: u32,
    pub gpu_va_bit_count: u32,
    pub reserved: u32,
    pub flags: u64,
    pub twod_class: u32,
    pub threed_class: u32,
    pub compute_class: u32,
    pub gpfifo_class: u32,
    pub inline_to_memory_class: u32,
    pub dma_copy_class: u32,
    pub max_fbps_count: u32,
    pub fbp_en_mask: u32,
    pub max_ltc_per_fbp: u32,
    pub max_lts_per_ltc: u32,
    pub max_tex_per_tpc: u32,
    pub max_gpc_count: u32,
    pub rop_l2_en_mask_0: u32,
    pub rop_l2_en_mask_1: u32,
    pub chipname: u64,
    pub gr_compbit_store_base_hw: u64,
}
#[test]
fn bindgen_test_layout_nvioctl_gpu_characteristics() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_gpu_characteristics>(),
        160usize,
        concat!("Size of: ", stringify!(nvioctl_gpu_characteristics))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_gpu_characteristics>(),
        8usize,
        concat!("Alignment of ", stringify!(nvioctl_gpu_characteristics))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).arch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).impl_ as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).rev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(rev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).num_gpc as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(num_gpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).L2_cache_size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(L2_cache_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).on_board_video_memory_size
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(on_board_video_memory_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).num_tpc_per_gpc as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(num_tpc_per_gpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).bus_type as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(bus_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).big_page_size as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(big_page_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).compression_page_size
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(compression_page_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).pde_coverage_bit_count
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(pde_coverage_bit_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).available_big_page_sizes
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(available_big_page_sizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gpc_mask as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gpc_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).sm_arch_sm_version as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(sm_arch_sm_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).sm_arch_spa_version as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(sm_arch_spa_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).sm_arch_warp_count as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(sm_arch_warp_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gpu_va_bit_count as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gpu_va_bit_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).reserved as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).flags as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).twod_class as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(twod_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).threed_class as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(threed_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).compute_class as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(compute_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gpfifo_class as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gpfifo_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).inline_to_memory_class
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(inline_to_memory_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).dma_copy_class as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(dma_copy_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_fbps_count as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_fbps_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).fbp_en_mask as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(fbp_en_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_ltc_per_fbp as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_ltc_per_fbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_lts_per_ltc as *const _
                as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_lts_per_ltc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_tex_per_tpc as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_tex_per_tpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).max_gpc_count as *const _
                as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(max_gpc_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).rop_l2_en_mask_0 as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(rop_l2_en_mask_0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).rop_l2_en_mask_1 as *const _
                as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(rop_l2_en_mask_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).chipname as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(chipname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpu_characteristics>())).gr_compbit_store_base_hw
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpu_characteristics),
            "::",
            stringify!(gr_compbit_store_base_hw)
        )
    );
}
#[repr(C)]
pub struct nvioctl_va_region {
    pub offset: u64,
    pub page_size: u32,
    pub pad: u32,
    pub pages: u64,
}
#[test]
fn bindgen_test_layout_nvioctl_va_region() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_va_region>(),
        24usize,
        concat!("Size of: ", stringify!(nvioctl_va_region))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_va_region>(),
        8usize,
        concat!("Alignment of ", stringify!(nvioctl_va_region))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).page_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_va_region>())).pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_va_region),
            "::",
            stringify!(pages)
        )
    );
}
#[repr(C)]
pub struct nvioctl_l2_state {
    pub mask: u32,
    pub flush: u32,
}
#[test]
fn bindgen_test_layout_nvioctl_l2_state() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_l2_state>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_l2_state))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_l2_state>(),
        4usize,
        concat!("Alignment of ", stringify!(nvioctl_l2_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_l2_state>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_l2_state),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_l2_state>())).flush as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_l2_state),
            "::",
            stringify!(flush)
        )
    );
}
#[repr(C)]
pub struct nvioctl_fence {
    pub id: u32,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_nvioctl_fence() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_fence>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_fence))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_fence>(),
        4usize,
        concat!("Alignment of ", stringify!(nvioctl_fence))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_fence>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_fence),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvioctl_fence>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_fence),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
pub struct nvioctl_gpfifo_entry {
    pub __bindgen_anon_1: nvioctl_gpfifo_entry__bindgen_ty_1,
}
#[repr(C)]
pub struct nvioctl_gpfifo_entry__bindgen_ty_1 {
    pub desc: __BindgenUnionField<u64>,
    pub desc32: __BindgenUnionField<[u32; 2usize]>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_nvioctl_gpfifo_entry__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_gpfifo_entry__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_gpfifo_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_gpfifo_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nvioctl_gpfifo_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpfifo_entry__bindgen_ty_1>())).desc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpfifo_entry__bindgen_ty_1),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<nvioctl_gpfifo_entry__bindgen_ty_1>())).desc32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvioctl_gpfifo_entry__bindgen_ty_1),
            "::",
            stringify!(desc32)
        )
    );
}
#[test]
fn bindgen_test_layout_nvioctl_gpfifo_entry() {
    assert_eq!(
        ::core::mem::size_of::<nvioctl_gpfifo_entry>(),
        8usize,
        concat!("Size of: ", stringify!(nvioctl_gpfifo_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<nvioctl_gpfifo_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(nvioctl_gpfifo_entry))
    );
}
pub const nvioctl_channel_obj_classnum_NvClassNumber_2D: nvioctl_channel_obj_classnum = 36909;
pub const nvioctl_channel_obj_classnum_NvClassNumber_3D: nvioctl_channel_obj_classnum = 45463;
pub const nvioctl_channel_obj_classnum_NvClassNumber_Compute: nvioctl_channel_obj_classnum = 45504;
pub const nvioctl_channel_obj_classnum_NvClassNumber_Kepler: nvioctl_channel_obj_classnum = 41280;
pub const nvioctl_channel_obj_classnum_NvClassNumber_DMA: nvioctl_channel_obj_classnum = 45237;
pub const nvioctl_channel_obj_classnum_NvClassNumber_ChannelGpfifo: nvioctl_channel_obj_classnum =
    45167;
pub type nvioctl_channel_obj_classnum = u32;
pub use self::nvioctl_channel_obj_classnum as NvClassNumber;
pub const nvioctl_channel_priority_NvChannelPriority_Low: nvioctl_channel_priority = 50;
pub const nvioctl_channel_priority_NvChannelPriority_Medium: nvioctl_channel_priority = 100;
pub const nvioctl_channel_priority_NvChannelPriority_High: nvioctl_channel_priority = 150;
pub type nvioctl_channel_priority = u32;
pub use self::nvioctl_channel_priority as NvChannelPriority;
pub const NvZcullConfig_NvZcullConfig_Global: NvZcullConfig = 0;
pub const NvZcullConfig_NvZcullConfig_NoCtxSwitch: NvZcullConfig = 1;
pub const NvZcullConfig_NvZcullConfig_SeparateBuffer: NvZcullConfig = 2;
pub const NvZcullConfig_NvZcullConfig_PartOfRegularBuffer: NvZcullConfig = 3;
pub type NvZcullConfig = u32;
pub const NvMapBufferFlags_NvMapBufferFlags_FixedOffset: NvMapBufferFlags = 1;
pub const NvMapBufferFlags_NvMapBufferFlags_IsCacheable: NvMapBufferFlags = 4;
pub type NvMapBufferFlags = u32;
pub const NvErrorType_NvErrorType_FifoErrorIdleTimeout: NvErrorType = 8;
pub const NvErrorType_NvErrorType_GrErrorSwNotify: NvErrorType = 13;
pub const NvErrorType_NvErrorType_GrSemaphoreTimeout: NvErrorType = 24;
pub const NvErrorType_NvErrorType_GrIllegalNotify: NvErrorType = 25;
pub const NvErrorType_NvErrorType_FifoErrorMmuErrFlt: NvErrorType = 31;
pub const NvErrorType_NvErrorType_PbdmaError: NvErrorType = 32;
pub const NvErrorType_NvErrorType_ResetChannelVerifError: NvErrorType = 43;
pub const NvErrorType_NvErrorType_PbdmaPushbufferCrcMismatch: NvErrorType = 80;
pub type NvErrorType = u32;
#[repr(C)]
pub struct NvError {
    pub tickstamp: u64,
    pub error_type: u32,
    pub unk16: u16,
    pub status: u16,
}
#[test]
fn bindgen_test_layout_NvError() {
    assert_eq!(
        ::core::mem::size_of::<NvError>(),
        16usize,
        concat!("Size of: ", stringify!(NvError))
    );
    assert_eq!(
        ::core::mem::align_of::<NvError>(),
        8usize,
        concat!("Alignment of ", stringify!(NvError))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).tickstamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(tickstamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).error_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(error_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).unk16 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(unk16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvError>())).status as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(NvError),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    pub fn nvioctlNvhostCtrl_SyncptRead(fd: u32, id: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_SyncptIncr(fd: u32, id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_SyncptWait(fd: u32, id: u32, threshold: u32, timeout: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventSignal(fd: u32, event_id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventWait(
        fd: u32,
        syncpt_id: u32,
        threshold: u32,
        timeout: s32,
        event_id: u32,
        out: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventWaitAsync(
        fd: u32,
        syncpt_id: u32,
        threshold: u32,
        timeout: s32,
        event_id: u32,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventRegister(fd: u32, event_id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrl_EventUnregister(fd: u32, event_id: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_ZCullGetCtxSize(fd: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_ZCullGetInfo(fd: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_GetCharacteristics(
        fd: u32,
        out: *mut nvioctl_gpu_characteristics,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_GetTpcMasks(fd: u32, inval: u32, out: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostCtrlGpu_GetL2State(fd: u32, out: *mut nvioctl_l2_state) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_BindChannel(fd: u32, channel_fd: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_AllocSpace(
        fd: u32,
        pages: u32,
        page_size: u32,
        flags: u32,
        align: u64,
        offset: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_MapBufferEx(
        fd: u32,
        flags: u32,
        kind: u32,
        nvmap_handle: u32,
        page_size: u32,
        buffer_offset: u64,
        mapping_size: u64,
        input_offset: u64,
        offset: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_UnmapBuffer(fd: u32, offset: u64) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_GetVARegions(fd: u32, regions: *mut nvioctl_va_region) -> Result;
}
extern "C" {
    pub fn nvioctlNvhostAsGpu_InitializeEx(fd: u32, big_page_size: u32, flags: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_Create(fd: u32, size: u32, nvmap_handle: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_FromId(fd: u32, id: u32, nvmap_handle: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_Alloc(
        fd: u32,
        nvmap_handle: u32,
        heapmask: u32,
        flags: u32,
        align: u32,
        kind: u8,
        addr: *mut lang_items::c_void,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_Free(fd: u32, nvmap_handle: u32) -> Result;
}
extern "C" {
    pub fn nvioctlNvmap_GetId(fd: u32, nvmap_handle: u32, id: *mut u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetNvmapFd(fd: u32, nvmap_fd: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SubmitGpfifo(
        fd: u32,
        entries: *mut nvioctl_gpfifo_entry,
        num_entries: u32,
        flags: u32,
        fence_inout: *mut nvioctl_fence,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_KickoffPb(
        fd: u32,
        entries: *mut nvioctl_gpfifo_entry,
        num_entries: u32,
        flags: u32,
        fence_inout: *mut nvioctl_fence,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_AllocObjCtx(
        fd: u32,
        class_num: u32,
        flags: u32,
        id_out: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_ZCullBind(fd: u32, gpu_va: u64, mode: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetErrorNotifier(fd: u32, enable: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_GetErrorNotification(fd: u32, out: *mut NvError) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetPriority(fd: u32, priority: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetTimeout(fd: u32, timeout: u32) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_AllocGpfifoEx2(
        fd: u32,
        num_entries: u32,
        flags: u32,
        unk0: u32,
        unk1: u32,
        unk2: u32,
        unk3: u32,
        fence_out: *mut nvioctl_fence,
    ) -> Result;
}
extern "C" {
    pub fn nvioctlChannel_SetUserData(fd: u32, addr: *mut lang_items::c_void) -> Result;
}
pub type NvFence = nvioctl_fence;
#[repr(C)]
pub struct NvMultiFence {
    pub num_fences: u32,
    pub fences: [NvFence; 4usize],
}
#[test]
fn bindgen_test_layout_NvMultiFence() {
    assert_eq!(
        ::core::mem::size_of::<NvMultiFence>(),
        36usize,
        concat!("Size of: ", stringify!(NvMultiFence))
    );
    assert_eq!(
        ::core::mem::align_of::<NvMultiFence>(),
        4usize,
        concat!("Alignment of ", stringify!(NvMultiFence))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMultiFence>())).num_fences as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMultiFence),
            "::",
            stringify!(num_fences)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvMultiFence>())).fences as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvMultiFence),
            "::",
            stringify!(fences)
        )
    );
}
extern "C" {
    pub fn nvFenceInit() -> Result;
}
extern "C" {
    pub fn nvFenceExit();
}
extern "C" {
    pub fn nvFenceWait(f: *mut NvFence, timeout_us: s32) -> Result;
}
extern "C" {
    pub fn nvMultiFenceWait(mf: *mut NvMultiFence, timeout_us: s32) -> Result;
}
/// < Double-buffering with raw tiled (block-linear) framebuffer.
pub const GfxMode_GfxMode_TiledDouble: GfxMode = 0;
/// < Double-buffering with linear framebuffer, which is transferred to the actual framebuffer by \ref gfxFlushBuffers().
pub const GfxMode_GfxMode_LinearDouble: GfxMode = 1;
/// GfxMode set by \ref gfxSetMode. The default is GfxMode_LinearDouble. Note that the text-console (see console.h) sets this to GfxMode_TiledDouble.
pub type GfxMode = u32;
extern "C" {
    /// @brief Initializes the graphics subsystem.
    /// @warning Do not use \ref viInitialize when using this function.
    pub fn gfxInitDefault() -> Result;
}
extern "C" {
    /// @brief Uninitializes the graphics subsystem.
    /// @warning Do not use \ref viExit when using this function.
    pub fn gfxExit();
}
extern "C" {
    /// @brief Sets the resolution to be used when initializing the graphics subsystem.
    /// @param[in] width Horizontal resolution, in pixels.
    /// @param[in] height Vertical resolution, in pixels.
    /// @note The default resolution is 720p.
    /// @note This can only be used before calling \ref gfxInitDefault, this will use \ref fatalSimple otherwise. If the input is 0, the default resolution will be used during \ref gfxInitDefault. This sets the maximum resolution for the framebuffer, used during \ref gfxInitDefault. This is also used as the current resolution when crop isn't set. The width/height are reset to the default when \ref gfxExit is used.
    /// @note Normally you should only use this when you need a maximum resolution larger than the default, see above.
    /// @note The width and height are aligned to 4.
    pub fn gfxInitResolution(width: u32, height: u32);
}
extern "C" {
    /// Wrapper for \ref gfxInitResolution with resolution=1080p. Use this if you want to support 1080p or >720p in docked-mode.
    pub fn gfxInitResolutionDefault();
}
extern "C" {
    /// Configure framebuffer crop, by default crop is all-zero. Use all-zero input to reset to default. \ref gfxExit resets this to the default.
    /// When the input is invalid this returns without changing the crop data, this includes the input values being larger than the framebuf width/height.
    /// This will update the display width/height returned by \ref gfxGetFramebuffer, with that width/height being reset to the default when required.
    /// \ref gfxGetFramebufferDisplayOffset uses absolute x/y, it will not adjust for non-zero crop left/top.
    /// When used during frame-drawing, this should be called before \ref gfxGetFramebuffer.
    /// The right and bottom params are aligned to 4.
    pub fn gfxConfigureCrop(left: s32, top: s32, right: s32, bottom: s32);
}
extern "C" {
    /// Wrapper for \ref gfxConfigureCrop. Use this to set the resolution, within the bounds of the maximum resolution. Use all-zero input to reset to default.
    pub fn gfxConfigureResolution(width: s32, height: s32);
}
extern "C" {
    /// If enabled, \ref gfxConfigureResolution will be used with the input resolution for the current OperationMode. Then \ref gfxConfigureResolution will automatically be used with the specified resolution each time OperationMode changes.
    pub fn gfxConfigureAutoResolution(
        enable: bool,
        handheld_width: s32,
        handheld_height: s32,
        docked_width: s32,
        docked_height: s32,
    );
}
extern "C" {
    /// Wrapper for \ref gfxConfigureAutoResolution. handheld_resolution=720p, docked_resolution={all-zero for using current maximum resolution}.
    pub fn gfxConfigureAutoResolutionDefault(enable: bool);
}
extern "C" {
    /// Waits for vertical sync.
    pub fn gfxWaitForVsync();
}
extern "C" {
    /// Appends one or more fences that the display service will wait on before rendering the current framebuffer. Note that only up to 4 fences can be submitted.
    pub fn gfxAppendFence(mf: *mut NvMultiFence);
}
extern "C" {
    /// Swaps the framebuffers.
    pub fn gfxSwapBuffers();
}
extern "C" {
    /// Get the specified framebuffer nvmap handle where index specifies the buffer number beginning with the back buffer, with optional output ptr for the offset in the buffer.
    pub fn gfxGetFramebufferHandle(index: u32, offset: *mut u32) -> u32;
}
extern "C" {
    /// Get the current framebuffer address, with optional output ptrs for the display framebuffer width/height. The display width/height is adjusted by \ref gfxConfigureCrop and \ref gfxConfigureResolution.
    pub fn gfxGetFramebuffer(width: *mut u32, height: *mut u32) -> *mut u8;
}
extern "C" {
    /// Get the framebuffer width/height without crop.
    pub fn gfxGetFramebufferResolution(width: *mut u32, height: *mut u32);
}
extern "C" {
    /// Use this to get the actual byte-size of the framebuffer for use with memset/etc.
    pub fn gfxGetFramebufferSize() -> usize;
}
extern "C" {
    /// Use this to get the actual byte-pitch of the framebuffer for use with memset/etc.
    pub fn gfxGetFramebufferPitch() -> u32;
}
extern "C" {
    /// Sets the \ref GfxMode.
    pub fn gfxSetMode(mode: GfxMode);
}
extern "C" {
    /// Configures transform. See the NATIVE_WINDOW_TRANSFORM_* enums in buffer_producer.h. The default is 0.
    pub fn gfxConfigureTransform(transform: u32);
}
extern "C" {
    /// Flushes the framebuffer in the data cache. When \ref GfxMode is GfxMode_LinearDouble, this also transfers the linear-framebuffer to the actual framebuffer.
    pub fn gfxFlushBuffers();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Binder {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub id: s32,
    pub ipc_buffer_size: usize,
}
#[test]
fn bindgen_test_layout_Binder() {
    assert_eq!(
        ::core::mem::size_of::<Binder>(),
        16usize,
        concat!("Size of: ", stringify!(Binder))
    );
    assert_eq!(
        ::core::mem::align_of::<Binder>(),
        8usize,
        concat!("Alignment of ", stringify!(Binder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Binder>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Binder),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Binder>())).ipc_buffer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Binder),
            "::",
            stringify!(ipc_buffer_size)
        )
    );
}
impl Binder {
    #[inline]
    pub fn created(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_created(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn initialized(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_transact_auto(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_transact_auto(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        created: bool,
        initialized: bool,
        has_transact_auto: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let created: u8 = unsafe { ::core::mem::transmute(created) };
            created as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let initialized: u8 = unsafe { ::core::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_transact_auto: u8 = unsafe { ::core::mem::transmute(has_transact_auto) };
            has_transact_auto as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn binderCreate(b: *mut Binder, id: s32);
}
extern "C" {
    pub fn binderClose(b: *mut Binder);
}
extern "C" {
    pub fn binderInitSession(b: *mut Binder) -> Result;
}
extern "C" {
    pub fn binderTransactParcel(
        b: *mut Binder,
        code: u32,
        parcel_data: *mut lang_items::c_void,
        parcel_data_size: usize,
        parcel_reply: *mut lang_items::c_void,
        parcel_reply_size: usize,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn binderConvertErrorCode(code: s32) -> Result;
}
extern "C" {
    pub fn binderAdjustRefcount(b: *mut Binder, addval: s32, type_: s32) -> Result;
}
extern "C" {
    pub fn binderGetNativeHandle(b: *mut Binder, unk0: u32, event_out: *mut Event) -> Result;
}
#[repr(C)]
pub struct ParcelHeader {
    pub payload_size: u32,
    pub payload_off: u32,
    pub objects_size: u32,
    pub objects_off: u32,
}
#[test]
fn bindgen_test_layout_ParcelHeader() {
    assert_eq!(
        ::core::mem::size_of::<ParcelHeader>(),
        16usize,
        concat!("Size of: ", stringify!(ParcelHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<ParcelHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(ParcelHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).payload_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).payload_off as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(payload_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).objects_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(objects_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ParcelHeader>())).objects_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ParcelHeader),
            "::",
            stringify!(objects_off)
        )
    );
}
#[repr(C)]
pub struct Parcel {
    pub payload: [u8; 1024usize],
    pub payload_size: u32,
    pub objects: *mut u8,
    pub objects_size: u32,
    pub capacity: u32,
    pub pos: u32,
}
#[test]
fn bindgen_test_layout_Parcel() {
    assert_eq!(
        ::core::mem::size_of::<Parcel>(),
        1056usize,
        concat!("Size of: ", stringify!(Parcel))
    );
    assert_eq!(
        ::core::mem::align_of::<Parcel>(),
        8usize,
        concat!("Alignment of ", stringify!(Parcel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).payload_size as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).objects as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).objects_size as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(objects_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).capacity as *const _ as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Parcel>())).pos as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(Parcel),
            "::",
            stringify!(pos)
        )
    );
}
extern "C" {
    pub fn parcelCreate(ctx: *mut Parcel);
}
extern "C" {
    pub fn parcelTransact(
        session: *mut Binder,
        code: u32,
        in_parcel: *mut Parcel,
        reply_parcel: *mut Parcel,
    ) -> Result;
}
extern "C" {
    pub fn parcelWriteData(
        ctx: *mut Parcel,
        data: *mut lang_items::c_void,
        data_size: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn parcelReadData(
        ctx: *mut Parcel,
        data: *mut lang_items::c_void,
        data_size: usize,
    ) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn parcelWriteInt32(ctx: *mut Parcel, val: s32);
}
extern "C" {
    pub fn parcelWriteUInt32(ctx: *mut Parcel, val: u32);
}
extern "C" {
    pub fn parcelWriteString16(ctx: *mut Parcel, str: *const lang_items::c_char);
}
extern "C" {
    pub fn parcelReadInt32(ctx: *mut Parcel) -> s32;
}
extern "C" {
    pub fn parcelReadUInt32(ctx: *mut Parcel) -> u32;
}
extern "C" {
    pub fn parcelWriteInterfaceToken(ctx: *mut Parcel, str: *const lang_items::c_char);
}
extern "C" {
    pub fn parcelReadFlattenedObject(ctx: *mut Parcel, size: *mut usize)
        -> *mut lang_items::c_void;
}
extern "C" {
    pub fn parcelWriteFlattenedObject(
        ctx: *mut Parcel,
        data: *mut lang_items::c_void,
        size: usize,
    ) -> *mut lang_items::c_void;
}
pub const PIXEL_FORMAT_RGBA_8888: _bindgen_ty_6 = 1;
pub const PIXEL_FORMAT_RGBX_8888: _bindgen_ty_6 = 2;
pub const PIXEL_FORMAT_RGB_888: _bindgen_ty_6 = 3;
pub const PIXEL_FORMAT_RGB_565: _bindgen_ty_6 = 4;
pub const PIXEL_FORMAT_BGRA_8888: _bindgen_ty_6 = 5;
pub const PIXEL_FORMAT_RGBA_5551: _bindgen_ty_6 = 6;
pub const PIXEL_FORMAT_RGBA_4444: _bindgen_ty_6 = 7;
pub const PIXEL_FORMAT_YCRCB_420_SP: _bindgen_ty_6 = 17;
pub const PIXEL_FORMAT_RAW16: _bindgen_ty_6 = 32;
pub const PIXEL_FORMAT_BLOB: _bindgen_ty_6 = 33;
pub const PIXEL_FORMAT_IMPLEMENTATION_DEFINED: _bindgen_ty_6 = 34;
pub const PIXEL_FORMAT_YCBCR_420_888: _bindgen_ty_6 = 35;
pub const PIXEL_FORMAT_Y8: _bindgen_ty_6 = 538982489;
pub const PIXEL_FORMAT_Y16: _bindgen_ty_6 = 540422489;
pub const PIXEL_FORMAT_YV12: _bindgen_ty_6 = 842094169;
pub type _bindgen_ty_6 = u32;
pub const GRALLOC_USAGE_SW_READ_NEVER: _bindgen_ty_7 = 0;
pub const GRALLOC_USAGE_SW_READ_RARELY: _bindgen_ty_7 = 2;
pub const GRALLOC_USAGE_SW_READ_OFTEN: _bindgen_ty_7 = 3;
pub const GRALLOC_USAGE_SW_READ_MASK: _bindgen_ty_7 = 15;
pub const GRALLOC_USAGE_SW_WRITE_NEVER: _bindgen_ty_7 = 0;
pub const GRALLOC_USAGE_SW_WRITE_RARELY: _bindgen_ty_7 = 32;
pub const GRALLOC_USAGE_SW_WRITE_OFTEN: _bindgen_ty_7 = 48;
pub const GRALLOC_USAGE_SW_WRITE_MASK: _bindgen_ty_7 = 240;
pub const GRALLOC_USAGE_HW_TEXTURE: _bindgen_ty_7 = 256;
pub const GRALLOC_USAGE_HW_RENDER: _bindgen_ty_7 = 512;
pub const GRALLOC_USAGE_HW_2D: _bindgen_ty_7 = 1024;
pub const GRALLOC_USAGE_HW_COMPOSER: _bindgen_ty_7 = 2048;
pub const GRALLOC_USAGE_HW_FB: _bindgen_ty_7 = 4096;
pub const GRALLOC_USAGE_EXTERNAL_DISP: _bindgen_ty_7 = 8192;
pub const GRALLOC_USAGE_PROTECTED: _bindgen_ty_7 = 16384;
pub const GRALLOC_USAGE_CURSOR: _bindgen_ty_7 = 32768;
pub const GRALLOC_USAGE_HW_VIDEO_ENCODER: _bindgen_ty_7 = 65536;
pub const GRALLOC_USAGE_HW_CAMERA_WRITE: _bindgen_ty_7 = 131072;
pub const GRALLOC_USAGE_HW_CAMERA_READ: _bindgen_ty_7 = 262144;
pub const GRALLOC_USAGE_HW_CAMERA_ZSL: _bindgen_ty_7 = 393216;
pub const GRALLOC_USAGE_HW_CAMERA_MASK: _bindgen_ty_7 = 393216;
pub const GRALLOC_USAGE_HW_MASK: _bindgen_ty_7 = 466688;
pub const GRALLOC_USAGE_RENDERSCRIPT: _bindgen_ty_7 = 1048576;
pub type _bindgen_ty_7 = u32;
pub const NATIVE_WINDOW_WIDTH: _bindgen_ty_8 = 0;
pub const NATIVE_WINDOW_HEIGHT: _bindgen_ty_8 = 1;
pub const NATIVE_WINDOW_FORMAT: _bindgen_ty_8 = 2;
pub type _bindgen_ty_8 = u32;
pub const NATIVE_WINDOW_API_CPU: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = u32;
pub const HAL_TRANSFORM_FLIP_H: _bindgen_ty_10 = 1;
pub const HAL_TRANSFORM_FLIP_V: _bindgen_ty_10 = 2;
pub const HAL_TRANSFORM_ROT_90: _bindgen_ty_10 = 4;
pub const HAL_TRANSFORM_ROT_180: _bindgen_ty_10 = 3;
pub const HAL_TRANSFORM_ROT_270: _bindgen_ty_10 = 7;
/// Transformation definitions
///
/// IMPORTANT NOTE:
/// HAL_TRANSFORM_ROT_90 is applied CLOCKWISE and AFTER HAL_TRANSFORM_FLIP_{H|V}.
///
pub type _bindgen_ty_10 = u32;
pub const NATIVE_WINDOW_TRANSFORM_FLIP_H: _bindgen_ty_11 = 1;
pub const NATIVE_WINDOW_TRANSFORM_FLIP_V: _bindgen_ty_11 = 2;
pub const NATIVE_WINDOW_TRANSFORM_ROT_90: _bindgen_ty_11 = 4;
pub const NATIVE_WINDOW_TRANSFORM_ROT_180: _bindgen_ty_11 = 3;
pub const NATIVE_WINDOW_TRANSFORM_ROT_270: _bindgen_ty_11 = 7;
pub type _bindgen_ty_11 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BqRect {
    pub left: s32,
    pub top: s32,
    pub right: s32,
    pub bottom: s32,
}
#[test]
fn bindgen_test_layout_BqRect() {
    assert_eq!(
        ::core::mem::size_of::<BqRect>(),
        16usize,
        concat!("Size of: ", stringify!(BqRect))
    );
    assert_eq!(
        ::core::mem::align_of::<BqRect>(),
        4usize,
        concat!("Alignment of ", stringify!(BqRect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqRect>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqRect),
            "::",
            stringify!(bottom)
        )
    );
}
#[repr(C)]
pub struct BqQueueBufferInput {
    pub __bindgen_anon_1: BqQueueBufferInput__bindgen_ty_1,
    pub isAutoTimestamp: s32,
    pub crop: BqRect,
    pub scalingMode: s32,
    pub transform: u32,
    pub stickyTransform: u32,
    pub unk: u32,
    pub swapInterval: u32,
    pub fence: NvMultiFence,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct BqQueueBufferInput__bindgen_ty_1 {
    pub timestamp: s64,
}
#[test]
fn bindgen_test_layout_BqQueueBufferInput__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<BqQueueBufferInput__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(BqQueueBufferInput__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<BqQueueBufferInput__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(BqQueueBufferInput__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqQueueBufferInput__bindgen_ty_1>())).timestamp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput__bindgen_ty_1),
            "::",
            stringify!(timestamp)
        )
    );
}
#[test]
fn bindgen_test_layout_BqQueueBufferInput() {
    assert_eq!(
        ::core::mem::size_of::<BqQueueBufferInput>(),
        84usize,
        concat!("Size of: ", stringify!(BqQueueBufferInput))
    );
    assert_eq!(
        ::core::mem::align_of::<BqQueueBufferInput>(),
        4usize,
        concat!("Alignment of ", stringify!(BqQueueBufferInput))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqQueueBufferInput>())).isAutoTimestamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(isAutoTimestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqQueueBufferInput>())).crop as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(crop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqQueueBufferInput>())).scalingMode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(scalingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqQueueBufferInput>())).transform as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqQueueBufferInput>())).stickyTransform as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(stickyTransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqQueueBufferInput>())).unk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(unk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqQueueBufferInput>())).swapInterval as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(swapInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqQueueBufferInput>())).fence as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferInput),
            "::",
            stringify!(fence)
        )
    );
}
#[repr(C)]
pub struct BqQueueBufferOutput {
    pub width: u32,
    pub height: u32,
    pub transformHint: u32,
    pub numPendingBuffers: u32,
}
#[test]
fn bindgen_test_layout_BqQueueBufferOutput() {
    assert_eq!(
        ::core::mem::size_of::<BqQueueBufferOutput>(),
        16usize,
        concat!("Size of: ", stringify!(BqQueueBufferOutput))
    );
    assert_eq!(
        ::core::mem::align_of::<BqQueueBufferOutput>(),
        4usize,
        concat!("Alignment of ", stringify!(BqQueueBufferOutput))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqQueueBufferOutput>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferOutput),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqQueueBufferOutput>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferOutput),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqQueueBufferOutput>())).transformHint as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferOutput),
            "::",
            stringify!(transformHint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqQueueBufferOutput>())).numPendingBuffers as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqQueueBufferOutput),
            "::",
            stringify!(numPendingBuffers)
        )
    );
}
#[repr(C)]
pub struct BqGraphicBuffer {
    pub magic: u32,
    pub width: u32,
    pub height: u32,
    pub stride: u32,
    pub format: u32,
    pub usage: u32,
    pub pid: u32,
    pub refcount: u32,
    pub numFds: u32,
    pub numInts: u32,
    pub data: BqGraphicBuffer__bindgen_ty_1,
}
#[repr(C)]
pub struct BqGraphicBuffer__bindgen_ty_1 {
    pub unk_x0: u32,
    pub nvmap_handle0: u32,
    pub unk_x8: u32,
    pub unk_xc: u32,
    pub unk_x10: u32,
    pub unk_x14: u32,
    pub unk_x18: u32,
    pub unk_x1c: u32,
    pub unk_x20: u32,
    pub width_unk0: u32,
    pub buffer_size0: u32,
    pub unk_x2c: u32,
    pub unk_x30: u32,
    pub width_unk1: u32,
    pub height_unk: u32,
    pub flags: u32,
    pub unk_x40: u32,
    pub unk_x44: u32,
    pub byte_stride: u32,
    pub nvmap_handle1: u32,
    pub buffer_offset: u32,
    pub unk_x54: u32,
    pub unk_x58: u32,
    pub unk_x5c: u32,
    pub unk_x60: u32,
    pub unk_x64: u32,
    pub unk_x68: u32,
    pub buffer_size1: u32,
    pub unk_x70: [u32; 51usize],
    pub __bindgen_anon_1: BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
pub struct BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1 {
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1>())).timestamp
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(timestamp)
        )
    );
}
#[test]
fn bindgen_test_layout_BqGraphicBuffer__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<BqGraphicBuffer__bindgen_ty_1>(),
        324usize,
        concat!("Size of: ", stringify!(BqGraphicBuffer__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<BqGraphicBuffer__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(BqGraphicBuffer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).nvmap_handle0 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(nvmap_handle0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x8 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_xc as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_xc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x10 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x14 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x18 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x1c as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x1c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x20 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).width_unk0 as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(width_unk0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).buffer_size0 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(buffer_size0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x2c as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x2c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x30 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).width_unk1 as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(width_unk1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).height_unk as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(height_unk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).flags as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x40 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x40)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x44 as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x44)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).byte_stride as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(byte_stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).nvmap_handle1 as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(nvmap_handle1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).buffer_offset as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(buffer_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x54 as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x54)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x58 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x58)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x5c as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x5c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x60 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x60)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x64 as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x68 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x68)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).buffer_size1 as *const _
                as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(buffer_size1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<BqGraphicBuffer__bindgen_ty_1>())).unk_x70 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer__bindgen_ty_1),
            "::",
            stringify!(unk_x70)
        )
    );
}
#[test]
fn bindgen_test_layout_BqGraphicBuffer() {
    assert_eq!(
        ::core::mem::size_of::<BqGraphicBuffer>(),
        364usize,
        concat!("Size of: ", stringify!(BqGraphicBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<BqGraphicBuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(BqGraphicBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).stride as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).usage as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).refcount as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).numFds as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(numFds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).numInts as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(numInts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<BqGraphicBuffer>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BqGraphicBuffer),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn bqRequestBuffer(b: *mut Binder, bufferIdx: s32, buf: *mut BqGraphicBuffer) -> Result;
}
extern "C" {
    pub fn bqDequeueBuffer(
        b: *mut Binder,
        async: bool,
        width: u32,
        height: u32,
        format: s32,
        usage: u32,
        buf: *mut s32,
        fence: *mut NvMultiFence,
    ) -> Result;
}
extern "C" {
    pub fn bqDetachBuffer(b: *mut Binder, slot: s32) -> Result;
}
extern "C" {
    pub fn bqQueueBuffer(
        b: *mut Binder,
        buf: s32,
        input: *mut BqQueueBufferInput,
        output: *mut BqQueueBufferOutput,
    ) -> Result;
}
extern "C" {
    pub fn bqCancelBuffer(b: *mut Binder, buf: s32, fence: *mut NvMultiFence) -> Result;
}
extern "C" {
    pub fn bqQuery(b: *mut Binder, what: s32, value: *mut s32) -> Result;
}
extern "C" {
    pub fn bqConnect(
        b: *mut Binder,
        api: s32,
        producerControlledByApp: bool,
        output: *mut BqQueueBufferOutput,
    ) -> Result;
}
extern "C" {
    pub fn bqDisconnect(b: *mut Binder, api: s32) -> Result;
}
extern "C" {
    pub fn bqSetPreallocatedBuffer(b: *mut Binder, buf: s32, input: *mut BqGraphicBuffer)
        -> Result;
}
extern "C" {
    pub fn nvgfxInitialize() -> Result;
}
extern "C" {
    pub fn nvgfxExit();
}
extern "C" {
    pub fn nvgfxSubmitGpfifo() -> Result;
}
extern "C" {
    pub fn nvgfxGetFramebuffer(buffer: *mut *mut u8, size: *mut usize, handle: *mut u32) -> Result;
}
#[repr(C)]
pub struct NvAddressSpace {
    pub fd: u32,
    pub has_init: bool,
}
#[test]
fn bindgen_test_layout_NvAddressSpace() {
    assert_eq!(
        ::core::mem::size_of::<NvAddressSpace>(),
        8usize,
        concat!("Size of: ", stringify!(NvAddressSpace))
    );
    assert_eq!(
        ::core::mem::align_of::<NvAddressSpace>(),
        4usize,
        concat!("Alignment of ", stringify!(NvAddressSpace))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvAddressSpace>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvAddressSpace),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvAddressSpace>())).has_init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvAddressSpace),
            "::",
            stringify!(has_init)
        )
    );
}
pub const NvPageSize_NvPageSize_4K: NvPageSize = 4096;
pub const NvPageSize_NvPageSize_64K: NvPageSize = 65536;
pub type NvPageSize = u32;
extern "C" {
    pub fn nvAddressSpaceCreate(a: *mut NvAddressSpace) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceClose(a: *mut NvAddressSpace);
}
extern "C" {
    pub fn nvAddressSpaceReserveAlign(
        a: *mut NvAddressSpace,
        align: NvPageSize,
        pages: u32,
        page_sz: NvPageSize,
        iova_out: *mut iova_t,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceReserveAtFixedAddr(
        a: *mut NvAddressSpace,
        addr: iova_t,
        pages: u32,
        page_sz: NvPageSize,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceReserveFull(a: *mut NvAddressSpace) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceMapBuffer(
        a: *mut NvAddressSpace,
        fd: u32,
        flags: u32,
        kind: NvKind,
        iova_out: *mut iova_t,
    ) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceUnmapBuffer(a: *mut NvAddressSpace, iova: iova_t) -> Result;
}
extern "C" {
    pub fn nvAddressSpaceBindToChannel(a: *mut NvAddressSpace, channel: *mut NvChannel) -> Result;
}
#[repr(C)]
pub struct NvBuffer {
    pub fd: u32,
    pub size: u32,
    pub cpu_addr: *mut lang_items::c_void,
    pub gpu_addr: iova_t,
    pub gpu_addr_texture: iova_t,
    pub addr_space: *mut NvAddressSpace,
    pub kind: NvKind,
    pub has_init: bool,
    pub is_cpu_cacheable: bool,
    pub is_gpu_cacheable: bool,
}
#[test]
fn bindgen_test_layout_NvBuffer() {
    assert_eq!(
        ::core::mem::size_of::<NvBuffer>(),
        48usize,
        concat!("Size of: ", stringify!(NvBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<NvBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(NvBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).cpu_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(cpu_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).gpu_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(gpu_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).gpu_addr_texture as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(gpu_addr_texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).addr_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(addr_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).kind as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).has_init as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(has_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).is_cpu_cacheable as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(is_cpu_cacheable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvBuffer>())).is_gpu_cacheable as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(NvBuffer),
            "::",
            stringify!(is_gpu_cacheable)
        )
    );
}
extern "C" {
    pub fn nvBufferInit() -> Result;
}
extern "C" {
    pub fn nvBufferGetNvmapFd() -> u32;
}
extern "C" {
    pub fn nvBufferExit();
}
extern "C" {
    pub fn nvBufferCreate(
        m: *mut NvBuffer,
        size: usize,
        align: u32,
        is_cpu_cacheable: bool,
        is_gpu_cacheable: bool,
        kind: NvKind,
        as_: *mut NvAddressSpace,
    ) -> Result;
}
extern "C" {
    pub fn nvBufferFree(m: *mut NvBuffer);
}
extern "C" {
    pub fn nvBufferGetCpuAddr(m: *mut NvBuffer) -> *mut lang_items::c_void;
}
extern "C" {
    pub fn nvBufferGetGpuAddr(m: *mut NvBuffer) -> iova_t;
}
extern "C" {
    pub fn nvBufferMapAsTexture(m: *mut NvBuffer, kind: NvKind) -> Result;
}
extern "C" {
    pub fn nvBufferGetGpuAddrTexture(m: *mut NvBuffer) -> iova_t;
}
#[repr(C)]
pub struct NvChannel {
    pub fd: u32,
    pub has_init: bool,
}
#[test]
fn bindgen_test_layout_NvChannel() {
    assert_eq!(
        ::core::mem::size_of::<NvChannel>(),
        8usize,
        concat!("Size of: ", stringify!(NvChannel))
    );
    assert_eq!(
        ::core::mem::align_of::<NvChannel>(),
        4usize,
        concat!("Alignment of ", stringify!(NvChannel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvChannel>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvChannel),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvChannel>())).has_init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NvChannel),
            "::",
            stringify!(has_init)
        )
    );
}
extern "C" {
    pub fn nvChannelCreate(c: *mut NvChannel, dev: *const lang_items::c_char) -> Result;
}
extern "C" {
    pub fn nvChannelClose(c: *mut NvChannel);
}
extern "C" {
    pub fn nvChannelSetPriority(c: *mut NvChannel, prio: NvChannelPriority) -> Result;
}
extern "C" {
    pub fn nvChannelSetTimeout(c: *mut NvChannel, timeout: u32) -> Result;
}
extern "C" {
    pub fn nvChannelSetNvmapFd(c: *mut NvChannel) -> Result;
}
extern "C" {
    pub fn nvInfoInit() -> Result;
}
extern "C" {
    pub fn nvInfoExit();
}
extern "C" {
    pub fn nvInfoGetZcullCtxSize() -> u32;
}
#[repr(C)]
pub struct NvCmdList {
    pub buffer: NvBuffer,
    pub offset: usize,
    pub num_cmds: usize,
    pub max_cmds: usize,
    pub parent: *mut NvGpu,
}
#[test]
fn bindgen_test_layout_NvCmdList() {
    assert_eq!(
        ::core::mem::size_of::<NvCmdList>(),
        80usize,
        concat!("Size of: ", stringify!(NvCmdList))
    );
    assert_eq!(
        ::core::mem::align_of::<NvCmdList>(),
        8usize,
        concat!("Alignment of ", stringify!(NvCmdList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvCmdList>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvCmdList),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvCmdList>())).offset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NvCmdList),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvCmdList>())).num_cmds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NvCmdList),
            "::",
            stringify!(num_cmds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvCmdList>())).max_cmds as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NvCmdList),
            "::",
            stringify!(max_cmds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvCmdList>())).parent as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NvCmdList),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn nvCmdListCreate(c: *mut NvCmdList, parent: *mut NvGpu, max_cmds: usize) -> Result;
}
extern "C" {
    pub fn nvCmdListClose(c: *mut NvCmdList);
}
extern "C" {
    pub fn nvCmdListGetGpuAddr(c: *mut NvCmdList) -> iova_t;
}
extern "C" {
    pub fn nvCmdListGetListSize(c: *mut NvCmdList) -> u64;
}
extern "C" {
    pub fn nvCmdListReset(c: *mut NvCmdList);
}
extern "C" {
    pub fn nvCmdListInsert(c: *mut NvCmdList, num_cmds: usize) -> *mut u32;
}
#[repr(C)]
pub struct NvGpfifo {
    pub parent: *mut NvChannel,
    pub syncpt_id: u32,
    pub num_entries: u32,
    pub entries: [nvioctl_gpfifo_entry; 2048usize],
}
#[test]
fn bindgen_test_layout_NvGpfifo() {
    assert_eq!(
        ::core::mem::size_of::<NvGpfifo>(),
        16400usize,
        concat!("Size of: ", stringify!(NvGpfifo))
    );
    assert_eq!(
        ::core::mem::align_of::<NvGpfifo>(),
        8usize,
        concat!("Alignment of ", stringify!(NvGpfifo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpfifo>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpfifo),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpfifo>())).syncpt_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpfifo),
            "::",
            stringify!(syncpt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpfifo>())).num_entries as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpfifo),
            "::",
            stringify!(num_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpfifo>())).entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpfifo),
            "::",
            stringify!(entries)
        )
    );
}
extern "C" {
    pub fn nvGpfifoCreate(f: *mut NvGpfifo, parent: *mut NvChannel) -> Result;
}
extern "C" {
    pub fn nvGpfifoClose(f: *mut NvGpfifo);
}
extern "C" {
    pub fn nvGpfifoAppendEntry(
        f: *mut NvGpfifo,
        start: iova_t,
        num_cmds: usize,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn nvGpfifoAppendCmdList(f: *mut NvGpfifo, cmd_list: *mut NvCmdList, flags: u32) -> Result;
}
extern "C" {
    pub fn nvGpfifoFlush(f: *mut NvGpfifo, fence_incr: u32, fence_out: *mut NvFence) -> Result;
}
#[repr(C)]
pub struct NvZcullContext {
    pub parent: *mut NvGpu,
    pub ctx_buf: NvBuffer,
}
#[test]
fn bindgen_test_layout_NvZcullContext() {
    assert_eq!(
        ::core::mem::size_of::<NvZcullContext>(),
        56usize,
        concat!("Size of: ", stringify!(NvZcullContext))
    );
    assert_eq!(
        ::core::mem::align_of::<NvZcullContext>(),
        8usize,
        concat!("Alignment of ", stringify!(NvZcullContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvZcullContext>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvZcullContext),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvZcullContext>())).ctx_buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvZcullContext),
            "::",
            stringify!(ctx_buf)
        )
    );
}
extern "C" {
    pub fn nvZcullContextCreate(z: *mut NvZcullContext, parent: *mut NvGpu) -> Result;
}
extern "C" {
    pub fn nvZcullContextClose(z: *mut NvZcullContext);
}
#[repr(C)]
pub struct Nv3DContext {
    pub parent: *mut NvGpu,
    pub obj_id: u64,
}
#[test]
fn bindgen_test_layout_Nv3DContext() {
    assert_eq!(
        ::core::mem::size_of::<Nv3DContext>(),
        16usize,
        concat!("Size of: ", stringify!(Nv3DContext))
    );
    assert_eq!(
        ::core::mem::align_of::<Nv3DContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Nv3DContext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nv3DContext>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Nv3DContext),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Nv3DContext>())).obj_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Nv3DContext),
            "::",
            stringify!(obj_id)
        )
    );
}
extern "C" {
    pub fn nv3DContextCreate(t: *mut Nv3DContext, parent: *mut NvGpu) -> Result;
}
extern "C" {
    pub fn nv3DContextClose(t: *mut Nv3DContext);
}
#[repr(C)]
pub struct NvErrorNotifier {
    pub parent: *mut NvGpu,
    pub event: Event,
    pub has_init: bool,
}
#[test]
fn bindgen_test_layout_NvErrorNotifier() {
    assert_eq!(
        ::core::mem::size_of::<NvErrorNotifier>(),
        24usize,
        concat!("Size of: ", stringify!(NvErrorNotifier))
    );
    assert_eq!(
        ::core::mem::align_of::<NvErrorNotifier>(),
        8usize,
        concat!("Alignment of ", stringify!(NvErrorNotifier))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvErrorNotifier>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvErrorNotifier),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvErrorNotifier>())).event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvErrorNotifier),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvErrorNotifier>())).has_init as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NvErrorNotifier),
            "::",
            stringify!(has_init)
        )
    );
}
extern "C" {
    pub fn nvErrorNotifierCreate(t: *mut NvErrorNotifier, parent: *mut NvGpu) -> Result;
}
extern "C" {
    pub fn nvErrorNotifierClose(t: *mut NvErrorNotifier);
}
extern "C" {
    pub fn nvErrorNotifierWait(t: *mut NvErrorNotifier, timeout: u64) -> Result;
}
extern "C" {
    pub fn nvErrorNotifierGetError(t: *mut NvErrorNotifier, out: *mut NvError) -> Result;
}
#[repr(C)]
pub struct NvGpu {
    pub addr_space: NvAddressSpace,
    pub gpu_channel: NvChannel,
    pub gpfifo: NvGpfifo,
    pub zcull_ctx: NvZcullContext,
    pub _3d_ctx: Nv3DContext,
    pub error_notifier: NvErrorNotifier,
}
#[test]
fn bindgen_test_layout_NvGpu() {
    assert_eq!(
        ::core::mem::size_of::<NvGpu>(),
        16512usize,
        concat!("Size of: ", stringify!(NvGpu))
    );
    assert_eq!(
        ::core::mem::align_of::<NvGpu>(),
        8usize,
        concat!("Alignment of ", stringify!(NvGpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpu>())).addr_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpu),
            "::",
            stringify!(addr_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpu>())).gpu_channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpu),
            "::",
            stringify!(gpu_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpu>())).gpfifo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpu),
            "::",
            stringify!(gpfifo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpu>())).zcull_ctx as *const _ as usize },
        16416usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpu),
            "::",
            stringify!(zcull_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpu>()))._3d_ctx as *const _ as usize },
        16472usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpu),
            "::",
            stringify!(_3d_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NvGpu>())).error_notifier as *const _ as usize },
        16488usize,
        concat!(
            "Offset of field: ",
            stringify!(NvGpu),
            "::",
            stringify!(error_notifier)
        )
    );
}
extern "C" {
    pub fn nvGpuCreate(g: *mut NvGpu) -> Result;
}
extern "C" {
    pub fn nvGpuClose(g: *mut NvGpu);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioDriverEtc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioDriver {
    pub etc: *mut AudioDriverEtc,
    pub config: AudioRendererConfig,
    pub in_mempools: *mut AudioRendererMemPoolInfoIn,
    pub in_channels: *mut AudioRendererChannelInfoIn,
    pub in_voices: *mut AudioRendererVoiceInfoIn,
    pub in_mixes: *mut AudioRendererMixInfoIn,
    pub in_sinks: *mut AudioRendererSinkInfoIn,
}
#[test]
fn bindgen_test_layout_AudioDriver() {
    assert_eq!(
        ::core::mem::size_of::<AudioDriver>(),
        72usize,
        concat!("Size of: ", stringify!(AudioDriver))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDriver>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioDriver))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).config as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_mempools as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_mempools)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_channels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_voices as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_voices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_mixes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_mixes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriver>())).in_sinks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriver),
            "::",
            stringify!(in_sinks)
        )
    );
}
extern "C" {
    pub fn audrvCreate(
        d: *mut AudioDriver,
        config: *const AudioRendererConfig,
        num_final_mix_channels: lang_items::c_int,
    ) -> Result;
}
extern "C" {
    pub fn audrvUpdate(d: *mut AudioDriver) -> Result;
}
extern "C" {
    pub fn audrvClose(d: *mut AudioDriver);
}
extern "C" {
    pub fn audrvMemPoolAdd(
        d: *mut AudioDriver,
        buffer: *mut lang_items::c_void,
        size: usize,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn audrvMemPoolRemove(d: *mut AudioDriver, id: lang_items::c_int) -> bool;
}
extern "C" {
    pub fn audrvMemPoolAttach(d: *mut AudioDriver, id: lang_items::c_int) -> bool;
}
extern "C" {
    pub fn audrvMemPoolDetach(d: *mut AudioDriver, id: lang_items::c_int) -> bool;
}
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Free: AudioDriverWaveBufState = 0;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Waiting: AudioDriverWaveBufState = 1;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Queued: AudioDriverWaveBufState = 2;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Playing: AudioDriverWaveBufState = 3;
pub const AudioDriverWaveBufState_AudioDriverWaveBufState_Done: AudioDriverWaveBufState = 4;
pub type AudioDriverWaveBufState = u32;
#[repr(C)]
pub struct AudioDriverWaveBuf {
    pub __bindgen_anon_1: AudioDriverWaveBuf__bindgen_ty_1,
    pub size: u64,
    pub start_sample_offset: s32,
    pub end_sample_offset: s32,
    pub context_addr: *const lang_items::c_void,
    pub context_sz: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub is_looping: bool,
    pub sequence_id: u32,
    pub next: *mut AudioDriverWaveBuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AudioDriverWaveBuf__bindgen_ty_1 {
    pub data_pcm16: *mut s16,
    pub data_adpcm: *mut u8,
    pub data_raw: *const lang_items::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_AudioDriverWaveBuf__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AudioDriverWaveBuf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AudioDriverWaveBuf__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDriverWaveBuf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf__bindgen_ty_1>())).data_pcm16 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1),
            "::",
            stringify!(data_pcm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf__bindgen_ty_1>())).data_adpcm as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1),
            "::",
            stringify!(data_adpcm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf__bindgen_ty_1>())).data_raw as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf__bindgen_ty_1),
            "::",
            stringify!(data_raw)
        )
    );
}
#[test]
fn bindgen_test_layout_AudioDriverWaveBuf() {
    assert_eq!(
        ::core::mem::size_of::<AudioDriverWaveBuf>(),
        56usize,
        concat!("Size of: ", stringify!(AudioDriverWaveBuf))
    );
    assert_eq!(
        ::core::mem::align_of::<AudioDriverWaveBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioDriverWaveBuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf>())).start_sample_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(start_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf>())).end_sample_offset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(end_sample_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<AudioDriverWaveBuf>())).context_addr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(context_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).context_sz as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(context_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).is_looping as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(is_looping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).sequence_id as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(sequence_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<AudioDriverWaveBuf>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioDriverWaveBuf),
            "::",
            stringify!(next)
        )
    );
}
impl AudioDriverWaveBuf {
    #[inline]
    pub fn state(&self) -> AudioDriverWaveBufState {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: AudioDriverWaveBufState) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: AudioDriverWaveBufState,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn audrvVoiceInit(
        d: *mut AudioDriver,
        id: lang_items::c_int,
        num_channels: lang_items::c_int,
        format: PcmFormat,
        sample_rate: lang_items::c_int,
    ) -> bool;
}
extern "C" {
    pub fn audrvVoiceDrop(d: *mut AudioDriver, id: lang_items::c_int);
}
extern "C" {
    pub fn audrvVoiceStop(d: *mut AudioDriver, id: lang_items::c_int);
}
extern "C" {
    pub fn audrvVoiceIsPlaying(d: *mut AudioDriver, id: lang_items::c_int) -> bool;
}
extern "C" {
    pub fn audrvVoiceAddWaveBuf(
        d: *mut AudioDriver,
        id: lang_items::c_int,
        wavebuf: *mut AudioDriverWaveBuf,
    ) -> bool;
}
extern "C" {
    pub fn audrvVoiceGetWaveBufSeq(d: *mut AudioDriver, id: lang_items::c_int) -> u32;
}
extern "C" {
    pub fn audrvVoiceGetPlayedSampleCount(d: *mut AudioDriver, id: lang_items::c_int) -> u32;
}
extern "C" {
    pub fn audrvVoiceGetVoiceDropsCount(d: *mut AudioDriver, id: lang_items::c_int) -> u32;
}
extern "C" {
    pub fn audrvVoiceSetBiquadFilter(
        d: *mut AudioDriver,
        id: lang_items::c_int,
        biquad_id: lang_items::c_int,
        a0: f32,
        a1: f32,
        a2: f32,
        b0: f32,
        b1: f32,
        b2: f32,
    );
}
extern "C" {
    pub fn audrvMixAdd(
        d: *mut AudioDriver,
        sample_rate: lang_items::c_int,
        num_channels: lang_items::c_int,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn audrvMixRemove(d: *mut AudioDriver, id: lang_items::c_int);
}
extern "C" {
    pub fn audrvDeviceSinkAdd(
        d: *mut AudioDriver,
        device_name: *const lang_items::c_char,
        num_channels: lang_items::c_int,
        channel_ids: *const u8,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn audrvSinkRemove(d: *mut AudioDriver, id: lang_items::c_int);
}
/// Structure representing an entry in the homebrew environment configuration.
#[repr(C)]
pub struct ConfigEntry {
    /// < Type of entry
    pub Key: u32,
    /// < Entry flags
    pub Flags: u32,
    /// < Entry arguments (type-specific)
    pub Value: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ConfigEntry() {
    assert_eq!(
        ::core::mem::size_of::<ConfigEntry>(),
        24usize,
        concat!("Size of: ", stringify!(ConfigEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<ConfigEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(ConfigEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConfigEntry>())).Key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigEntry),
            "::",
            stringify!(Key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConfigEntry>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigEntry),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConfigEntry>())).Value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConfigEntry),
            "::",
            stringify!(Value)
        )
    );
}
/// < Specifies that the entry **must** be processed by the homebrew application.
pub const EntryFlag_IsMandatory: _bindgen_ty_12 = 1;
/// Entry flags
pub type _bindgen_ty_12 = u32;
/// < Entry list terminator.
pub const EntryType_EndOfList: _bindgen_ty_13 = 0;
/// < Provides the handle to the main thread.
pub const EntryType_MainThreadHandle: _bindgen_ty_13 = 1;
/// < Provides a buffer containing information about the next homebrew application to load.
pub const EntryType_NextLoadPath: _bindgen_ty_13 = 2;
/// < Provides heap override information.
pub const EntryType_OverrideHeap: _bindgen_ty_13 = 3;
/// < Provides service override information.
pub const EntryType_OverrideService: _bindgen_ty_13 = 4;
/// < Provides argv.
pub const EntryType_Argv: _bindgen_ty_13 = 5;
/// < Provides syscall availability hints.
pub const EntryType_SyscallAvailableHint: _bindgen_ty_13 = 6;
/// < Provides APT applet type.
pub const EntryType_AppletType: _bindgen_ty_13 = 7;
/// < Indicates that APT is broken and should not be used.
pub const EntryType_AppletWorkaround: _bindgen_ty_13 = 8;
/// < Unused/reserved entry type, formerly used by StdioSockets.
pub const EntryType_Reserved9: _bindgen_ty_13 = 9;
/// < Provides the process handle.
pub const EntryType_ProcessHandle: _bindgen_ty_13 = 10;
/// < Provides the last load result.
pub const EntryType_LastLoadResult: _bindgen_ty_13 = 11;
/// < Provides random data used to seed the pseudo-random number generator.
pub const EntryType_RandomSeed: _bindgen_ty_13 = 14;
pub type _bindgen_ty_13 = u32;
/// < Use AppletType_Application instead of AppletType_SystemApplication.
pub const EnvAppletFlags_ApplicationOverride: _bindgen_ty_14 = 1;
pub type _bindgen_ty_14 = u32;
/// Loader return function.
pub type LoaderReturnFn =
    ::core::option::Option<unsafe extern "C" fn(result_code: lang_items::c_int)>;
extern "C" {
    /// @brief Parses the homebrew loader environment block (internally called).
    /// @param ctx Reserved.
    /// @param main_thread Reserved.
    /// @param saved_lr Reserved.
    pub fn envSetup(ctx: *mut lang_items::c_void, main_thread: Handle, saved_lr: LoaderReturnFn);
}
extern "C" {
    /// Retrieves the handle to the main thread.
    pub fn envGetMainThreadHandle() -> Handle;
}
extern "C" {
    /// Returns true if the application is running as NSO, otherwise NRO.
    pub fn envIsNso() -> bool;
}
extern "C" {
    /// Returns true if the environment has a heap override.
    pub fn envHasHeapOverride() -> bool;
}
extern "C" {
    /// Returns the address of the overriden heap.
    pub fn envGetHeapOverrideAddr() -> *mut lang_items::c_void;
}
extern "C" {
    /// Returns the size of the overriden heap.
    pub fn envGetHeapOverrideSize() -> u64;
}
extern "C" {
    /// Returns true if the environment has an argv array.
    pub fn envHasArgv() -> bool;
}
extern "C" {
    /// Returns the pointer to the argv array.
    pub fn envGetArgv() -> *mut lang_items::c_void;
}
extern "C" {
    /// @brief Returns whether a syscall is hinted to be available.
    /// @param svc Syscall number to test.
    /// @returns true if the syscall is available.
    pub fn envIsSyscallHinted(svc: u8) -> bool;
}
extern "C" {
    /// Returns the handle to the running homebrew process.
    pub fn envGetOwnProcessHandle() -> Handle;
}
extern "C" {
    /// Returns the loader's return function, to be called on program exit.
    pub fn envGetExitFuncPtr() -> LoaderReturnFn;
}
extern "C" {
    /// Sets the return function to be called on program exit.
    pub fn envSetExitFuncPtr(addr: LoaderReturnFn);
}
extern "C" {
    /// @brief Configures the next homebrew application to load.
    /// @param path Path to the next homebrew application to load (.nro).
    /// @param argv Argument string to pass.
    pub fn envSetNextLoad(
        path: *const lang_items::c_char,
        argv: *const lang_items::c_char,
    ) -> Result;
}
extern "C" {
    /// Returns true if the environment supports envSetNextLoad.
    pub fn envHasNextLoad() -> bool;
}
extern "C" {
    /// Returns the Result from the last NRO.
    pub fn envGetLastLoadResult() -> Result;
}
extern "C" {
    /// Returns true if the environment provides a random seed.
    pub fn envHasRandomSeed() -> bool;
}
extern "C" {
    /// @brief Retrieves the random seed provided by the environment.
    /// @param out Pointer to a u64[2] buffer which will contain the random seed on return.
    pub fn envGetRandomSeed(out: *mut u64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut __nxlink_host: in_addr;
}
extern "C" {
    pub fn nxlinkStdio() -> lang_items::c_int;
}
pub type _ssize_t = lang_items::c_long;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = lang_items::c_int;
pub type __blkcnt_t = lang_items::c_long;
pub type __blksize_t = lang_items::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = lang_items::c_long;
pub type __pid_t = lang_items::c_int;
pub type __dev_t = lang_items::c_short;
pub type __uid_t = lang_items::c_ushort;
pub type __gid_t = lang_items::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = lang_items::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = lang_items::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = lang_items::c_long;
pub type _fpos_t = lang_items::c_long;
pub type __size_t = lang_items::c_ulong;
pub type __ssize_t = _ssize_t;
pub type wint_t = lang_items::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: lang_items::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [lang_items::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut lang_items::c_void;
pub type __clock_t = lang_items::c_ulong;
pub type __time_t = lang_items::c_long;
pub type __clockid_t = lang_items::c_ulong;
pub type __timer_t = lang_items::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = lang_items::c_ushort;
pub type __suseconds_t = lang_items::c_long;
pub type __useconds_t = lang_items::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __sigset_t = lang_items::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = lang_items::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: lang_items::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = lang_items::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: lang_items::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> lang_items::c_int;
}
extern "C" {
    pub fn pselect(
        __n: lang_items::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> lang_items::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = lang_items::c_uchar;
pub type u_short = lang_items::c_ushort;
pub type u_int = lang_items::c_uint;
pub type u_long = lang_items::c_ulong;
pub type ushort = lang_items::c_ushort;
pub type uint = lang_items::c_uint;
pub type ulong = lang_items::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = lang_items::c_ulong;
pub type daddr_t = lang_items::c_long;
pub type caddr_t = *mut lang_items::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: lang_items::c_int,
    pub stackaddr: *mut lang_items::c_void,
    pub stacksize: lang_items::c_int,
    pub contentionscope: lang_items::c_int,
    pub inheritsched: lang_items::c_int,
    pub schedpolicy: lang_items::c_int,
    pub schedparam: sched_param,
    pub detachstate: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).contentionscope as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).inheritsched as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedpolicy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: lang_items::c_int,
    pub recursive: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutexattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).recursive as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: lang_items::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_condattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: lang_items::c_int,
    pub init_executed: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).init_executed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
extern "C" {
    /// Convert a UTF-8 sequence into a UTF-32 codepoint
    ///
    /// @param[out] out Output codepoint
    /// @param[in]  in  Input sequence
    ///
    /// @returns number of input code units consumed
    /// @returns -1 for error
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> isize;
}
extern "C" {
    /// Convert a UTF-16 sequence into a UTF-32 codepoint
    ///
    /// @param[out] out Output codepoint
    /// @param[in]  in  Input sequence
    ///
    /// @returns number of input code units consumed
    /// @returns -1 for error
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> isize;
}
extern "C" {
    /// Convert a UTF-32 codepoint into a UTF-8 sequence
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input codepoint
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out must be able to store 4 code units
    pub fn encode_utf8(out: *mut u8, in_: u32) -> isize;
}
extern "C" {
    /// Convert a UTF-32 codepoint into a UTF-16 sequence
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input codepoint
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out must be able to store 2 code units
    pub fn encode_utf16(out: *mut u16, in_: u32) -> isize;
}
extern "C" {
    /// Convert a UTF-8 sequence into a UTF-16 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-8 sequence into a UTF-32 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-16 sequence into a UTF-8 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-16 sequence into a UTF-32 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-32 sequence into a UTF-8 sequence
    ///
    /// Fills the output buffer up to \a len code units.
    /// Returns the number of code units that the input would produce;
    /// if it returns greater than \a len, the output has been
    /// truncated.
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    /// Convert a UTF-32 sequence into a UTF-16 sequence
    ///
    /// @param[out] out Output sequence
    /// @param[in]  in  Input sequence (null-terminated)
    /// @param[in]  len Output length
    ///
    /// @returns number of output code units produced
    /// @returns -1 for error
    ///
    /// @note \a out is not null-terminated
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: usize) -> isize;
}
/// Renderer interface for the console.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConsoleRenderer {
    pub init: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole) -> bool>,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole)>,
    pub drawChar: ::core::option::Option<
        unsafe extern "C" fn(
            con: *mut PrintConsole,
            x: lang_items::c_int,
            y: lang_items::c_int,
            c: lang_items::c_int,
        ),
    >,
    pub scrollWindow: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole)>,
    pub flushAndSwap: ::core::option::Option<unsafe extern "C" fn(con: *mut PrintConsole)>,
}
#[test]
fn bindgen_test_layout_ConsoleRenderer() {
    assert_eq!(
        ::core::mem::size_of::<ConsoleRenderer>(),
        40usize,
        concat!("Size of: ", stringify!(ConsoleRenderer))
    );
    assert_eq!(
        ::core::mem::align_of::<ConsoleRenderer>(),
        8usize,
        concat!("Alignment of ", stringify!(ConsoleRenderer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).deinit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).drawChar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(drawChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).scrollWindow as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(scrollWindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleRenderer>())).flushAndSwap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleRenderer),
            "::",
            stringify!(flushAndSwap)
        )
    );
}
/// A font struct for the console.
#[repr(C)]
pub struct ConsoleFont {
    /// < A pointer to the font graphics
    pub gfx: *const lang_items::c_void,
    /// < Offset to the first valid character in the font table
    pub asciiOffset: u16,
    /// < Number of characters in the font graphics
    pub numChars: u16,
    pub tileWidth: u16,
    pub tileHeight: u16,
}
#[test]
fn bindgen_test_layout_ConsoleFont() {
    assert_eq!(
        ::core::mem::size_of::<ConsoleFont>(),
        16usize,
        concat!("Size of: ", stringify!(ConsoleFont))
    );
    assert_eq!(
        ::core::mem::align_of::<ConsoleFont>(),
        8usize,
        concat!("Alignment of ", stringify!(ConsoleFont))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).gfx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(gfx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).asciiOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(asciiOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).numChars as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(numChars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).tileWidth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(tileWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ConsoleFont>())).tileHeight as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ConsoleFont),
            "::",
            stringify!(tileHeight)
        )
    );
}
/// @brief Console structure used to store the state of a console render context.
///
/// Default values from consoleGetDefault();
/// @code
/// PrintConsole defaultConsole =
/// {
/// //Font:
/// {
/// default_font_bin, //font gfx
/// 0, //first ascii character in the set
/// 256, //number of characters in the font set
/// 16, //tile width
/// 16, //tile height
/// },
/// NULL, //renderer
/// 0,0, //cursorX cursorY
/// 0,0, //prevcursorX prevcursorY
/// 80, //console width
/// 45, //console height
/// 0,  //window x
/// 0,  //window y
/// 80, //window width
/// 45, //window height
/// 3, //tab size
/// 7, // foreground color
/// 0, // background color
/// 0, // flags
/// false //console initialized
/// };
/// @endcode
#[repr(C)]
pub struct PrintConsole {
    /// < Font of the console
    pub font: ConsoleFont,
    /// < Renderer of the console
    pub renderer: *mut ConsoleRenderer,
    /// < Current X location of the cursor (as a tile offset by default)
    pub cursorX: lang_items::c_int,
    /// < Current Y location of the cursor (as a tile offset by default)
    pub cursorY: lang_items::c_int,
    /// < Internal state
    pub prevCursorX: lang_items::c_int,
    /// < Internal state
    pub prevCursorY: lang_items::c_int,
    /// < Width of the console hardware layer in characters
    pub consoleWidth: lang_items::c_int,
    /// < Height of the console hardware layer in characters
    pub consoleHeight: lang_items::c_int,
    /// < Window X location in characters
    pub windowX: lang_items::c_int,
    /// < Window Y location in characters
    pub windowY: lang_items::c_int,
    /// < Window width in characters
    pub windowWidth: lang_items::c_int,
    /// < Window height in characters
    pub windowHeight: lang_items::c_int,
    /// < Size of a tab
    pub tabSize: lang_items::c_int,
    /// < Foreground color
    pub fg: lang_items::c_int,
    /// < Background color
    pub bg: lang_items::c_int,
    /// < Reverse/bright flags
    pub flags: lang_items::c_int,
    /// < True if the console is initialized
    pub consoleInitialised: bool,
}
#[test]
fn bindgen_test_layout_PrintConsole() {
    assert_eq!(
        ::core::mem::size_of::<PrintConsole>(),
        88usize,
        concat!("Size of: ", stringify!(PrintConsole))
    );
    assert_eq!(
        ::core::mem::align_of::<PrintConsole>(),
        8usize,
        concat!("Alignment of ", stringify!(PrintConsole))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).font as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).renderer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).cursorX as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(cursorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).cursorY as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(cursorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).prevCursorX as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(prevCursorX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).prevCursorY as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(prevCursorY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).consoleWidth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).consoleHeight as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowX as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowY as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowWidth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).windowHeight as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(windowHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).tabSize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(tabSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).fg as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(fg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).bg as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(bg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PrintConsole>())).flags as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PrintConsole>())).consoleInitialised as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PrintConsole),
            "::",
            stringify!(consoleInitialised)
        )
    );
}
/// < Swallows prints to stderr
pub const debugDevice_debugDevice_NULL: debugDevice = 0;
/// < Outputs stderr debug statements using svcOutputDebugString, which can then be captured by interactive debuggers
pub const debugDevice_debugDevice_SVC: debugDevice = 1;
/// < Directs stderr debug statements to Switch console window
pub const debugDevice_debugDevice_CONSOLE: debugDevice = 2;
pub const debugDevice_debugDevice_3DMOO: debugDevice = 1;
/// Console debug devices supported by libnx.
pub type debugDevice = u32;
extern "C" {
    /// @brief Loads the font into the console.
    /// @param console Pointer to the console to update, if NULL it will update the current console.
    /// @param font The font to load.
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    /// @brief Sets the print window.
    /// @param console Console to set, if NULL it will set the current console window.
    /// @param x X location of the window.
    /// @param y Y location of the window.
    /// @param width Width of the window.
    /// @param height Height of the window.
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: lang_items::c_int,
        y: lang_items::c_int,
        width: lang_items::c_int,
        height: lang_items::c_int,
    );
}
extern "C" {
    /// @brief Gets a pointer to the console with the default values.
    /// This should only be used when using a single console or without changing the console that is returned, otherwise use consoleInit().
    /// @return A pointer to the console with the default values.
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    /// @brief Make the specified console the render target.
    /// @param console A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)).
    /// @return A pointer to the previous console.
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    /// @brief Initialise the console.
    /// @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
    /// @return A pointer to the current console.
    pub fn consoleInit(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    /// @brief Deinitialise the console.
    /// @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
    pub fn consoleExit(console: *mut PrintConsole);
}
extern "C" {
    /// @brief Updates the console, submitting a new frame to the display.
    /// @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
    /// @remark This function should be called periodically. Failure to call this function will result in lack of screen updating.
    pub fn consoleUpdate(console: *mut PrintConsole);
}
extern "C" {
    /// @brief Initializes debug console output on stderr to the specified device.
    /// @param device The debug device (or devices) to output debug print statements to.
    pub fn consoleDebugInit(device: debugDevice);
}
extern "C" {
    /// Clears the screan by using printf("\x1b[2J");
    pub fn consoleClear();
}
#[repr(C)]
pub struct UsbCommsInterfaceInfo {
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
}
#[test]
fn bindgen_test_layout_UsbCommsInterfaceInfo() {
    assert_eq!(
        ::core::mem::size_of::<UsbCommsInterfaceInfo>(),
        3usize,
        concat!("Size of: ", stringify!(UsbCommsInterfaceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbCommsInterfaceInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbCommsInterfaceInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbCommsInterfaceInfo>())).bInterfaceClass as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbCommsInterfaceInfo),
            "::",
            stringify!(bInterfaceClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbCommsInterfaceInfo>())).bInterfaceSubClass as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbCommsInterfaceInfo),
            "::",
            stringify!(bInterfaceSubClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<UsbCommsInterfaceInfo>())).bInterfaceProtocol as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbCommsInterfaceInfo),
            "::",
            stringify!(bInterfaceProtocol)
        )
    );
}
extern "C" {
    /// Initializes usbComms with the default number of interfaces (1)
    pub fn usbCommsInitialize() -> Result;
}
extern "C" {
    /// Initializes usbComms with a specific number of interfaces.
    pub fn usbCommsInitializeEx(num_interfaces: u32, infos: *const UsbCommsInterfaceInfo)
        -> Result;
}
extern "C" {
    /// Exits usbComms.
    pub fn usbCommsExit();
}
extern "C" {
    /// Sets whether to throw a fatal error in usbComms{Read/Write}* on failure, or just return the transferred size. By default (false) the latter is used.
    pub fn usbCommsSetErrorHandling(flag: bool);
}
extern "C" {
    /// Read data with the default interface.
    pub fn usbCommsRead(buffer: *mut lang_items::c_void, size: usize) -> usize;
}
extern "C" {
    /// Write data with the default interface.
    pub fn usbCommsWrite(buffer: *const lang_items::c_void, size: usize) -> usize;
}
extern "C" {
    /// Same as usbCommsRead except with the specified interface.
    pub fn usbCommsReadEx(buffer: *mut lang_items::c_void, size: usize, interface: u32) -> usize;
}
extern "C" {
    /// Same as usbCommsWrite except with the specified interface.
    pub fn usbCommsWriteEx(buffer: *const lang_items::c_void, size: usize, interface: u32)
        -> usize;
}
/// Open directory struct
#[repr(C)]
pub struct fsdev_dir_t {
    /// < "fsdv"
    pub magic: u32,
    /// < File descriptor
    pub fd: FsDir,
    /// < Current entry index
    pub index: isize,
    /// < Current batch size
    pub size: usize,
    /// < Temporary storage for reading entries
    pub entry_data: [FsDirectoryEntry; 32usize],
}
#[test]
fn bindgen_test_layout_fsdev_dir_t() {
    assert_eq!(
        ::core::mem::size_of::<fsdev_dir_t>(),
        25120usize,
        concat!("Size of: ", stringify!(fsdev_dir_t))
    );
    assert_eq!(
        ::core::mem::align_of::<fsdev_dir_t>(),
        8usize,
        concat!("Alignment of ", stringify!(fsdev_dir_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fsdev_dir_t>())).entry_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fsdev_dir_t),
            "::",
            stringify!(entry_data)
        )
    );
}
extern "C" {
    /// Initializes and mounts the sdmc device if accessible. Also initializes current working directory to point to the folder containing the path to the executable (argv[0]), if it is provided by the environment.
    pub fn fsdevMountSdmc() -> Result;
}
extern "C" {
    /// Mounts the input fs with the specified device name. fsdev will handle closing the fs when required, including when fsdevMountDevice() fails.
    /// Returns -1 when any errors occur.
    pub fn fsdevMountDevice(name: *const lang_items::c_char, fs: FsFileSystem)
        -> lang_items::c_int;
}
extern "C" {
    /// Unmounts the specified device.
    pub fn fsdevUnmountDevice(name: *const lang_items::c_char) -> lang_items::c_int;
}
extern "C" {
    /// Uses fsFsCommit() with the specified device. This must be used after any savedata-write operations(not just file-write). This should be used after each file-close where file-writing was done.
    /// This is not used automatically at device unmount.
    pub fn fsdevCommitDevice(name: *const lang_items::c_char) -> Result;
}
extern "C" {
    /// Returns the FsFileSystem for the specified device. Returns NULL when the specified device isn't found.
    pub fn fsdevGetDeviceFileSystem(name: *const lang_items::c_char) -> *mut FsFileSystem;
}
extern "C" {
    /// Returns the FsFileSystem for the default device (SD card), if mounted. Used internally by romfs_dev.
    pub fn fsdevGetDefaultFileSystem() -> *mut FsFileSystem;
}
extern "C" {
    /// This calls fsFsSetArchiveBit on the filesystem specified by the input absolute path.
    pub fn fsdevSetArchiveBit(path: *const lang_items::c_char) -> Result;
}
extern "C" {
    /// Unmounts all devices and cleans up any resources used by the FS driver.
    pub fn fsdevUnmountAll() -> Result;
}
/// RomFS header.
#[repr(C)]
pub struct romfs_header {
    /// < Size of the header.
    pub headerSize: u64,
    /// < Offset of the directory hash table.
    pub dirHashTableOff: u64,
    /// < Size of the directory hash table.
    pub dirHashTableSize: u64,
    /// < Offset of the directory table.
    pub dirTableOff: u64,
    /// < Size of the directory table.
    pub dirTableSize: u64,
    /// < Offset of the file hash table.
    pub fileHashTableOff: u64,
    /// < Size of the file hash table.
    pub fileHashTableSize: u64,
    /// < Offset of the file table.
    pub fileTableOff: u64,
    /// < Size of the file table.
    pub fileTableSize: u64,
    /// < Offset of the file data.
    pub fileDataOff: u64,
}
#[test]
fn bindgen_test_layout_romfs_header() {
    assert_eq!(
        ::core::mem::size_of::<romfs_header>(),
        80usize,
        concat!("Size of: ", stringify!(romfs_header))
    );
    assert_eq!(
        ::core::mem::align_of::<romfs_header>(),
        8usize,
        concat!("Alignment of ", stringify!(romfs_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).headerSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(headerSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirHashTableOff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirHashTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirHashTableSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirHashTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirTableOff as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).dirTableSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(dirTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileHashTableOff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileHashTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileHashTableSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileHashTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileTableOff as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileTableOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileTableSize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileTableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<romfs_header>())).fileDataOff as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(romfs_header),
            "::",
            stringify!(fileDataOff)
        )
    );
}
/// RomFS directory.
#[repr(C)]
pub struct romfs_dir {
    /// < Offset of the parent directory.
    pub parent: u32,
    /// < Offset of the next sibling directory.
    pub sibling: u32,
    /// < Offset of the first child directory.
    pub childDir: u32,
    /// < Offset of the first file.
    pub childFile: u32,
    /// < Directory hash table pointer.
    pub nextHash: u32,
    /// < Name length.
    pub nameLen: u32,
    /// < Name. (UTF-8)
    pub name: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_romfs_dir() {
    assert_eq!(
        ::core::mem::size_of::<romfs_dir>(),
        24usize,
        concat!("Size of: ", stringify!(romfs_dir))
    );
    assert_eq!(
        ::core::mem::align_of::<romfs_dir>(),
        4usize,
        concat!("Alignment of ", stringify!(romfs_dir))
    );
}
/// RomFS file.
#[repr(C)]
pub struct romfs_file {
    /// < Offset of the parent directory.
    pub parent: u32,
    /// < Offset of the next sibling file.
    pub sibling: u32,
    /// < Offset of the file's data.
    pub dataOff: u64,
    /// < Length of the file's data.
    pub dataSize: u64,
    /// < File hash table pointer.
    pub nextHash: u32,
    /// < Name length.
    pub nameLen: u32,
    /// < Name. (UTF-8)
    pub name: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_romfs_file() {
    assert_eq!(
        ::core::mem::size_of::<romfs_file>(),
        32usize,
        concat!("Size of: ", stringify!(romfs_file))
    );
    assert_eq!(
        ::core::mem::align_of::<romfs_file>(),
        8usize,
        concat!("Alignment of ", stringify!(romfs_file))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct romfs_mount {
    _unused: [u8; 0],
}
extern "C" {
    /// @brief Mounts the Application's RomFS.
    /// @param mount Output mount handle
    pub fn romfsMount(mount: *mut *mut romfs_mount) -> Result;
}
extern "C" {
    /// @brief Mounts RomFS from an open file.
    /// @param file FsFile of the RomFS image.
    /// @param offset Offset of the RomFS within the file.
    /// @param mount Output mount handle
    pub fn romfsMountFromFile(file: FsFile, offset: u64, mount: *mut *mut romfs_mount) -> Result;
}
extern "C" {
    /// @brief Mounts RomFS from an open storage.
    /// @param storage FsStorage of the RomFS image.
    /// @param offset Offset of the RomFS within the storage.
    /// @param mount Output mount handle
    pub fn romfsMountFromStorage(
        storage: FsStorage,
        offset: u64,
        mount: *mut *mut romfs_mount,
    ) -> Result;
}
extern "C" {
    /// Bind the RomFS mount
    pub fn romfsBind(mount: *mut romfs_mount) -> Result;
}
extern "C" {
    /// Unmounts the RomFS device.
    pub fn romfsUnmount(mount: *mut romfs_mount) -> Result;
}
/// Configuration structure for socketInitalize
#[repr(C)]
pub struct SocketInitConfig {
    /// < Observed 1 on 2.0 LibAppletWeb, 2 on 3.0.
    pub bsdsockets_version: u32,
    /// < Size of the TCP transfer (send) buffer (initial or fixed).
    pub tcp_tx_buf_size: u32,
    /// < Size of the TCP recieve buffer (initial or fixed).
    pub tcp_rx_buf_size: u32,
    /// < Maximum size of the TCP transfer (send) buffer. If it is 0, the size of the buffer is fixed to its initial value.
    pub tcp_tx_buf_max_size: u32,
    /// < Maximum size of the TCP receive buffer. If it is 0, the size of the buffer is fixed to its initial value.
    pub tcp_rx_buf_max_size: u32,
    /// < Size of the UDP transfer (send) buffer (typically 0x2400 bytes).
    pub udp_tx_buf_size: u32,
    /// < Size of the UDP receive buffer (typically 0xA500 bytes).
    pub udp_rx_buf_size: u32,
    /// < Number of buffers for each socket (standard values range from 1 to 8).
    pub sb_efficiency: u32,
    /// < For getaddrinfo.
    pub serialized_out_addrinfos_max_size: usize,
    /// < For gethostbyname/gethostbyaddr.
    pub serialized_out_hostent_max_size: usize,
    /// < For name gethostbyname/getaddrinfo: bypass the Name Server Daemon.
    pub bypass_nsd: bool,
    /// < For DNS requests: timeout or 0.
    pub dns_timeout: lang_items::c_int,
}
#[test]
fn bindgen_test_layout_SocketInitConfig() {
    assert_eq!(
        ::core::mem::size_of::<SocketInitConfig>(),
        56usize,
        concat!("Size of: ", stringify!(SocketInitConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<SocketInitConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(SocketInitConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).bsdsockets_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(bsdsockets_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_tx_buf_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_tx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_rx_buf_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_tx_buf_max_size as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_tx_buf_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).tcp_rx_buf_max_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(tcp_rx_buf_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).udp_tx_buf_size as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(udp_tx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).udp_rx_buf_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(udp_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SocketInitConfig>())).sb_efficiency as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(sb_efficiency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).serialized_out_addrinfos_max_size
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(serialized_out_addrinfos_max_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SocketInitConfig>())).serialized_out_hostent_max_size
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(serialized_out_hostent_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SocketInitConfig>())).bypass_nsd as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(bypass_nsd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SocketInitConfig>())).dns_timeout as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketInitConfig),
            "::",
            stringify!(dns_timeout)
        )
    );
}
extern "C" {
    /// Fetch the default configuration for the socket driver.
    pub fn socketGetDefaultInitConfig() -> *const SocketInitConfig;
}
extern "C" {
    /// Initalize the socket driver.
    pub fn socketInitialize(config: *const SocketInitConfig) -> Result;
}
extern "C" {
    /// Fetch the last bsd:u/s Switch result code (thread-local).
    pub fn socketGetLastBsdResult() -> Result;
}
extern "C" {
    /// Fetch the last sfdnsres Switch result code (thread-local).
    pub fn socketGetLastSfdnsresResult() -> Result;
}
extern "C" {
    /// Deinitialize the socket driver.
    pub fn socketExit();
}
pub type __uint128_t = [u64; 2];
pub type __int128_t = [u64; 2];
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: lang_items::c_uint,
    pub fp_offset: lang_items::c_uint,
    pub overflow_arg_area: *mut lang_items::c_void,
    pub reg_save_area: *mut lang_items::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
